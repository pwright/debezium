// This file provides hints for an IDE how to render the preview, for example, in IntelliJ.
// This is mostly intended to define attributes.
// Read more at: https://intellij-asciidoc-plugin.ahus1.de/docs/users-guide/features/advanced/asciidoctorconfig-file.html

// Duplicate values for the preview that are defined in another repository in the Antora playbook
:prodname: Debezium
:jira-url: 'https://issues.redhat.com'

// Define attributes that are used downstream so that an editor known that they exist and doesn't show them in warnings.
:product!:

// Use the website's preview stylesheet for the preview.
// Update to the AsciiDoc plugin for IntelliJ version 0.37.49 or later for the best experience.
:linkcss:
:stylesdir: https://debezium.io/documentation/debezium-antora/css
:stylesheet: preview.css

:source-highlighter: highlightjs
// enable following to see product docs
//:product:
// AsciiDoc Attributes
// DO NOT EDIT - generated from antora.yml
:debezium-version: 2.7.0.Final
:debezium-kafka-version: 3.7.0
:debezium-docker-label: 2.7
:DockerKafkaConnect: registry.redhat.io/amq7/amq-streams-kafka-28-rhel8:1.8.0
:groovy-version: 4.0.17
:assemblies: ../assemblies
:modules: ../../modules
:mysql-version: 8.2
:strimzi-version: 0.18.0
:apicurio-version: 2.5.11.Final
:db2-version: 11.5.0.0
:ojdbc8-version: 21.11.0.0
:informix-jdbc-version: 4.50.10
:ifx-changestream-version: 1.1.3
:community: True
:registry: Apicurio Registry
:registry-name-full: Apicurio API and Schema Registry
:link-avro-serialization: configuration/avro.adoc
:link-cassandra-connector: connectors/cassandra.adoc
:link-cloud-events: integrations/cloudevents.adoc
:link-connectors: connectors/index.adoc
:link-content-based-routing: transformations/content-based-routing.adoc
:link-custom-converters: development/converters.adoc
:link-db2-connector: connectors/db2.adoc
:link-debezium-monitoring: operations/monitoring.adoc
:link-debezium-server: operations/debezium-server.adoc
:link-engine: development/engine.adoc
:link-event-flattening: transformations/event-flattening.adoc
:link-event-record-changes: transformations/event-changes.adoc
:link-filtering: transformations/filtering.adoc
:link-install-debezium: install.adoc
:link-jdbc-connector: connectors/jdbc.adoc
:link-mongodb-connector: connectors/mongodb.adoc
:link-mongodb-event-flattening: transformations/mongodb-event-flattening.adoc
:link-mongodb-outbox-event-router: transformations/mongodb-outbox-event-router.adoc
:link-mysql-connector: connectors/mysql.adoc
:link-notification: configuration/notification.adoc
:link-oracle-connector: connectors/oracle.adoc
:link-outbox-event-router: transformations/outbox-event-router.adoc
:link-postgresql-connector: connectors/postgresql.adoc
:link-postgresql-plugins: postgres-plugins.adoc
:link-prefix: xref
:link-serdes: integrations/serdes.adoc
:link-signalling: configuration/signalling.adoc
:link-smt-predicates: transformations/applying-transformations-selectively.adoc
:link-sqlserver-connector: connectors/sqlserver.adoc
:link-transformations: transformations/index.adoc
:link-topic-auto-creation: configuration/topic-auto-create-config.adoc
:link-topic-routing: transformations/topic-routing.adoc
:link-tutorial: tutorial.adoc
:link-vitess-connector: connectors/vitess.adoc
:link-informix-connector: connectors/informix.adoc
:link-spanner-connector: connectors/spanner.adoc
:link-mysql-plugin-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-connector-mysql&v=LATEST&c=plugin&e=tar.gz
:link-postgres-plugin-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-connector-postgres&v=LATEST&c=plugin&e=tar.gz
:link-mongodb-plugin-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-connector-mongodb&v=LATEST&c=plugin&e=tar.gz
:link-sqlserver-plugin-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-connector-sqlserver&v=LATEST&c=plugin&e=tar.gz
:link-oracle-plugin-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-connector-oracle&v=LATEST&c=plugin&e=tar.gz
:link-db2-plugin-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-connector-db2&v=LATEST&c=plugin&e=tar.gz
:link-cassandra-3-plugin-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-connector-cassandra-3&v=LATEST&c=plugin&e=tar.gz
:link-cassandra-4-plugin-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-connector-cassandra-4&v=LATEST&c=plugin&e=tar.gz
:link-vitess-plugin-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-connector-vitess&v=LATEST&c=plugin&e=tar.gz
:link-spanner-plugin-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-connector-spanner&v=LATEST&c=plugin&e=tar.gz
:link-jdbc-plugin-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-connector-jdbc&v=LATEST&c=plugin&e=tar.gz
:link-informix-plugin-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-connector-informix&v=LATEST&c=plugin&e=tar.gz
:link-server-snapshot: https://s01.oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&g=io.debezium&a=debezium-server-dist&v=LATEST&e=tar.gz
:link-kafka-docs: https://kafka.apache.org/documentation
:link-java7-standard-names: https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#MessageDigest
:name-tutorial: Debezium Tutorial

= User guide

== High level

//partialsdir needs to be defined wrt page that references that attribute
:partialsdir: modules/ROOT/partials

:leveloffset: +2

// Category: debezium-using
// Type: concept
// ModuleID: description-of-debezium-features
// Title: Description of Debezium features
[id="debezium-features"]
= {prodname} Features

:linkattrs:
:icons: font

{prodname} is a set of source connectors for Apache Kafka Connect. Each connector
ingests changes from a different database by using that database's features for change data capture (CDC).
Unlike other approaches, such as polling or dual writes,
log-based CDC as implemented by {prodname}:

* Ensures that *all data changes are captured*.
* Produces change events with a *very low delay* while avoiding increased CPU usage required for frequent polling. For example, for MySQL or PostgreSQL, the delay is in the millisecond range.
* Requires *no changes to your data model*, such as a "Last Updated" column.
* Can *capture deletes*.
* Can *capture old record state and additional metadata* such as transaction ID and causing query, depending on the database's capabilities and configuration.

link:https://debezium.io/blog/2018/07/19/advantages-of-log-based-change-data-capture/[Five Advantages of Log-Based Change Data Capture] is a blog post that provides more details.

{prodname} connectors capture data changes with a range of related capabilities and options:

* *Snapshots:* optionally, an initial snapshot of a database's current state can be taken if a connector is started and not all logs still exist. Typically, this is the case when the database has been running for some time and has discarded transaction logs that are no longer needed for transaction recovery or replication. There are different modes for performing snapshots, including support for _incremental_ snapshots, which can be triggered at connector runtime. For more details, see the documentation for the connector that you are using.
* *Filters:* you can configure the set of captured schemas, tables and columns with include/exclude list filters.
* *Masking:* the values from specific columns can be masked, for example, when they contain sensitive data.
* *Monitoring:* most connectors can be monitored by using JMX.
* Ready-to-use *message transformations* for message routing, filtering, event flattening, and more; see xref:transformations/index.adoc[Transformations] for an overview of all the SMTs coming with {prodname}.

See the xref:{link-connectors}[connector documentation] for a list of all supported databases and detailed information about the features and configuration options of each connector.

{prodname} can also be used as xref:development/engine.adoc[library embedded] into your JVM-based applications;
via xref:operations/debezium-server.adoc[Debezium Server], you can emit change events to messaging infrastructure like Amazon Kinesis, Google Cloud Pub/Sub, Apache Pulsar, etc.

:leveloffset!:
:leveloffset: +2

// Category: debezium-using
// Type: concept
// ModuleID: description-of-debezium-architecture
// Title: Description of Debezium architecture
[id="debezium-architecture"]
= {prodname} Architecture

Most commonly, you deploy {prodname} by means of Apache {link-kafka-docs}/#connect[Kafka Connect].
Kafka Connect is a framework and runtime for implementing and operating:


* Source connectors such as {prodname} that send records into Kafka
* Sink connectors that propagate records from Kafka topics to other systems

The following image shows the architecture of a change data capture pipeline based on {prodname}:

image::debezium-architecture.png[{prodname} Architecture]

As shown in the image, the {prodname} connectors for MySQL and PostgresSQL are deployed to capture changes to these two types of databases. Each {prodname} connector establishes a connection to its source database:

* The MySQL connector uses a client library for accessing the `binlog`.
* The PostgreSQL connector reads from a logical replication stream.

Kafka Connect operates as a separate service besides the Kafka broker.

By default, changes from one database table are written to a Kafka topic whose name corresponds to the table name.
If needed, you can adjust the destination topic name by configuring {prodname}'s {link-prefix}:{link-topic-routing}#topic-routing[topic routing transformation]. For example, you can:

* Route records to a topic whose name is different from the table's name
* Stream change event records for multiple tables into a single topic

After change event records are in Apache Kafka, different connectors in the Kafka Connect eco-system can stream the records to other systems and databases such as Elasticsearch, data warehouses and analytics systems, or caches such as Infinispan.
Depending on the chosen sink connector, you might need to configure {prodname}'s {link-prefix}:{link-event-flattening}#new-record-state-extraction[new record state extraction] transformation. This Kafka Connect SMT propagates the `after` structure from {prodname}'s change event to the sink connector. This is in place of the verbose change event record that is propagated by default.

== {prodname} Server

Another way to deploy {prodname} is using the xref:operations/debezium-server.adoc[{prodname} server].
The {prodname} server is a configurable, ready-to-use application that streams change events from a source database to a variety of messaging infrastructures.

The following image shows the architecture of a change data capture pipeline that uses the {prodname} server:

image::debezium-server-architecture.png[{prodname} Architecture]

The {prodname} server is configured to use one of the {prodname} source connectors to capture changes from the source database.
Change events can be serialized to different formats like JSON or Apache Avro and then will be sent to one of a variety of messaging infrastructures such as Amazon Kinesis, Google Cloud Pub/Sub, or Apache Pulsar.

== Debezium Engine

Yet an alternative way for using the {prodname} connectors is the xref:development/engine.adoc[Debezium engine].
In this case, {prodname} will not be run via Kafka Connect, but as a library embedded into your custom Java applications.
This can be useful for either consuming change events within your application itself,
without the needed for deploying complete Kafka and Kafka Connect clusters,
or for streaming changes to alternative messaging brokers such as Amazon Kinesis.
You can find https://github.com/debezium/debezium-examples/tree/main/kinesis[an example] for the latter in the examples repository.

:leveloffset!:

:partialsdir: ../../partials/

//connectors

:leveloffset: +1

// Category: debezium-using
// Type: assembly
[id="debezium-connector-for-mysql"]
= {prodname} connector for MySQL

:context: mysql
:data-collection: table
:database-port: 3306
:mbean-name: {context}
:connector-file: {context}
:connector-class: MySql
:connector-name: MySQL
:include-list-example: inventory.*
:toc:
:toc-placement: macro
:linkattrs:
:icons: font
:source-highlighter: highlight.js
:MYSQL:
toc::[]

:leveloffset: +1

{connector-name} has a binary log (binlog) that records all operations in the order in which they are committed to the database.
This includes changes to table schemas as well as changes to the data in tables.
{connector-name} uses the binlog for replication and recovery.

The {prodname} {connector-name} connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics.
Client applications read those Kafka topics.

Because {connector-name} is typically set up to purge binlogs after a specified period of time, the {connector-name} connector performs an initial _consistent snapshot_ of each of your databases.
The {connector-name} connector reads the binlog from the point at which the snapshot was made.

For information about the {connector-name} Database versions that are compatible with this connector, see the link:https://debezium.io/releases/[{prodname} release overview].


:leveloffset: 1

// Type: assembly
// ModuleID: how-debezium-mysql-connectors-work
// Title: How {prodname} MySQL connectors work
[[how-the-mysql-connector-works]]
== How the connector works

:leveloffset: +1


An overview of the {connector-name} topologies that the connector supports is useful for planning your application.
To optimally configure and run a {prodname} {connector-name} connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names.


:leveloffset: 1

// Type: concept
// ModuleID: mysql-topologies-supported-by-debezium-connectors
// Title: MySQL topologies supported by {prodname} connectors
[id="supported-mysql-topologies"]
=== Supported MySQL topologies

:leveloffset: +1

The {prodname} {connector-name} connector supports the following {connector-name} topologies:

Standalone::
When a single {connector-name} server is used, the server must have the binlog enabled so the {prodname} {connector-name} connector can monitor the server.
This is often acceptable, since the binary log can also be used as an incremental
link:https://dev.mysql.com/doc/refman/{mysql-version}/en/backup-methods.html
[backup].
In this case, the {connector-name} connector always connects to and follows this standalone {connector-name} server instance.

Primary and replica::
The {prodname} {connector-name} connector can follow one of the primary servers, or one of the replicas (_if that replica has its binlog enabled_), but the connector detects changes only in the cluster that is visible to that server.
Generally, this is not a problem except for the multi-primary topologies.
+
The connector records its position in the server’s binlog, which is different on each server in the cluster.
Therefore, the connector must follow just one {connector-name} server instance.
If that server fails, that server must be restarted or recovered before the connector can continue.

High available clusters::
A variety of
https://dev.mysql.com/doc/mysql-ha-scalability/en/
[high availability] solutions exist for {connector-name}, and they make it significantly easier to tolerate and almost immediately recover from problems and failures.
Because
most
HA {connector-name} clusters use GTIDs, replicas are able to track all of the changes that occur on any primary server.



Multi-primary::
link:https://dev.mysql.com/doc/refman/{mysql-version}/en/mysql-cluster-replication-multi-source.html[Network Database (NDB) cluster replication]
uses one or more {connector-name} replica nodes that each replicate from multiple primary servers.
Cluster replication provides a powerful way to aggregate the replication of multiple {connector-name} clusters.
This topology requires the use of GTIDs.
+
A {prodname} {connector-name} connector can use these multi-primary {connector-name} replicas as sources, and can fail over to different multi-primary {connector-name} replicas as long as the new replica is caught up to the old replica.
That is, the new replica has all transactions that were seen on the first replica.
This works even if the connector is using only a subset of databases and/or tables, because the connector can be configured to include or exclude specific GTID sources when attempting to reconnect to a new multi-primary {connector-name} replica and find the correct position in the binlog.

Hosted::
The {prodname} {connector-name} connector can use hosted database options such as Amazon RDS and Amazon Aurora.
+
Because these hosted options do not permit the use of global read locks, the connector uses table-level locks when it creates a consistent snapshot.


:leveloffset: 1

// Type: concept
// Title: How {prodname} MySQL connectors handle database schema changes
[[mysql-schema-history-topic]]
=== Schema history topic

:leveloffset: +1

When a database client queries a database, the client uses the database’s current schema.
However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded.
Also, a connector cannot necessarily apply the current schema to every event.
If an event is relatively old, it's possible that it was recorded before the current schema was applied.

To ensure correct processing of events that occur after a schema change, {connector-name} includes in the transaction log not only the row-level changes that affect the data, but also the DDL statements that are applied to the database.
As the connector encounters these DDL statements in the binlog, it parses them and updates an in-memory representation of each table’s schema.
The connector uses this schema representation to identify the structure of the tables at the time of each insert, update, or delete operation and to produce the appropriate change event.
In a separate database schema history Kafka topic, the connector records all DDL statements along with the position in the binlog where each DDL statement appeared.

When the connector restarts after either a crash or a graceful stop, it starts reading the binlog from a specific position, that is, from a specific point in time.
The connector rebuilds the table structures that existed at this point in time by reading the database schema history Kafka topic and parsing all DDL statements up to the point in the binlog where the connector is starting.

This database schema history topic is for internal connector use only.
Optionally, the connector can also xref:{context}-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].

When the {connector-name} connector captures changes in a table to which a schema change tool such as `gh-ost` or `pt-online-schema-change` is applied, there are helper tables created during the migration process.
You must configure the connector to capture changes that occur in these helper tables.
If consumers do not need the records the connector generates for helper tables, configure a {link-prefix}:{link-filtering}#message-filtering[single message transform (SMT)] to remove these records from the messages that the connector emits.

.Additional resources

* xref:{context}-topic-names[Default names for topics] that receive {prodname} event records.

:leveloffset: 1

// Type: concept
// Title: How {prodname} MySQL connectors expose database schema changes
[id="mysql-schema-change-topic"]
=== Schema change topic

:leveloffset: +1

You can configure a {prodname} {connector-name} connector to produce schema change events that describe schema changes that are applied to tables in the database.
The connector writes schema change events to a Kafka topic named `_<topicPrefix>_`, where `_topicPrefix_` is the namespace specified in the xref:{context}-property-topic-prefix[`topic.prefix`] connector configuration property.
Messages that the connector sends to the schema change topic contain a payload, and, optionally, also contain the schema of the change event message.

The schema for the schema change event has the following elements:

`name`:: The name of the schema change event message.
`type`:: The type of the change event message.
`version`:: The version of the schema. The version is an integer that is incremented each time the schema is changed.
`fields`:: The fields that are included in the change event message.

.Example: Schema of the {connector-name} connector schema change topic
The following example shows a typical schema in JSON format.

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {
    "type": "struct",
    "fields": [
      {
        "type": "string",
        "optional": false,
        "field": "databaseName"
      }
    ],
    "optional": false,
    "name": "io.debezium.connector.{context}.SchemaChangeKey",
    "version": 1
  },
  "payload": {
    "databaseName": "inventory"
  }
}
----

The payload of a schema change event message includes the following elements:

`ddl`:: Provides the SQL `CREATE`, `ALTER`, or `DROP` statement that results in the schema change.
`databaseName`:: The name of the database to which the DDL statements are applied.
The value of `databaseName` serves as the message key.
`pos`:: The position in the binlog where the statements appear.
`tableChanges`::  A structured representation of the entire table schema after the schema change.
The `tableChanges` field contains an array that includes entries for each column of the table.
Because the structured representation presents data in JSON or Avro format, consumers can easily read messages without first processing them through a DDL parser.

[IMPORTANT]
====
For a table that is in capture mode, the connector not only stores the history of schema changes in the schema change topic, but also in an internal database schema history topic.
The internal database schema history topic is for connector use only, and it is not intended for direct use by consuming applications.
Ensure that applications that require notifications about schema changes consume that information only from the schema change topic.
====

[IMPORTANT]
====
Never partition the database schema history topic.
For the database schema history topic to function correctly, it must maintain a consistent, global order of the event records that the connector emits to it.

To ensure that the topic is not split among partitions, set the partition count for the topic by using one of the following methods:

* If you create the database schema history topic manually, specify a partition count of `1`.
* If you use the Apache Kafka broker to create the database schema history topic automatically, the topic is created, set the value of the link:{link-kafka-docs}/#brokerconfigs_num.partitions[Kafka `num.partitions`] configuration option to `1`.
====

[WARNING]
====
The format of the messages that a connector emits to its schema change topic is in an incubating state and is subject to change without notice.
====

.Example: Message emitted to the {connector-name} connector schema change topic
The following example shows a typical schema change message in JSON format.
The message contains a logical representation of the table schema.

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": { },
  "payload": {
      "source": {  // <1>
        "version": "{debezium-version}",
        "connector": "{context}",
        "name": "{context}",
        "ts_ms": 1651535750218, // <2>
        "ts_us": 1651535750218000, // <2>
        "ts_ns": 1651535750218000000, // <2>
        "snapshot": "false",
        "db": "inventory",
        "sequence": null,
        "table": "customers",
        "server_id": 223344,
        "gtid": null,
        "file": "{context}-bin.000003",
        "pos": 570,
        "row": 0,
        "thread": null,
        "query": null
      },
      "databaseName": "inventory", <3>
      "schemaName": null,
      "ddl": "ALTER TABLE customers ADD middle_name varchar(255) AFTER first_name", <4>
      "tableChanges": [  <5>
        {
          "type": "ALTER", <6>
          "id": "\"inventory\".\"customers\"", <7>
          "table": {    <8>
            "defaultCharsetName": "utf8mb4",
            "primaryKeyColumnNames": [  <9>
              "id"
            ],
            "columns": [  <10>
              {
                "name": "id",
                "jdbcType": 4,
                "nativeType": null,
                "typeName": "INT",
                "typeExpression": "INT",
                "charsetName": null,
                "length": null,
                "scale": null,
                "position": 1,
                "optional": false,
                "autoIncremented": true,
                "generated": true
              },
              {
                "name": "first_name",
                "jdbcType": 12,
                "nativeType": null,
                "typeName": "VARCHAR",
                "typeExpression": "VARCHAR",
                "charsetName": "utf8mb4",
                "length": 255,
                "scale": null,
                "position": 2,
                "optional": false,
                "autoIncremented": false,
                "generated": false
              },
              {
                "name": "middle_name",
                "jdbcType": 12,
                "nativeType": null,
                "typeName": "VARCHAR",
                "typeExpression": "VARCHAR",
                "charsetName": "utf8mb4",
                "length": 255,
                "scale": null,
                "position": 3,
                "optional": true,
                "autoIncremented": false,
                "generated": false
              },
              {
                "name": "last_name",
                "jdbcType": 12,
                "nativeType": null,
                "typeName": "VARCHAR",
                "typeExpression": "VARCHAR",
                "charsetName": "utf8mb4",
                "length": 255,
                "scale": null,
                "position": 4,
                "optional": false,
                "autoIncremented": false,
                "generated": false
              },
              {
                "name": "email",
                "jdbcType": 12,
                "nativeType": null,
                "typeName": "VARCHAR",
                "typeExpression": "VARCHAR",
                "charsetName": "utf8mb4",
                "length": 255,
                "scale": null,
                "position": 5,
                "optional": false,
                "autoIncremented": false,
                "generated": false
            }
          ],
          "attributes": [ <11>
            {
              "customAttribute": "attributeValue"
            }
          ]
        }
      }
    ]
  }
}

----

.Descriptions of fields in messages emitted to the schema change topic
[cols="1,4,5",options="header"]
|===
|Item |Field name |Description

|1
|`source`
|The `source` field is structured exactly as standard data change events that the connector writes to table-specific topics.
This field is useful to correlate events on different topics.

|2
|`ts_ms`, `ts_us`, `ts_ns`
|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task. +
 +
In the source object, ts_ms indicates the time that the change was made in the database. By comparing the value for payload.source.ts_ms with the value for payload.ts_ms, you can determine the lag between the source database update and Debezium.

|3
|`databaseName` +
`schemaName`
|Identifies the database and the schema that contains the change.
The value of the `databaseName` field is used as the message key for the record.

|4
|`ddl`
|This field contains the DDL that is responsible for the schema change.
The `ddl` field can contain multiple DDL statements.
Each statement applies to the database in the `databaseName` field.
Multiple DDL statements appear in the order in which they were applied to the database. +
 +
Clients can submit multiple DDL statements that apply to multiple databases.
If {connector-name} applies them atomically, the connector takes the DDL statements in order, groups them by database, and creates a schema change event for each group.
If {connector-name} applies them individually, the connector creates a separate schema change event for each statement.

|5
|`tableChanges`
|An array of one or more items that contain the schema changes generated by a DDL command.

|6
|`type`
a|Describes the kind of change. The value is one of the following:

`CREATE`:: Table created.
`ALTER`:: Table modified.
`DROP`:: Table deleted.

|7
|`id`
|Full identifier of the table that was created, altered, or dropped.
In the case of a table rename, this identifier is a concatenation of `_<old>_,_<new>_` table names.

|8
|`table`
|Represents table metadata after the applied change.

|9
|`primaryKeyColumnNames`
|List of columns that compose the table's primary key.

|10
|`columns`
|Metadata for each column in the changed table.

|11
|`attributes`
|Custom attribute metadata for each table change.

|===

For more information, see xref:{context}-schema-history-topic[schema history topic].

:leveloffset: 1


// Type: concept
// Title: How {prodname} MySQL connectors perform database snapshots
[[mysql-snapshots]]
=== Snapshots

:leveloffset: +1

When a {prodname} {connector-name} connector is first started, it performs an initial _consistent snapshot_ of your database.
This snapshot enables the connector to establish a baseline for the current state of the database.

{prodname} can use different modes when it runs a snapshot.
The snapshot mode is determined by the xref:{context}-property-snapshot-mode[`snapshot.mode`] configuration property.
The default value of the property is `initial`.
You can customize the way that the connector creates snapshots by changing the value of the `snapshot.mode` property.


The connector completes a series of tasks when it performs the snapshot.
The exact steps vary with the snapshot mode and with the table locking policy that is in effect for the database.
The {prodname} {connector-name} connector completes different steps when it performs an initial snapshot that uses a xref:{context}-initial-snapshot-workflow-with-global-read-lock[global read lock] or xref:{context}-initial-snapshot-workflow-with-table-level-locks[table-level locks].

:leveloffset: 1

// Type: concept
[id="mysql-initial-snapshot-workflow-with-global-read-lock"]
==== Initial snapshots that use a global read lock

:leveloffset: +1

You can customize the way that the connector creates snapshots by changing the value of the `snapshot.mode` property.
If you configure a different snapshot mode, the connector completes the snapshot by using a modified version of this workflow.
For information about the snapshot process in environments that do not permit global read locks, see the xref:{context}-initial-snapshot-workflow-with-table-level-locks[snapshot workflow for table-level locks].

.Default workflow that the {prodname} {connector-name} connector uses to perform an initial snapshot with a global read lock
The following table shows the steps in the workflow that {prodname} follows to create a snapshot with a global read lock.

[cols="1a,9a",options="header",subs="+attributes"]
|===
|Step |Action

|1
a|Establish a connection to the database.

|2
|Determine the tables to be captured.
By default, the connector captures the data for all non-system tables.
After the snapshot completes, the connector continues to stream data for the specified tables.
If you want the connector to capture data only from specific tables you can direct the connector to capture the data for only a subset of tables or table elements by setting properties such as xref:{context}-property-table-include-list[`table.include.list`] or xref:{context}-property-table-exclude-list[`table.exclude.list`].

|3
|Obtain a global read lock on the tables to be captured to block _writes_ by other database clients. +
 +
The snapshot itself does not prevent other clients from applying DDL that might interfere with the connector's attempt to read the binlog position and table schemas.
The connector retains the global read lock while it reads the binlog position, and releases the lock as described in a later step.

|4
a|Start a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_. +
 +
[NOTE]
====
The use of these isolation semantics can slow the progress of the snapshot.
If the snapshot takes too long to complete, consider using a different isolation configuration, or skip the initial snapshot and run an xref:debezium-{context}-incremental-snapshots[incremental snapshot] instead.
====

|5
|Read the current binlog position.

|6
a|Capture the structure of all tables in the database, or all tables that are designated for capture.
The connector persists schema information in its internal database schema history topic, including all necessary `DROP...` and `CREATE...` DDL statements. +
The schema history provides information about the structure that is in effect when a change event occurs.
 +
[NOTE]
====
By default, the connector captures the schema of every table in the database, including tables that are not configured for capture.
If tables are not configured for capture, the initial snapshot captures only their structure; it does not capture any table data. +
 +
For more information about why snapshots persist schema information for tables that you did not include in the initial snapshot, see xref:understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables[Understanding why initial snapshots capture the schema for all tables].
====

|7
|Release the global read lock obtained in Step 3.
Other database clients can now write to the database.

|8
a|At the binlog position that the connector read in Step 5, the connector begins to scan the tables that are designated for capture.
During the scan, the connector completes the following tasks:

. Confirms that the table was created before the snapshot began.
If the table was created after the snapshot began, the connector skips the table.
After the snapshot is complete, and the connector transitions to streaming, it emits change events for any tables that were created after the snapshot began.
. Produces a `read` event for each row that is captured from a table.
All `read` events contain the same binlog position, which is the position that was obtained in step 5.
. Emits each `read` event to the Kafka topic for the source table.
. Releases data table locks, if applicable.

|9
|Commit the transaction.

|10
|Record the successful completion of the snapshot in the connector offsets.

|===

The resulting initial snapshot captures the current state of each row in the captured tables.
From this baseline state, the connector captures subsequent changes as they occur.

After the snapshot process begins, if the process is interrupted due to connector failure, rebalancing, or other reasons, the process restarts after the connector restarts.

After the connector completes the initial snapshot, it continues streaming from the position that it read in Step 5 so that it does not miss any updates.

If the connector stops again for any reason, after it restarts, it resumes streaming changes from where it previously left off.

After the connector restarts, if the logs have been pruned, the connector's position in the logs might no longer available.
The connector then fails, and returns an error that indicates that a new snapshot is required.
To configure the connector to automatically initiate a snapshot in this situation, set the value of the xref:{context}-property-snapshot-mode[`snapshot.mode`] property to `when_needed`.
For more tips on troubleshooting the {prodname} {connector-name} connector, see xref:{context}-when-things-go-wrong[behavior when things go wrong].

:leveloffset: 1

// Type: concept
[id="mysql-initial-snapshot-workflow-with-table-level-locks"]
==== Initial snapshots that use table-level locks

:leveloffset: +1

In some database environments, administrators do not permit global read locks.
If the {prodname} {connector-name} connector detects that global read locks are not permitted, the connector uses table-level locks when it performs snapshots.
For the connector to perform a snapshot that uses table-level locks, the database account that the {prodname} connector uses to connect to {connector-name} must have `LOCK TABLES` privileges.

.Default workflow that the {prodname} {connector-name} connector uses to perform an initial snapshot with table-level locks
The following table shows the steps in the workflow that {prodname} follows to create a snapshot with table-level read locks.
For information about the snapshot process in environments that do not permit global read locks, see the xref:{context}-initial-snapshot-workflow-with-global-read-lock[snapshot workflow for global read locks].

[cols="1,9",options="header",subs="+attributes"]
|===
|Step |Action

|1
|Establish a connection to the database.

|2
|Determine the tables to be captured.
By default, the connector captures all non-system tables.
To have the connector capture a subset of tables or table elements, you can set a number of `include` and `exclude` properties to filter the data, for example, xref:{context}-property-table-include-list[`table.include.list`] or xref:{context}-property-table-exclude-list[`table.exclude.list`].

|3
|Obtain table-level locks.

|4
a|Start a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.

|5
a|Read the current binlog position.

|6
a|Read the schema of the databases and tables for which the connector is configured to capture changes.
The connector persists schema information in its internal database schema history topic, including all necessary `DROP...` and `CREATE...` DDL statements. +
The schema history provides information about the structure that is in effect when a change event occurs.
 +
[NOTE]
====
By default, the connector captures the schema of every table in the database, including tables that are not configured for capture.
If tables are not configured for capture, the initial snapshot captures only their structure; it does not capture any table data.

For more information about why snapshots persist schema information for tables that you did not include in the initial snapshot, see xref:understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables[Understanding why initial snapshots capture the schema for all tables].
====

|7
a|At the binlog position that the connector read in Step 5, the connector begins to scan the tables that are designated for capture.
During the scan, the connector completes the following tasks:

. Confirms that the table was created before the snapshot began.
If the table was created after the snapshot began, the connector skips the table.
After the snapshot is complete, and the connector transitions to streaming, it emits change events for any tables that were created after the snapshot began.
. Produces a `read` event for each row that is captured from a table.
All `read` events contain the same binlog position, which is the position that was obtained in step 5.
. Emits each `read` event to the Kafka topic for the source table.
. Releases data table locks, if applicable.

|8
a|Commit the transaction.

|9
|Release the table-level locks.
Other database clients can now write to any previously locked tables.

|10
a|Record the successful completion of the snapshot in the connector offsets.

|===

[id="{context}-connector-snapshot-mode-options"]
.Settings for `snapshot.mode` connector configuration property
[cols="30%a,70%a",options="header"]
|===
|Setting |Description

|`always`
|The connector performs a snapshot every time that it starts.
The snapshot includes the structure and data of the captured tables.
Specify this value to populate topics with a complete representation of the data from the captured tables every time that the connector starts.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

|`initial`
|The connector performs a database snapshot as described in the xref:{context}-initial-snapshot-workflow-with-global-read-lock[default workflow for creating an initial snapshot].
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

|`initial_only`
|The connector performs a database snapshot.
After the snapshot completes, the connector stops, and does not stream event records for subsequent database changes.

|`schema_only`
|Deprecated, see `no_data`.

|`no_data`
|The connector captures the structure of all relevant tables, performing all the steps described in the xref:{context}-initial-snapshot-workflow-with-global-read-lock[default workflow for creating an initial snapshot], except that it does not create `READ` events to represent the data set at the point of the connector's start-up (Step 7.2).

|`never`
|When the connector starts, rather than performing a snapshot, it immediately begins to stream event records for subsequent database changes.
This option is under consideration for future deprecation, in favor of the `no_data` option.

|`schema_only_recovery`
|Deprecated, see `recovery`.

|`recovery`
|Set this option to restore a database schema history topic that is lost or corrupted.
After a restart, the connector runs a snapshot that rebuilds the topic from the source tables.
You can also set the property to periodically prune a database schema history topic that experiences unexpected growth. +
 +
WARNING: Do not use this mode to perform a snapshot if schema changes were committed to the database after the last connector shutdown.

|`when_needed`
|After the connector starts, it performs a snapshot only if it detects one of the following circumstances:

* It cannot detect any topic offsets.
* A previously recorded offset specifies a log position that is not available on the server.

|`configuration_based`
|Set the snapshot mode to `configuration_based` to control snapshot behavior through the set of connector properties that have the prefix 'snapshot.mode.configuration.based'.

|`custom`
|The `custom` snapshot mode lets you inject your own implementation of the `io.debezium.spi.snapshot.Snapshotter` interface.
Set the `snapshot.mode.custom.name` configuration property to the name provided by the `name()` method of your implementation.
The name is specified on the classpath of your Kafka Connect cluster.
If you use the `EmbeddedEngine`, the name is included in the connector JAR file.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|===
For more information, see xref:{context}-property-snapshot-mode[`snapshot.mode`] in the table of connector configuration properties.

:leveloffset: 1


// ModuleID: mysql-description-of-why-initial-snapshots-capture-the-schema-history-for-all-tables
// Title: Description of why initial snapshots capture the schema history for all tables
// Type: concept
[id="understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables"]
==== Understanding why initial snapshots capture the schema history for all tables

:leveloffset: +1

The initial snapshot that a connector runs captures two types of information:

Table data::
Information about `INSERT`, `UPDATE`, and `DELETE` operations in tables that are named in the connector's xref:{context}-property-table-include-list[`table.include.list`] property.
Schema data::
DDL statements that describe the structural changes that are applied to tables.
Schema data is persisted to both the internal schema history topic, and to the connector's schema change topic, if one is configured.

After you run an initial snapshot, you might notice that the snapshot captures schema information for tables that are not designated for capture.
By default, initial snapshots are designed to capture schema information for every table that is present in the database, not only from tables that are designated for capture.
Connectors require that the table's schema is present in the schema history topic before they can capture a table.
By enabling the initial snapshot to capture schema data for tables that are not part of the original capture set, {prodname} prepares the connector to readily capture event data from these tables should that later become necessary.
If the initial snapshot does not capture a table's schema, you must add the schema to the history topic before the connector can capture data from the table.

In some cases, you might want to limit schema capture in the initial snapshot.
This can be useful when you want to reduce the time required to complete a snapshot.
Or when {prodname} connects to the database instance through a user account that has access to multiple logical databases, but you want the connector to capture changes only from tables in a specific logic database.

.Additional information
* xref:{context}-capturing-data-from-tables-not-captured-by-the-initial-snapshot-no-schema-change[Capturing data from tables not captured by the initial snapshot (no schema change)]
* xref:{context}-capturing-data-from-new-tables-with-schema-changes[Capturing data from tables not captured by the initial snapshot (schema change)]
* Setting the xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.store.only.captured.tables.ddl`] property to specify the tables from which to capture schema information.
* Setting the xref:{context}-property-database-history-store-only-captured-databases-ddl[`schema.history.internal.store.only.captured.databases.ddl`] property to specify the logical databases from which to capture schema changes.

:leveloffset: 1


// Type: procedure
[id="mysql-capturing-data-from-tables-not-captured-by-the-initial-snapshot-no-schema-change"]
==== Capturing data from tables not captured by the initial snapshot (no schema change)

:leveloffset: +1

In some cases, you might want the connector to capture data from a table whose schema was not captured by the initial snapshot.
Depending on the connector configuration, the initial snapshot might capture the table schema only for specific tables in the database.
If the table schema is not present in the history topic, the connector fails to capture the table, and reports a missing schema error.

You might still be able to capture data from the table, but you must perform additional steps to add the table schema.

.Prerequisites

* You want to capture data from a table with a schema that the connector did not capture during the initial snapshot.
* In the transaction log, all entries for the table use the same schema.
For information about capturing data from a new table that has undergone structural changes, see xref:{context}-capturing-data-from-new-tables-with-schema-changes[Capturing data from tables not captured by the initial snapshot (schema change)].

.Procedure

1. Stop the connector.
2. Remove the internal database schema history topic that is specified by the xref:{context}-property-database-history-kafka-topic[`schema.history.internal.kafka.topic property`].
3. Apply the following changes to the connector configuration:
.. Set the xref:{context}-property-snapshot-mode[`snapshot.mode`] to `schema_only_recovery`.
.. Set the value of xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.store.only.captured.tables.ddl`] to `false`.
.. Add the tables that you want the connector to capture to `table.include.list`.
This guarantees that in the future, the connector can reconstruct the schema history for all tables.
4. Restart the connector.
The snapshot recovery process rebuilds the schema history based on the current structure of the tables.
5. (Optional) After the snapshot completes, initiate an xref:debezium-{context}-incremental-snapshots[incremental snapshot] to capture existing data for newly added tables along with changes to other tables that occurred while that connector was off-line.
6. (Optional) Reset the `snapshot.mode` back to `schema_only` to prevent the connector from initiating recovery after a future restart.

:leveloffset: 1


// Type: procedure
[id="mysql-capturing-data-from-new-tables-with-schema-changes"]
==== Capturing data from tables not captured by the initial snapshot (schema change)

:leveloffset: +1

If a schema change is applied to a table, records that are committed before the schema change have different structures than those that were committed after the change.
When {prodname} captures data from a table, it reads the schema history to ensure that it applies the correct schema to each event.
If the schema is not present in the schema history topic, the connector is unable to capture the table, and an error results.

If you want to capture data from a table that was not captured by the initial snapshot, and the schema of the table was modified, you must add the schema to the history topic, if it is not already available.
You can add the schema by running a new schema snapshot, or by running an initial snapshot for the table.

.Prerequisites
* You want to capture data from a table with a schema that the connector did not capture during the initial snapshot.
* A schema change was applied to the table so that the records to be captured do not have a uniform structure.

.Procedure

Initial snapshot captured the schema for all tables (`store.only.captured.tables.ddl` was set to `false`)::
1. Edit the xref:{context}-property-table-include-list[`table.include.list`] property to specify the tables that you want to capture.
2. Restart the connector.
3. Initiate an xref:debezium-{context}-incremental-snapshots[incremental snapshot] if you want to capture existing data from the newly added tables.

Initial snapshot did not capture the schema for all tables (`store.only.captured.tables.ddl` was set to `true`)::
If the initial snapshot did not save the schema of the table that you want to capture, complete one of the following procedures:

Procedure 1: Schema snapshot, followed by incremental snapshot:::
In this procedure, the connector first performs a schema snapshot.
You can then initiate an incremental snapshot to enable the connector to synchronize data.
1. Stop the connector.
2. Remove the internal database schema history topic that is specified by the xref:{context}-property-database-history-kafka-topic[`schema.history.internal.kafka.topic property`].
3. Clear the offsets in the configured Kafka Connect link:{link-kafka-docs}/#connectconfigs_offset.storage.topic[`offset.storage.topic`].
For more information about how to remove offsets, see the link:https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector[{prodname} community FAQ].
+
[WARNING]
====
Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.
====
4. Set values for properties in the connector configuration as described in the following steps:
.. Set the value of the xref:{context}-property-snapshot-mode[`snapshot.mode`] property to `schema_only`.
.. Edit the xref:{context}-property-table-include-list[`table.include.list`] to add the tables that you want to capture.
5. Restart the connector.
6. Wait for {prodname} to capture the schema of the new and existing tables.
Data changes that occurred any tables after the connector stopped are not captured.
7. To ensure that no data is lost, initiate an xref:debezium-{context}-incremental-snapshots[incremental snapshot].

Procedure 2: Initial snapshot, followed by optional incremental snapshot:::
In this procedure the connector performs a full initial snapshot of the database.
As with any initial snapshot, in a database with many large tables, running an initial snapshot can be a time-consuming operation.
After the snapshot completes, you can optionally trigger an incremental snapshot to capture any changes that occur while the connector is off-line.

1. Stop the connector.
2. Remove the internal database schema history topic that is specified by the xref:{context}-property-database-history-kafka-topic[`schema.history.internal.kafka.topic property`].
3. Clear the offsets in the configured Kafka Connect link:{link-kafka-docs}/#connectconfigs_offset.storage.topic[`offset.storage.topic`].
For more information about how to remove offsets, see the link:https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector[{prodname} community FAQ].
+
[WARNING]
====
Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.
====
4. Edit the xref:{context}-property-table-include-list[`table.include.list`] to add the tables that you want to capture.
5. Set values for properties in the connector configuration as described in the following steps:
.. Set the value of the xref:{context}-property-snapshot-mode[`snapshot.mode`] property to `initial`.
.. (Optional) Set xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.store.only.captured.tables.ddl`] to `false`.
6. Restart the connector.
The connector takes a full database snapshot.
After the snapshot completes, the connector transitions to streaming.
7. (Optional) To capture any data that changed while the connector was off-line, initiate an xref:debezium-{context}-incremental-snapshots[incremental snapshot].

:leveloffset: 1

// Type: concept
[id="debezium-mysql-ad-hoc-snapshots"]
=== Ad hoc snapshots

:leveloffset: +1

By default, a connector runs an initial snapshot operation only after it starts for the first time.
Following this initial snapshot, under normal circumstances, the connector does not repeat the snapshot process.
Any future change event data that the connector captures comes in through the streaming process only.

However, in some situations the data that the connector obtained during the initial snapshot might become stale, lost, or incomplete.
To provide a mechanism for recapturing {data-collection} data, {prodname} includes an option to perform ad hoc snapshots.
You might want to perform an ad hoc snapshot after any of the following changes occur in your {prodname} environment:

* The connector configuration is modified to capture a different set of {data-collection}s.
* Kafka topics are deleted and must be rebuilt.
* Data corruption occurs due to a configuration error or some other problem.

You can re-run a snapshot for a {data-collection} for which you previously captured a snapshot by initiating a so-called _ad-hoc snapshot_.
Ad hoc snapshots require the use of {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[signaling {data-collection}s].
You initiate an ad hoc snapshot by sending a signal request to the {prodname} signaling {data-collection}.

When you initiate an ad hoc snapshot of an existing {data-collection}, the connector appends content to the topic that already exists for the {data-collection}.
If a previously existing topic was removed, {prodname} can create a topic automatically if {link-prefix}:{link-topic-auto-creation}#customizing-debezium-automatically-created-topics[automatic topic creation] is enabled.

Ad hoc snapshot signals specify the {data-collection}s to include in the snapshot.
The snapshot can capture the entire contents of the database, or capture only a subset of the {data-collection}s in the database.
Also, the snapshot can capture a subset of the contents of the {data-collection}(s) in the database.

You specify the {data-collection}s to capture by sending an `execute-snapshot` message to the signaling {data-collection}.
Set the type of the `execute-snapshot` signal to `incremental` or `blocking`, and provide the names of the {data-collection}s to include in the snapshot, as described in the following table:


.Example of an ad hoc `execute-snapshot` signal record
[cols="2,2,6a",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| Specifies the type of snapshot that you want to run. +
Currently, you can request `incremental` or `blocking` snapshots.


|`data-collections`
|_N/A_
| An array that contains regular expressions matching the fully-qualified names of the {data-collection} to be snapshotted. +
The format of the names is the same as for the `signal.data.collection` configuration option.

|`[.line-through]#additional-condition#`
|_N/A_
| An optional string, which specifies a condition based on the column(s) of the {data-collection}(s), to capture a
subset of the contents of the {data-collection}(s). +

[NOTE]
====
This property is deprecated.
To specify criteria for defining the subset of data that you want the snapshot to capture, use the `additional-conditions` parameter.
====

|`additional-conditions`
|_N/A_
|An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot. +
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:

`data-collection`:: The fully-qualified name of the {data-collection} that the filter applies to.
You can apply different filters to each {data-collection}.
`filter`:: Specifies column values that must be present in a database record for the snapshot to include it, for example,  `"color='blue'"`. +
 +
The values that you assign to the `filter` parameter are the same types of values that you might specify in the `WHERE` clause of `SELECT` statements when you set the `snapshot.select.statement.overrides` property for a blocking snapshot.
In earlier {prodname} releases, an explicit `filter` parameter was not defined for snapshot signals; instead, filter criteria were implied by the values that were specified for the now deprecated  `additional-condition` parameter.

|`surrogate-key`
|_N/A_
| An optional string that specifies the column name that the connector uses as the primary key of a {data-collection} during the snapshot process.

|===

.Triggering an ad hoc incremental snapshot

You initiate an ad hoc incremental snapshot by adding an entry with the `execute-snapshot` signal type to the signaling {data-collection}.
After the connector processes the message, it begins the snapshot operation.
The snapshot process reads the first and last primary key values and uses those values as the start and end point for each {data-collection}.
Based on the number of entries in the {data-collection}, and the configured chunk size, {prodname} divides the {data-collection} into chunks, and proceeds to snapshot each chunk, in succession, one at a time.

For more information, see xref:debezium-{context}-incremental-snapshots[Incremental snapshots].

.Triggering an ad hoc blocking snapshot

You initiate an ad hoc blocking snapshot by adding an entry with the `execute-snapshot` signal type to the signaling {data-collection}.
After the connector processes the message, it begins the snapshot operation.
The connector temporarily stops streaming, and then initiates a snapshot of the specified {data-collection}, following the same process that it uses during an initial snapshot.
After the snapshot completes, the connector resumes streaming.

For more information, see xref:{context}-blocking-snapshots[Blocking snapshots].

:leveloffset: 1

// Type: assembly
// ModuleID: debezium-mysql-incremental-snapshots
[id="debezium-mysql-incremental-snapshots"]
=== Incremental snapshots

:leveloffset: +1

To provide flexibility in managing snapshots, {prodname} includes a supplementary snapshot mechanism, known as _incremental snapshotting_.
Incremental snapshots rely on the {prodname} mechanism for {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[sending signals to a {prodname} connector].
Incremental snapshots are based on the link:https://github.com/debezium/debezium-design-documents/blob/main/DDD-3.md[DDD-3] design document.

In an incremental snapshot, instead of capturing the full state of a database all at once, as in an initial snapshot, {prodname} captures each {data-collection} in phases, in a series of configurable chunks.
You can specify the {data-collection}s that you want the snapshot to capture and the xref:{context}-property-incremental-snapshot-chunk-size[size of each chunk].
The chunk size determines the number of rows that the snapshot collects during each fetch operation on the database.
The default chunk size for incremental snapshots is 1024 rows.

As an incremental snapshot proceeds, {prodname} uses watermarks to track its progress, maintaining a record of each {data-collection} row that it captures.
This phased approach to capturing data provides the following advantages over the standard initial snapshot process:

* You can run incremental snapshots in parallel with streamed data capture, instead of postponing streaming until the snapshot completes.
  The connector continues to capture near real-time events from the change log throughout the snapshot process, and neither operation blocks the other.
* If the progress of an incremental snapshot is interrupted, you can resume it without losing any data.
  After the process resumes, the snapshot begins at the point where it stopped, rather than recapturing the {data-collection} from the beginning.
* You can run an incremental snapshot on demand at any time, and repeat the process as needed to adapt to database updates.
  For example, you might re-run a snapshot after you modify the connector configuration to add a {data-collection} to its xref:{context}-property-{data-collection}-include-list[`{data-collection}.include.list`] property.

.Incremental snapshot process
When you run an incremental snapshot, {prodname} sorts each {data-collection} by primary key and then splits the {data-collection} into chunks based on the xref:{context}-property-incremental-snapshot-chunk-size[configured chunk size].
Working chunk by chunk, it then captures each {data-collection} row in a chunk.
For each row that it captures, the snapshot emits a `READ` event.
That event represents the value of the row when the snapshot for the chunk began.

As a snapshot proceeds, it’s likely that other processes continue to access the database, potentially modifying {data-collection} records.
To reflect such changes, `INSERT`, `UPDATE`, or `DELETE` operations are committed to the transaction log as per usual.
Similarly, the ongoing {prodname} streaming process continues to detect these change events and emits corresponding change event records to Kafka.

.How {prodname} resolves collisions among records with the same primary key
In some cases, the `UPDATE` or `DELETE` events that the streaming process emits are received out of sequence.
That is, the streaming process might emit an event that modifies a {data-collection} row before the snapshot captures the chunk that contains the `READ` event for that row.
When the snapshot eventually emits the corresponding `READ` event for the row, its value is already superseded.
To ensure that incremental snapshot events that arrive out of sequence are processed in the correct logical order, {prodname} employs a buffering scheme for resolving collisions.
Only after collisions between the snapshot events and the streamed events are resolved does {prodname} emit an event record to Kafka.

.Snapshot window
To assist in resolving collisions between late-arriving `READ` events and streamed events that modify the same {data-collection} row, {prodname} employs a so-called _snapshot window_.
The snapshot windows demarcates the interval during which an incremental snapshot captures data for a specified {data-collection} chunk.
Before the snapshot window for a chunk opens, {prodname} follows its usual behavior and emits events from the transaction log directly downstream to the target Kafka topic.
But from the moment that the snapshot for a particular chunk opens, until it closes, {prodname} performs a de-duplication step to resolve collisions between events that have the same primary key..

For each data collection, the {prodname} emits two types of events, and stores the records for them both in a single destination Kafka topic.
The snapshot records that it  captures directly from a table are emitted as `READ` operations.
Meanwhile, as users continue to update records in the data collection, and the transaction log is updated to reflect each commit, {prodname} emits `UPDATE` or `DELETE` operations for each change.

As the snapshot window opens, and {prodname} begins processing a snapshot chunk, it delivers snapshot records to a memory buffer.
During the snapshot windows, the primary keys of the `READ` events in the buffer are compared to the primary keys of the incoming streamed events.
If no match is found, the streamed event record is sent directly to Kafka.
If {prodname} detects a match, it discards the buffered `READ` event, and writes the streamed record to the destination topic, because the streamed event logically supersede the static snapshot event.
After the snapshot window for the chunk closes, the buffer contains only `READ` events for which no related transaction log events exist.
{prodname} emits these remaining `READ` events to the {data-collection}'s Kafka topic.

The connector repeats the process for each snapshot chunk.

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-mysql-triggering-an-incremental-snapshot
[id="mysql-triggering-an-incremental-snapshot"]
==== Triggering an incremental snapshot

:leveloffset: +1

Currently, the only way to initiate an incremental snapshot is to send an {link-prefix}:{link-signalling}#debezium-signaling-ad-hoc-snapshots[ad hoc snapshot signal] to the signaling {data-collection} on the source database.

You submit a signal to the signaling {data-collection} as SQL `INSERT` queries.

After {prodname} detects the change in the signaling {data-collection}, it reads the signal, and runs the requested snapshot operation.

The query that you submit specifies the {data-collection}s to include in the snapshot, and, optionally, specifies the type of snapshot operation.
Currently supports the `incremental` and `blocking` types.

To specify the {data-collection}s to include in the snapshot, provide a `data-collections` array that lists the {data-collection}s or an array of regular expressions used to match {data-collection}s, for example, +

`{"data-collections": ["public.MyFirstTable", "public.MySecondTable"]}` +

The `data-collections` array for an incremental snapshot signal has no default value.
If the `data-collections` array is empty, {prodname} detects that no action is required and does not perform a snapshot.

[NOTE]
====
If the name of a {data-collection} that you want to include in a snapshot contains a dot (`.`) in the name of the database, schema, or table, to add the {data-collection} to the `data-collections` array, you must escape each part of the name in double quotes. +
 +
For example, to include a table that exists in the `*public*` schema and that has the name `*My.Table*`, use the following format: `*"public"."My.Table"*`.
====

.Prerequisites

* {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[Signaling is enabled]. +
** A signaling data collection exists on the source database.
** The signaling data collection is specified in the xref:{context}-property-signal-data-collection[`signal.data.collection`] property.

.Using a source signaling channel to trigger an incremental snapshot

. Send a SQL query to add the ad hoc incremental snapshot request to the signaling {data-collection}:
+
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) VALUES (_'<id>'_, _'<snapshotType>'_, '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"_<snapshotType>_","additional-conditions":[{"data-collection": "_<tableName>_", "filter": "_<additional-condition>_"}]}');
----
+
For example,
+
[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) // <1>
values ('ad-hoc-1',   // <2>
    'execute-snapshot',  // <3>
    '{"data-collections": ["schema1.table1", "schema2.table2"], // <4>
    "type":"incremental", // <5>
    "additional-conditions":[{"data-collection": "schema1.table1" ,"filter":"color=\'blue\'"}]}'); // <6>
----
+
The values of the `id`,`type`, and `data` parameters in the command correspond to the {link-prefix}:{link-signalling}#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection[fields of the signaling {data-collection}].
+
The following table describes the parameters in the example:
+
.Descriptions of fields in a SQL command for sending an incremental snapshot signal to the signaling {data-collection}
[cols="1,2,6",options="header"]
|===
|Item |Value |Description

|1
|`myschema.debezium_signal`
|Specifies the fully-qualified name of the signaling {data-collection} on the source database.

|2
|`ad-hoc-1`
|The `id` parameter specifies an arbitrary string that is assigned as the `id` identifier for the signal request. +
Use this string to identify logging messages to entries in the signaling {data-collection}.
{prodname} does not use this string.
Rather, during the snapshot, {prodname} generates its own `id` string as a watermarking signal.

|3
|`execute-snapshot`
|The `type` parameter specifies the operation that the signal is intended to trigger. +

|4
|`data-collections`
|A required component of the `data` field of a signal that specifies an array of {data-collection} names or regular expressions to match {data-collection} names to include in the snapshot. +
The array lists regular expressions which match {data-collection}s by their fully-qualified names, using the same format as you use to specify the name of the connector's signaling {data-collection} in the xref:{context}-property-signal-data-collection[`signal.data.collection`] configuration property.

|5
|`incremental`
|An optional `type` component of the `data` field of a signal that specifies the type of snapshot operation to run. +
Currently supports the `incremental` and `blocking` types. +
If you do not specify a value, the connector runs an incremental snapshot.

|6
|`additional-conditions`
| An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot. +
Each additional condition is an object with `data-collection` and `filter` properties.
You can specify different filters for each data collection. +
* The `data-collection` property is the fully-qualified name of the data collection for which the filter will be applied.
For more information about the `additional-conditions` parameter, see xref:{context}-incremental-snapshots-additional-conditions[].
|===

[id="{context}-incremental-snapshots-additional-conditions"]
.Ad hoc incremental snapshots with `additional-conditions`

If you want a snapshot to include only a subset of the content in a {data-collection}, you can modify the signal request by appending an `additional-conditions` parameter to the snapshot signal.

The SQL query for a typical snapshot takes the following form:

[source,sql,subs="+attributes,+quotes"]
----
SELECT * FROM _<tableName>_ ....
----

By adding an `additional-conditions` parameter, you append a `WHERE` condition to the SQL query, as in the following example:

[source,sql,subs="+attributes,+quotes"]
----
SELECT * FROM _<data-collection>_ WHERE _<filter>_ ....
----

The following example shows a SQL query to send an ad hoc incremental snapshot request with an additional condition to the signaling {data-collection}:
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) VALUES (_'<id>'_, _'<snapshotType>'_, '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"_<snapshotType>_","additional-conditions":[{"data-collection": "_<tableName>_", "filter": "_<additional-condition>_"}]}');
----

For example, suppose you have a `products` {data-collection} that contains the following columns:

* `id` (primary key)
* `color`
* `quantity`

If you want an incremental snapshot of the `products` {data-collection} to include only the data items where `color=blue`, you can use the following SQL statement to trigger the snapshot:

[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) VALUES('ad-hoc-1', 'execute-snapshot', '{"data-collections": ["schema1.products"],"type":"incremental", "additional-conditions":[{"data-collection": "schema1.products", "filter": "color=blue"}]}');
----

The `additional-conditions` parameter also enables you to pass conditions that are based on more than one column.
For example, using the `products` {data-collection} from the previous example, you can submit a query that triggers an incremental snapshot that includes the data of only those items for which `color=blue` and `quantity>10`:

[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) VALUES('ad-hoc-1', 'execute-snapshot', '{"data-collections": ["schema1.products"],"type":"incremental", "additional-conditions":[{"data-collection": "schema1.products", "filter": "color=blue AND quantity>10"}]}');
----

The following example, shows the JSON for an incremental snapshot event that is captured by a connector.

.Example: Incremental snapshot event message
[source,json,index=0]
----
{
    "before":null,
    "after": {
        "pk":"1",
        "value":"New data"
    },
    "source": {
        ...
        "snapshot":"incremental" <1>
    },
    "op":"r", <2>
    "ts_ms":"1620393591654",
    "ts_us":"1620393591654547",
    "ts_ns":"1620393591654547920",
    "transaction":null
}
----
[cols="1,1,4",options="header"]
|===
|Item |Field name |Description
|1
|`snapshot`
|Specifies the type of snapshot operation to run. +
Currently, the only valid options are `blocking` and `incremental`. +
Specifying a `type` value in the SQL query that you submit to the signaling {data-collection} is optional. +
If you do not specify a value, the connector runs an incremental snapshot.

|2
|`op`
|Specifies the event type. +
The value for snapshot events is `r`, signifying a `READ` operation.

|===

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-mysql-using-the-kafka-signaling-channel-to-trigger-an-incremental-snapshot
[id="mysql-triggering-an-incremental-snapshot-kafka"]
==== Using the Kafka signaling channel to trigger an incremental snapshot

:leveloffset: +1

You can send a message to the {link-prefix}:{link-signalling}#debezium-signaling-enabling-kafka-signaling-channel[configured Kafka topic] to request the connector to run an ad hoc incremental snapshot.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value of the message is a JSON object with `type` and `data` fields.

The signal type is `execute-snapshot`, and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6a",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed.
Currently {prodname} supports the `incremental` and `blocking` types. +
See the next section for more details.

|`data-collections`
|_N/A_
| An array of comma-separated regular expressions that match the fully-qualified names of tables to include in the snapshot. +
Specify the names by using the same format as is required for the xref:{context}-property-signal-data-collection[signal.data.collection] configuration option.

|`[.line-through]#additional-condition#`
|_N/A_
| An optional string that specifies a condition that the connector evaluates to designate a subset of records to include in a snapshot. +

[NOTE]
====
This property is deprecated and should be replaced by the `additional-conditions` property.
====

|`additional-conditions`
|_N/A_
| An optional array of additional conditions that specifies criteria that the connector evaluates to designate a subset of records to include in a snapshot. +
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:
`data-collection`:: The fully-qualified name of the {data-collection} that the filter applies to.
You can apply different filters to each {data-collection}.
`filter`:: Specifies column values that must be present in a database record for the snapshot to include it, for example,  `"color='blue'"`. +
 +
The values that you assign to the `filter` parameter are the same types of values that you might specify in the `WHERE` clause of `SELECT` statements when you set the `snapshot.select.statement.overrides` property for a blocking snapshot.
In earlier {prodname} releases, an explicit `filter` parameter was not defined for snapshot signals; instead, filter criteria were implied by the values that were specified for the now deprecated `additional-condition` parameter.
|===

An example of the execute-snapshot Kafka message:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

.Ad hoc incremental snapshots with additional-conditions

{prodname} uses the `additional-conditions` field to select a subset of a {data-collection}'s content.

Typically, when {prodname} runs a snapshot, it runs a SQL query such as:

`SELECT * FROM _<tableName>_ ....`

When the snapshot request includes an `additional-conditions` property, the `data-collection` and `filter` parameters of the  property are appended to the SQL query, for example:

`SELECT * FROM _<data-collection>_ WHERE _<filter>_ ....`

For example, given a `products` {data-collection} with the columns `id` (primary key), `color`, and `brand`, if you want a snapshot to include only content for which `color='blue'`, when you request the snapshot, you could add the `additional-conditions` property to filter the content:
----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "schema1.products" ,"filter":"color='blue'"}]}}`
----

You can use the `additional-conditions` property to pass conditions based on multiple columns.
For example, using the same `products` {data-collection} as in the previous example, if you want a snapshot to include only the content from the `products` {data-collection} for which `color='blue'`, and `brand='MyBrand'`, you could send the following request:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "schema1.products" ,"filter":"color='blue' AND brand='MyBrand'"}]}}`
----

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-mysql-stopping-an-incremental-snapshot
[id="mysql-stopping-an-incremental-snapshot"]
==== Stopping an incremental snapshot

:leveloffset: +1

You can also stop an incremental snapshot by sending a signal to the {data-collection} on the source database.
You submit a stop snapshot signal to the {data-collection} by sending a SQL `INSERT` query.

After {prodname} detects the change in the signaling {data-collection}, it reads the signal, and stops the incremental snapshot operation if it's in progress.

The query that you submit specifies the snapshot operation of `incremental`, and, optionally, the {data-collection}s of the current running snapshot to be removed.

.Prerequisites

* {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[Signaling is enabled]. +
** A signaling data collection exists on the source database.
** The signaling data collection is specified in the xref:{context}-property-signal-data-collection[`signal.data.collection`] property.

.Using a source signaling channel to stop an incremental snapshot

. Send a SQL query to stop the ad hoc incremental snapshot to the signaling {data-collection}:
+
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) values (_'<id>'_, 'stop-snapshot', '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"incremental"}');
----
+
For example,
+
[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) // <1>
values ('ad-hoc-1',   // <2>
    'stop-snapshot',  // <3>
    '{"data-collections": ["schema1.table1", "schema2.table2"], // <4>
    "type":"incremental"}'); // <5>
----
+
The values of the `id`, `type`, and `data` parameters in the signal command correspond to the {link-prefix}:{link-signalling}#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection[fields of the signaling {data-collection}].
+
The following table describes the parameters in the example:
+
.Descriptions of fields in a SQL command for sending a stop incremental snapshot signal to the signaling {data-collection}
[cols="1,2,6",options="header"]
|===
|Item|Value |Description

|1
|`myschema.debezium_signal`
|Specifies the fully-qualified name of the signaling {data-collection} on the source database.

|2
|`ad-hoc-1`
| The `id` parameter specifies an arbitrary string that is assigned as the `id` identifier for the signal request. +
Use this string to identify logging messages to entries in the signaling {data-collection}.
{prodname} does not use this string.

|3
|`stop-snapshot`
| Specifies `type` parameter specifies the operation that the signal is intended to trigger. +

|4
|`data-collections`
|An optional component of the `data` field of a signal that specifies an array of {data-collection} names or regular expressions to match {data-collection} names to remove from the snapshot. +
The array lists regular expressions which match {data-collection}s by their fully-qualified names, using the same format as you use to specify the name of the connector's signaling {data-collection} in the xref:{context}-property-signal-data-collection[`signal.data.collection`] configuration property.
If this component of the `data` field is omitted, the signal stops the entire incremental snapshot that is in progress.

|5
|`incremental`
|A required component of the `data` field of a signal that specifies the type of snapshot operation that is to be stopped. +
Currently, the only valid option is `incremental`. +
If you do not specify a `type` value, the signal fails to stop the incremental snapshot.
|===

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-mysql-using-the-kafka-signaling-channel-to-stop-an-incremental-snapshot
[id="mysql-stopping-an-incremental-snapshot-kafka"]
==== Using the Kafka signaling channel to stop an incremental snapshot

:leveloffset: +1

You can send a signal message to the {link-prefix}:{link-signalling}#debezium-signaling-enabling-kafka-signaling-channel[configured Kafka signaling topic] to stop an ad hoc incremental snapshot.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value of the message is a JSON object with `type` and `data` fields.

The signal type is `stop-snapshot`, and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed.
Currently {prodname} supports only the `incremental` type.  +
See the next section for more details.

|`data-collections`
|_N/A_
| An optional array of comma-separated regular expressions that match the fully-qualified names of the tables to include in the snapshot. +
Specify the names by using the same format as is required for the xref:{context}-property-signal-data-collection[signal.data.collection] configuration option.

|===

The following example shows a typical `stop-snapshot` Kafka message:

----
Key = `test_connector`

Value = `{"type":"stop-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

:leveloffset: 1

[id="mysql-read-only-incremental-snapshots"]
==== Read-only incremental snapshots

:leveloffset: +1

The {prodname} {connector-name} connector allows for running incremental snapshots with a read-only connection to the database.
To run an incremental snapshot with read-only access, the connector uses the executed global transaction IDs (GTID) set as high and low watermarks.
The state of a chunk's window is updated by comparing the GTIDs of binary log (binlog) events or the server's heartbeats against low and high watermarks.

To switch to a read-only implementation, set the value of the xref:{context}-property-read-only[`read.only`] property to `true`.

.Prerequisites

* xref:enable-{context}-gtids[Enable {connector-name} GTIDs].
* If the connector reads from a multi-threaded replica (that is, a replica for which the value of `replica_parallel_workers` is greater than `0`)
you must set one of the following options:

** `replica_preserve_commit_order=ON`
** `slave_preserve_commit_order=ON`

:leveloffset: 1

==== Ad hoc read-only incremental snapshots

:leveloffset: +1

When the {connector-name} connection is read-only, you can use any of the {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[available signaling channels] without the requirement to use the `source` channel.

:leveloffset: 1

// Type: continue
[id="mysql-snapshot-events"]
=== Operation type of snapshot events

The MySQL connector emits snapshot events as `READ` operations `("op" : "r")`.
If you prefer that the connector emits snapshot events as `CREATE` (`c`) events, configure the {prodname} `ReadToInsertEvent` single message transform (SMT) to modify the event type.

The following example shows how to configure the SMT:

.Example: Using the `ReadToInsertEvent` SMT to change the type of snapshot events
----
transforms=snapshotasinsert,...
transforms.snapshotasinsert.type=io.debezium.connector.mysql.transforms.ReadToInsertEvent
----

[[connector-custom-snapshot]]
=== Custom snapshotter SPI
:leveloffset: +3

For more advanced uses, you can fine-tune control of the snapshot by implementing one of the following interfaces:

`io.debezium.snapshot.spi.Snapshotter`:: Controls whether the connector takes a snapshot.
`io.debezium.snapshot.spi.SnapshotQuery`:: Controls how data is queried during a snapshot.
`io.debezium.snapshot.spi.SnapshotLock`:: Controls whether the connector locks tables when taking a snapshot.


[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.Snapshotter interface. All built-in snapshot modes implement this interface.
----
/**
 * {@link Snapshotter} is used to determine the following details about the snapshot process:
 * <p>
 * - Whether a snapshot occurs. <br>
 * - Whether streaming continues during the snapshot. <br>
 * - Whether the snapshot includes schema (if supported). <br>
 * - Whether to snapshot data or schema following an error.
 * <p>
 * Although Debezium provides many default snapshot modes,
 * to provide more advanced functionality, such as partial snapshots,
 * you can customize implementation of the interface.
 * For more information, see the documentation.
 *
 *
 *
 */
@Incubating
public interface Snapshotter extends Configurable {

    /**
     * @return the name of the snapshotter.
     *
     *
     */
    String name();

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a data snapshot
     */
    boolean shouldSnapshotData(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a schema snapshot
     */
    boolean shouldSnapshotSchema(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @return {@code true} if the snapshotter should stream after taking a snapshot
     */
    boolean shouldStream();

    /**
     * @return {@code true} whether the schema can be recovered if database schema history is corrupted.
     */
    boolean shouldSnapshotOnSchemaError();

    /**
     * @return {@code true} whether the snapshot should be re-executed when there is a gap in data stream.
     */
    boolean shouldSnapshotOnDataError();

    /**
     *
     * @return {@code true} if streaming should resume from the start of the snapshot
     * transaction, or {@code false} for when a connector resumes and takes a snapshot,
     * streaming should resume from where streaming previously left off.
     */
    default boolean shouldStreamEventsStartingFromSnapshot() {
        return true;
    }

    /**
     * Lifecycle hook called after the snapshot phase is successful.
     */
    default void snapshotCompleted() {
        // no operation
    }

    /**
     * Lifecycle hook called after the snapshot phase is aborted.
     */
    default void snapshotAborted() {
        // no operation
    }
}
----

[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.SnapshotQuery interface. All built-in snapshot query modes implement this interface.
----
/**
 * {@link SnapshotQuery} is used to determine the query used during a data snapshot
 *
 *
 */
public interface SnapshotQuery extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Generate a valid query string for the specified table, or an empty {@link Optional}
     * to skip snapshotting this table (but that table will still be streamed from)
     *
     * @param tableId the table to generate a query for
     * @param snapshotSelectColumns the columns to be used in the snapshot select based on the column
     *                              include/exclude filters
     * @return a valid query string, or none to skip snapshotting this table
     */
    Optional<String> snapshotQuery(String tableId, List<String> snapshotSelectColumns);

}
----

[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.SnapshotLock interface. All built-in snapshot lock modes implement this interface.
----
/**
 * {@link SnapshotLock} is used to determine the table lock mode used during schema snapshot
 *
 *
 */
public interface SnapshotLock extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Returns a SQL statement for locking the given table during snapshotting, if required by the specific snapshotter
     * implementation.
     */
    Optional<String> tableLockingStatement(Duration lockTimeout, String tableId);

}
----

:leveloffset: 1

// Type: concept
[id="mysql-blocking-snapshots"]
=== Blocking snapshots

:leveloffset: +3

To provide more flexibility in managing snapshots, {prodname} includes a supplementary ad hoc snapshot mechanism, known as a _blocking snapshot_.
Blocking snapshots rely on the {prodname} mechanism for {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[sending signals to a {prodname} connector].

A blocking snapshot behaves just like an _initial snapshot_, except that you can trigger it at run time.

You might want to run a blocking snapshot rather than use the standard initial snapshot process in the following situations:

* You add a new {data-collection} and you want to complete the snapshot while the connector is running.
* You add a large {data-collection}, and you want the snapshot to complete in less time than is possible with an incremental snapshot.

.Blocking snapshot process
When you run a blocking snapshot, {prodname} stops streaming, and then initiates a snapshot of the specified {data-collection}, following the same process that it uses during an initial snapshot.
After the snapshot completes, the streaming is resumed.

.Configure snapshot

You can set the following properties in the `data` component of a signal:

 * data-collections: to specify which {data-collection}s must be snapshot
 * additional-conditions: You can specify different filters for different {data-collection}. +
 ** The `data-collection` property is the fully-qualified name of the {data-collection} for which the filter will be applied.
 ** The `filter` property will have the same value used in the  `snapshot.select.statement.overrides`

For example:
[source,json]
----
  {"type": "blocking", "data-collections": ["schema1.table1", "schema1.table2"], "additional-conditions": [{"data-collection": "schema1.table1", "filter": "SELECT * FROM [schema1].[table1] WHERE column1 = 0 ORDER BY column2 DESC"}, {"data-collection": "schema1.table2", "filter": "SELECT * FROM [schema1].[table2] WHERE column2 > 0"}]}
----

.Possible duplicates
A delay might exist between the time that you send the signal to trigger the snapshot, and the time when streaming stops and the snapshot starts.
As a result of this delay, after the snapshot completes, the connector might emit some event records that duplicate records captured by the snapshot.

:leveloffset: 1

// Type: concept
// Title: Default names of Kafka topics that receive {prodname} MySQL change event records
[[mysql-topic-names]]
=== Topic names

:leveloffset: +1

By default, the {connector-name} connector writes change events for all of the `INSERT`, `UPDATE`, and `DELETE` operations that occur in a table to a single Apache Kafka topic that is specific to that table.

The connector uses the following convention to name change event topics:

_topicPrefix.databaseName.tableName_

Suppose that `fulfillment` is the topic prefix, `inventory` is the database name, and the database contains tables named `orders`, `customers`, and `products`.
The {prodname} {connector-name} connector emits events to three Kafka topics, one for each table in the database:

----
fulfillment.inventory.orders
fulfillment.inventory.customers
fulfillment.inventory.products
----

The following list provides definitions for the components of the default name:

_topicPrefix_:: The topic prefix as specified by the xref:{context}-property-topic-prefix[`topic.prefix`] connector configuration property.

_schemaName_:: The name of the schema in which the operation occurred.

_tableName_:: The name of the table in which the operation occurred.

The connector applies similar naming conventions to label its internal database schema history topics, xref:{context}-schema-change-topic[schema change topics], and xref:{context}-transaction-metadata[transaction metadata topics].

If the default topic name do not meet your requirements, you can configure custom topic names.
To configure custom topic names, you specify regular expressions in the logical topic routing SMT.
For more information about using the logical topic routing SMT to customize topic naming, see {link-prefix}:{link-topic-routing}#topic-routing[Topic routing].

:leveloffset: 1

[[mysql-transaction-metadata]]
=== Transaction metadata

:leveloffset: +1

{prodname} can generate events that represent transaction boundaries and that enrich data change event messages.

[NOTE]
.Limits on when {prodname} receives transaction metadata
====
{prodname} registers and receives metadata only for transactions that occur after you deploy the connector.
Metadata for transactions that occur before you deploy the connector is not available.
====

{prodname} generates transaction boundary events for the `BEGIN` and `END` delimiters in every transaction.
Transaction boundary events contain the following fields:

`status`:: `BEGIN` or `END`.
`id`:: String representation of the unique transaction identifier.
`ts_ms`:: The time of a transaction boundary event (`BEGIN` or `END` event) at the data source.
If the data source does not provide {prodname} with the event time, then the field instead represents the time at which {prodname} processes the event.
`event_count` (for `END` events):: Total number of events emitted by the transaction.
`data_collections` (for `END` events):: An array of pairs of `data_collection` and `event_count` elements that indicates the number of events that the connector emits for changes that originate from a data collection.

.Example

[source,json,indent=0,subs="+attributes"]
----
{
  "status": "BEGIN",
  "id": "0e4d5dcd-a33b-11ea-80f1-02010a22a99e:10",
  "ts_ms": 1486500577125,
  "event_count": null,
  "data_collections": null
}

{
  "status": "END",
  "id": "0e4d5dcd-a33b-11ea-80f1-02010a22a99e:10",
  "ts_ms": 1486500577691,
  "event_count": 2,
  "data_collections": [
    {
      "data_collection": "s1.a",
      "event_count": 1
    },
    {
      "data_collection": "s2.a",
      "event_count": 1
    }
  ]
}
----

Unless overridden via the xref:{context}-property-topic-transaction[`topic.transaction`] option,
the connector emits transaction events to the xref:{context}-property-topic-prefix[`_<topic.prefix>_`]`.transaction` topic.

.Change data event enrichment

When transaction metadata is enabled the data message `Envelope` is enriched with a new `transaction` field.
This field provides information about every event in the form of a composite of fields:

`id`:: String representation of unique transaction identifier.
`total_order`:: The absolute position of the event among all events generated by the transaction.
`data_collection_order`:: The per-data collection position of the event among all events that were emitted by the transaction.

Following is an example of a message:

[source,json,indent=0,subs="+attributes"]
----
{
  "before": null,
  "after": {
    "pk": "2",
    "aa": "1"
  },
  "source": {
...
  },
  "op": "c",
  "ts_ms": "1580390884335",
  "ts_us": "1580390884335472",
  "ts_ns": "1580390884335472987",
  "transaction": {
    "id": "0e4d5dcd-a33b-11ea-80f1-02010a22a99e:10",
    "total_order": "1",
    "data_collection_order": "1"
  }
}
----

:leveloffset: 1

// Type: assembly
// ModuleID: descriptions-of-debezium-mysql-connector-data-change-events
// Title: Descriptions of {prodname} MySQL connector data change events
[[mysql-events]]
== Data change events

:leveloffset: +1

The {prodname} {connector-name} connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed.

{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained.

The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converter and you configure it to produce all four basic change event parts, change events have this structure:

[source,json,index=0]
----
{
 "schema": { //<1>
   ...
  },
 "payload": { //<2>
   ...
 },
 "schema": { //<3>
   ...
 },
 "payload": { //<4>
   ...
 },
}
----

.Overview of change event basic content
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +
 +
It is possible to override the table's primary key by setting the xref:{context}-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.

|2
|`payload`
|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field, and it contains the key for the row that was changed.

|3
|`schema`
|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas.

|4
|`payload`
|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.

|===

By default, the connector streams change event records to topics with names that are the same as the event's originating table. See xref:{context}-topic-names[topic names].

[WARNING]
====
The {connector-name} connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or pass:[_]. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or pass:[_]. If there is an invalid character it is replaced with an underscore character.

This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.
====


:leveloffset: 1

// Type: concept
// ModuleID: about-keys-in-debezium-mysql-change-events
// Title: About keys in {prodname} MySQL change events
[[mysql-change-event-keys]]
=== Change event keys

:leveloffset: +1

A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.

Consider the following `customers` table, which is followed by an example of a change event key for this table.

[source,sql]
----
CREATE TABLE customers (
  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE KEY
) AUTO_INCREMENT=1001;
----

Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:

[source,json,index=0,subs="+attributes"]
----
{
 "schema": { <1>
    "type": "struct",
    "name": "{context}-server-1.inventory.customers.Key", <2>
    "optional": false, <3>
    "fields": [ <4>
      {
        "field": "id",
        "type": "int32",
        "optional": false
      }
    ]
  },
 "payload": { <5>
    "id": 1001
  }
}
----

.Description of change event key
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion.

|2
|`{context}-server-1.inventory.customers.Key`
a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: +

* `{context}-server-1` is the name of the connector that generated this event. +
* `inventory` is the database that contains the table that was changed. +
* `customers` is the table that was updated.

|3
|`optional`
|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.

|4
|`fields`
|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.

|5
|`payload`
|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1001`.

|===

:leveloffset: 1

// Type: concept
// ModuleID: about-values-in-debezium-mysql-change-events
// Title: About values in {prodname} MySQL change events
[[mysql-change-event-values]]
=== Change event values

:leveloffset: +1

The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure.

Consider the same sample table that was used to show an example of a change event key:

[source,sql]
----
CREATE TABLE customers (
  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE KEY
) AUTO_INCREMENT=1001;
----

The value portion of a change event for a change to this table is described for:

* <<{context}-create-events,_create_ events>>
* <<{context}-update-events,_update_ events>>
* <<{context}-primary-key-updates,Primary key updates>>
* <<{context}-delete-events,_delete_ events>>
* <<{context}-tombstone-events,Tombstone events>>
* <<{context}-truncate-events,_truncate_ events>>

:leveloffset: 1


// Type: continue
[id="mysql-create-events"]
=== _create_ events

:leveloffset: +1


The following example shows the value portion of a change event that the connector generates for an operation that creates data in the `customers` table:

[source,json,options="nowrap",subs="+attributes"]
----
{
  "schema": { // <1>
    "type": "struct",
    "fields": [
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "id"
          },
          {
            "type": "string",
            "optional": false,
            "field": "first_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "last_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "email"
          }
        ],
        "optional": true,
        "name": "{context}-server-1.inventory.customers.Value", // <2>
        "field": "before"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "id"
          },
          {
            "type": "string",
            "optional": false,
            "field": "first_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "last_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "email"
          }
        ],
        "optional": true,
        "name": "{context}-server-1.inventory.customers.Value",
        "field": "after"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "string",
            "optional": false,
            "field": "version"
          },
          {
            "type": "string",
            "optional": false,
            "field": "connector"
          },
          {
            "type": "string",
            "optional": false,
            "field": "name"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ms"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_us"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ns"
          },
          {
            "type": "boolean",
            "optional": true,
            "default": false,
            "field": "snapshot"
          },
          {
            "type": "string",
            "optional": false,
            "field": "db"
          },
          {
            "type": "string",
            "optional": true,
            "field": "table"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "server_id"
          },
          {
            "type": "string",
            "optional": true,
            "field": "gtid"
          },
          {
            "type": "string",
            "optional": false,
            "field": "file"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "pos"
          },
          {
            "type": "int32",
            "optional": false,
            "field": "row"
          },
          {
            "type": "int64",
            "optional": true,
            "field": "thread"
          },
          {
            "type": "string",
            "optional": true,
            "field": "query"
          }
        ],
        "optional": false,
        "name": "io.debezium.connector.{context}.Source", // <3>
        "field": "source"
      },
      {
        "type": "string",
        "optional": false,
        "field": "op"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ms"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_us"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ns"
      }
    ],
    "optional": false,
    "name": "{context}-server-1.inventory.customers.Envelope" // <4>
  },
  "payload": { // <5>
    "op": "c", // <6>
    "ts_ms": 1465491411815, // <7>
    "ts_us": 1465491411815437, // <7>
    "ts_ns": 1465491411815437158, // <7>
    "before": null, // <8>
    "after": { // <9>
      "id": 1004,
      "first_name": "Anne",
      "last_name": "Kretchmar",
      "email": "annek@noanswer.org"
    },
    "source": { // <10>
      "version": "{debezium-version}",
      "connector": "{context}",
      "name": "{context}-server-1",
      "ts_ms": 0,
      "ts_us": 0,
      "ts_ns": 0,
      "snapshot": false,
      "db": "inventory",
      "table": "customers",
      "server_id": 0,
      "gtid": null,
      "file": "{context}-bin.000003",
      "pos": 154,
      "row": 0,
      "thread": 7,
      "query": "INSERT INTO customers (first_name, last_name, email) VALUES ('Anne', 'Kretchmar', 'annek@noanswer.org')"
    }
  }
}
----

.Descriptions of _create_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The value's schema, which describes the structure of the value's payload.
A change event's value schema is the same in every change event that the connector generates for a particular table.

|2
|`name`
a|In the `schema` section, each `name` field specifies the schema for a field in the value's payload. +
 +
`{context}-server-1.inventory.customers.Value` is the schema for the payload's `before` and `after` fields.
This schema is specific to the `customers` table. +
 +
Names of schemas for `before` and `after` fields are of the form `_logicalName_._tableName_.Value`, which ensures that the schema name is unique in the database.
This means that when using the {link-prefix}:{link-avro-serialization}#avro-serialization[Avro converter], the resulting Avro schema for each table in each logical source has its own evolution and history.

|3
|`name`
|`io.debezium.connector.{context}.Source` is the schema for the payload's `source` field.
This schema is specific to the {connector-name} connector.
The connector uses it for all events that it generates.

|4
|`name`
|`{context}-server-1.inventory.customers.Envelope` is the schema for the overall structure of the payload, where `{context}-server-1` is the connector name, `inventory` is the database, and `customers` is the table.

|5
|`payload`
|The value's actual data.
This is the information that the change event is providing. +
 +
It may appear that the JSON representations of the events are much larger than the rows they describe.
This is because the JSON representation must include the schema and the payload portions of the message.
However, by using the {link-prefix}:{link-avro-serialization}#avro-serialization[Avro converter], you can significantly decrease the size of the messages that the connector streams to Kafka topics.

|6
|`op`
a| Mandatory string that describes the type of operation that caused the connector to generate the event.
In this example, `c` indicates that the operation created a row. Valid values are:

* `c` = create
* `u` = update
* `d` = delete
* `r` = read (applies to only snapshots)

|7
|`ts_ms`, `ts_us`, `ts_ns`
a| Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database.
By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|8
|`before`
| An optional field that specifies the state of the row before the event occurred.
When the `op` field is `c` for create, as it is in this example, the `before` field is `null` since this change event is for new content.

|9
|`after`
| An optional field that specifies the state of the row after the event occurred.
In this example, the `after` field contains the values of the new row's `id`, `first_name`, `last_name`, and `email` columns.

|10
|`source`
a| Mandatory field that describes the source metadata for the event.
This field contains information that you can use to compare this event with other events, with regard to the origin of the events, the order in which the events occurred, and whether events were part of the same transaction. The source metadata includes:

* {prodname} version
* Connector name
* binlog name where the event was recorded
* binlog position
* Row within the event
* If the event was part of a snapshot
* Name of the database and table that contain the new row
* ID of the {connector-name} thread that created the event (non-snapshot only)
* {connector-name} server ID (if available)
* Timestamp for when the change was made in the database


|===

:leveloffset: 1

// Type: continue
[id="mysql-update-events"]
=== _update_ events

:leveloffset: +1

The value of a change event for an update in the sample `customers` table has the same schema as a _create_ event for that table. Likewise, the event value's payload has the same structure. However, the event value payload contains different values in an _update_ event. Here is an example of a change event value in an event that the connector generates for an update in the `customers` table:

[source,json,options="nowrap",subs="+attributes"]
----
{
  "schema": { ... },
  "payload": {
    "before": { // <1>
      "id": 1004,
      "first_name": "Anne",
      "last_name": "Kretchmar",
      "email": "annek@noanswer.org"
    },
    "after": { // <2>
      "id": 1004,
      "first_name": "Anne Marie",
      "last_name": "Kretchmar",
      "email": "annek@noanswer.org"
    },
    "source": { // <3>
      "version": "{debezium-version}",
      "name": "{context}-server-1",
      "connector": "{context}",
      "name": "{context}-server-1",
      "ts_ms": 1465581029100,
      "ts_ms": 1465581029100000,
      "ts_ms": 1465581029100000000,
      "snapshot": false,
      "db": "inventory",
      "table": "customers",
      "server_id": 223344,
      "gtid": null,
      "file": "{context}-bin.000003",
      "pos": 484,
      "row": 0,
      "thread": 7,
      "query": "UPDATE customers SET first_name='Anne Marie' WHERE id=1004"
    },
    "op": "u", // <4>
    "ts_ms": 1465581029523, // <5>
    "ts_ms": 1465581029523758, // <6>
    "ts_ms": 1465581029523758914 // <7>
  }
}
----

.Descriptions of _update_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|An optional field that specifies the state of the row before the event occurred. In an _update_ event value, the `before` field contains a field for each table column and the value that was in that column before the database commit. In this example, the `first_name` value is `Anne.`

|2
|`after`
| An optional field that specifies the state of the row after the event occurred. You can compare the `before` and `after` structures to determine what the update to this row was. In the example, the `first_name` value is now `Anne Marie`.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. The `source` field structure has the same fields as in a _create_ event, but some values are different, for example, the sample _update_ event is from a different position in the binlog. The source metadata includes:

* {prodname} version
* Connector name
* binlog name where the event was recorded
* binlog position
* Row within the event
* If the event was part of a snapshot
* Name of the database and table that contain the updated row
* ID of the {connector-name} thread that created the event (non-snapshot only)
* {connector-name} server ID (if available)
* Timestamp for when the change was made in the database


|4
|`op`
a|Mandatory string that describes the type of operation. In an _update_ event value, the `op` field value is `u`, signifying that this row changed because of an update.

|5
|`ts_ms`
a| Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|6
|`ts_us`
a|Optional field that displays the time at which the connector processed the event, in microseconds.
The time is based on the system clock in the JVM running the Kafka Connect task.

|7
|`ts_ns`
a|Optional field that displays the time at which the connector processed the event, in nanoseconds.
The time is based on the system clock in the JVM running the Kafka Connect task.

|===

[NOTE]
====
Updating the columns for a row's primary/unique key changes the value of the row's key. When a key changes, {prodname} outputs _three_ events: a `DELETE` event and a xref:{context}-tombstone-events[tombstone event] with the old key for the row, followed by an event with the new key for the row. Details are in the next section.
====


:leveloffset: 1

// Type: continue
[id="mysql-primary-key-updates"]
=== Primary key updates

:leveloffset: +1

An `UPDATE` operation that changes a row's primary key field(s) is known
as a primary key change. For a primary key change, in place of an `UPDATE` event record, the connector emits a `DELETE` event record for the old key and a `CREATE` event record for the new (updated) key. These events have the usual structure and content, and in addition, each one has a message header related to the primary key change:

* The `DELETE` event record has `__debezium.newkey` as a message header. The value of this header is the new primary key for the updated row.

* The `CREATE` event record has `__debezium.oldkey` as a message header. The value of this header is the previous (old) primary key that the updated row had.


:leveloffset: 1


// Type: continue
[id="mysql-delete-events"]
=== _delete_ events

:leveloffset: +1

The value in a _delete_ change event has the same `schema` portion as _create_ and _update_ events for the same table. The `payload` portion in a _delete_ event for the sample `customers` table looks like this:

[source,json,options="nowrap",subs="+attributes"]
----
{
  "schema": { ... },
  "payload": {
    "before": { // <1>
      "id": 1004,
      "first_name": "Anne Marie",
      "last_name": "Kretchmar",
      "email": "annek@noanswer.org"
    },
    "after": null, // <2>
    "source": { // <3>
      "version": "{debezium-version}",
      "connector": "{context}",
      "name": "{context}-server-1",
      "ts_ms": 1465581902300,
      "ts_us": 1465581902300000,
      "ts_ns": 1465581902300000000,
      "snapshot": false,
      "db": "inventory",
      "table": "customers",
      "server_id": 223344,
      "gtid": null,
      "file": "{context}-bin.000003",
      "pos": 805,
      "row": 0,
      "thread": 7,
      "query": "DELETE FROM customers WHERE id=1004"
    },
    "op": "d", // <4>
    "ts_ms": 1465581902461, // <5>
    "ts_us": 1465581902461842, // <6>
    "ts_ns": 1465581902461842579 // <7>
  }
}
----

.Descriptions of _delete_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|Optional field that specifies the state of the row before the event occurred. In a _delete_ event value, the `before` field contains the values that were in the row before it was deleted with the database commit.

|2
|`after`
| Optional field that specifies the state of the row after the event occurred. In a _delete_ event value, the `after` field is `null`, signifying that the row no longer exists.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. In a _delete_ event value, the `source` field structure is the same as for _create_ and _update_ events for the same table. Many `source` field values are also the same. In a _delete_ event value, the `ts_ms` and `pos` field values, as well as other values, might have changed. But the `source` field in a _delete_ event value provides the same metadata:

* {prodname} version
* Connector name
* binlog name where the event was recorded
* binlog position
* Row within the event
* If the event was part of a snapshot
* Name of the database and table that contain the updated row
* ID of the {connector-name} thread that created the event (non-snapshot only)
* {connector-name} server ID (if available)
* Timestamp for when the change was made in the database


|4
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `d`, signifying that this row was deleted.

|5
|`ts_ms`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|6
|`ts_us`
a|Optional field that displays the time at which the connector processed the event, in microseconds.
The time is based on the system clock in the JVM running the Kafka Connect task.

|7
|`ts_ns`
a|Optional field that displays the time at which the connector processed the event, in nanoseconds.
The time is based on the system clock in the JVM running the Kafka Connect task.

|===

A _delete_ change event record provides a consumer with the information it needs to process the removal of this row. The old values are included because some consumers might require them in order to properly handle the removal.

{connector-name} connector events are designed to work with link:{link-kafka-docs}/#compaction[Kafka log compaction]. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.

:leveloffset: 1

// Type: continue
[id="mysql-tombstone-events"]
=== Tombstone events

:leveloffset: +1

When a row is deleted, the _delete_ event value still works with log compaction, because Kafka can remove all earlier messages that have that same key.
However, for Kafka to remove all messages that have that same key, the message value must be `null`.
To make this possible, after the {prodname} {connector-name} connector emits a _delete_ event, the connector emits a special tombstone event that has the same key but a `null` value.

:leveloffset: 1

// Type: continue
[id="mysql-truncate-events"]
=== _truncate_ events

:leveloffset: +1

A  _truncate_ change event signals that a table has been truncated.
The message key of a _truncate_ event is `null`.
The message value resembles the following example:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "source": { // <1>
            "version": "{debezium-version}",
            "name": "{context}-server-1",
            "connector": "{context}",
            "name": "{context}-server-1",
            "ts_ms": 1465581029100,
            "ts_us": 1465581029100000,
            "ts_ns": 1465581029100000000,
            "snapshot": false,
            "db": "inventory",
            "table": "customers",
            "server_id": 223344,
            "gtid": null,
            "file": "{context}-bin.000003",
            "pos": 484,
            "row": 0,
            "thread": 7,
            "query": "UPDATE customers SET first_name='Anne Marie' WHERE id=1004"
        },
        "op": "t", // <2>
        "ts_ms": 1465581029523, // <3>
        "ts_us": 1465581029523468, // <4>
        "ts_ns": 1465581029523468471 // <5>
    }
}
----

.Descriptions of _truncate_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`source`
a|Mandatory field that describes the source metadata for the event. In a _truncate_ event value, the `source` field structure is the same as for _create_, _update_, and _delete_ events for the same table, provides this metadata:

* {prodname} version
* Connector type and name
* Binlog name where the event was recorded
* Binlog position
* Row within the event
* If the event was part of a snapshot
* Name of the database and table
* ID of the {connector-name} thread that truncated the event (non-snapshot only)
* {connector-name} server ID (if available)
* Timestamp for when the change was made in the database

|2
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `t`, signifying that this table was truncated.

|3
|`ts_ms`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|4
|`ts_us`
a|Optional field that displays the time at which the connector processed the event, in microseconds. The time is based on the system clock in the JVM running the Kafka Connect task.

|5
|`ts_ns`
a|Optional field that displays the time at which the connector processed the event, in nanoseconds. The time is based on the system clock in the JVM running the Kafka Connect task.

|===

In case a single `TRUNCATE` statement applies to multiple tables,
one _truncate_ change event record for each truncated table will be emitted.

[NOTE]
====
A _truncate_ event represents a change that applies to an entire table, and it does not have a message key.
In topics that span multiple partition, the order of change events that apply to an entire table is is not guaranteed.
That is, there is no ordering guarantee for (_create_, _update_, etc.), or for the _truncate_ events for that table.
When a consumer reads events from different partition, it might read an _update_ event for a table from one partition only after it reads a _truncate_ event for the same table from a second partition.
====

:leveloffset: 1

// Type: reference
// ModuleID: how-debezium-mysql-connectors-map-data-types
// Title: How {prodname} MySQL connectors map data types
[[mysql-data-types]]
== Data type mappings

:leveloffset: +1


The {prodname} {connector-name} connector represents changes to rows with events that are structured like the table in which the row exists. The event contains a field for each column value.
The {connector-name} data type of that column dictates how {prodname} represents the value in the event.

Columns that store strings are defined in {connector-name} with a character set and collation.
The {connector-name} connector uses the column's character set when reading the binary representation of the column values in the binlog events.

The connector can map {connector-name} data types to both _literal_ and _semantic_ types.

* *Literal type*: how the value is represented using Kafka Connect schema types.
* *Semantic type*: how the Kafka Connect schema captures the meaning of the field (schema name).

If the default data type conversions do not meet your needs, you can {link-prefix}:{link-custom-converters}#custom-converters[create a custom converter] for the connector.


:leveloffset: 1

[id="mysql-basic-types"]
=== Basic types

:leveloffset: +1

The following table shows how the connector maps basic {connector-name} data types.

.Descriptions of basic type mappings
[cols="25%a,20%a,55%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`BOOLEAN, BOOL`
|`BOOLEAN`
a|_n/a_

|`BIT(1)`
|`BOOLEAN`
a|_n/a_

|`BIT(>1)`
|`BYTES`
a|`io.debezium.data.Bits` +
 +
The `length` schema parameter contains an integer that represents the number of bits. The `byte[]` contains the bits in _little-endian_ form and is sized to contain the specified number of bits. For example, where `n` is bits: +
`numBytes = n/8 + (n%8== 0 ? 0 : 1)`

|`TINYINT`
|`INT16`
a|_n/a_

|`SMALLINT[(M)]`
|`INT16`
a|_n/a_

|`MEDIUMINT[(M)]`
|`INT32`
a|_n/a_

|`INT, INTEGER[(M)]`
|`INT32`
a|_n/a_

|`BIGINT[(M)]`
|`INT64`
a|_n/a_

|`REAL[(M,D)]`
|`FLOAT32`
a|_n/a_

|`FLOAT[(P)]`
|`FLOAT32` or `FLOAT64`
a|The precision is used only to determine storage size.
A precision `P` from 0 to 23 results in a 4-byte single-precision `FLOAT32` column.
A precision `P` from 24 to 53 results in an 8-byte double-precision `FLOAT64` column.


|`DOUBLE[(M,D)]`
|`FLOAT64`
a|_n/a_

|`CHAR(M)]`
|`STRING`
a|_n/a_

|`VARCHAR(M)]`
|`STRING`
a|_n/a_

|`BINARY(M)]`
|`BYTES` or `STRING`
a|_n/a_ +
 +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{context}-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`VARBINARY(M)]`
|`BYTES` or `STRING`
a|_n/a_ +
 +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{context}-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`TINYBLOB`
|`BYTES` or `STRING`
a|_n/a_ +
 +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{context}-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`TINYTEXT`
|`STRING`
a|_n/a_

|`BLOB`
|`BYTES` or `STRING`
a|_n/a_ +
 +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{context}-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting. +
 +
Only values with a size of up to 2GB are supported. It is recommended to externalize large column values, using the claim check pattern.

|`TEXT`
|`STRING`
a|_n/a_ +
 +
Only values with a size of up to 2GB are supported. It is recommended to externalize large column values, using the claim check pattern.

|`MEDIUMBLOB`
|`BYTES` or `STRING`
a|_n/a_ +
 +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{context}-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`MEDIUMTEXT`
|`STRING`
a|_n/a_

|`LONGBLOB`
|`BYTES` or `STRING`
a|_n/a_ +
 +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{context}-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting. +
 +
Only values with a size of up to 2GB are supported. It is recommended to externalize large column values, using the claim check pattern.

|`LONGTEXT`
|`STRING`
a|_n/a_ +
 +
Only values with a size of up to 2GB are supported. It is recommended to externalize large column values, using the claim check pattern.

|`JSON`
|`STRING`
a|`io.debezium.data.Json` +
 +
Contains the string representation of a `JSON` document, array, or scalar.

|`ENUM`
|`STRING`
a|`io.debezium.data.Enum` +
 +
The `allowed` schema parameter contains the comma-separated list of allowed values.

|`SET`
|`STRING`
a|`io.debezium.data.EnumSet` +
 +
The `allowed` schema parameter contains the comma-separated list of allowed values.

|`YEAR[(2\|4)]`
|`INT32`
|`io.debezium.time.Year`

|`TIMESTAMP[(M)]`
|`STRING`
a|`io.debezium.time.ZonedTimestamp` +
 +
In link:https://www.iso.org/iso-8601-date-and-time-format.html[ISO 8601] format with microsecond precision.
{connector-name} allows `M` to be in the range of `0-6`.

|===

:leveloffset: 1

.
[id="mysql-temporal-types"]
=== Temporal types

:leveloffset: +1

Excluding the `TIMESTAMP` data type, {connector-name} temporal types depend on the value of the `time.precision.mode` connector configuration property. For `TIMESTAMP` columns whose default value is specified as `CURRENT_TIMESTAMP` or `NOW`, the value `1970-01-01 00:00:00` is used as the default value in the Kafka Connect schema.

{connector-name} allows zero-values for `DATE`, `DATETIME`, and `TIMESTAMP` columns because zero-values are sometimes preferred over null values.
The {connector-name} connector represents zero-values as null values when the column definition allows null values, or as the epoch day when the column does not allow null values.

.Temporal values without time zones
The `DATETIME` type represents a local date and time such as "2018-01-13 09:48:27". As you can see, there is no time zone information. Such columns are converted into epoch milliseconds or microseconds based on the column’s precision by using UTC.
The `TIMESTAMP` type represents a timestamp without time zone information.
It is converted by {connector-name} from the server (or session’s) current time zone into UTC when writing and from UTC into the server (or session's) current time zone when reading back the value. For example:

* `DATETIME` with a value of `2018-06-20 06:37:03` becomes `1529476623000`.
* `TIMESTAMP` with a value of `2018-06-20 06:37:03` becomes `2018-06-20T13:37:03Z`.

Such columns are converted into an equivalent `io.debezium.time.ZonedTimestamp` in UTC based on the server (or session’s) current time zone.
The time zone will be queried from the server by default.


The time zone of the JVM running Kafka Connect and {prodname} does not affect these conversions.

More details about properties related to temporal values are in the documentation for xref:{context}-connector-properties[{connector-name} connector configuration properties].

time.precision.mode=adaptive_time_microseconds(default)::
The {connector-name} connector determines the literal type and semantic type based on the column's data type definition so that events represent exactly the values in the database. All time fields are in microseconds. Only positive `TIME` field values in the range of `00:00:00.000000` to `23:59:59.999999` can be captured correctly.
+
.Mappings when `time.precision.mode=adaptive_time_microseconds`
[cols="25%a,20%a,55%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`DATE`
|`INT32`
a|`io.debezium.time.Date` +
Represents the number of days since the epoch.

|`TIME[(M)]`
|`INT64`
a|`io.debezium.time.MicroTime` +
Represents the time value in microseconds and does not include time zone information.
{connector-name} allows `M` to be in the range of `0-6`.

|`DATETIME, DATETIME(0), DATETIME(1), DATETIME(2), DATETIME(3)`
|`INT64`
a|`io.debezium.time.Timestamp` +
Represents the number of milliseconds past the epoch and does not include time zone information.

|`DATETIME(4), DATETIME(5), DATETIME(6)`
|`INT64`
a|`io.debezium.time.MicroTimestamp` +
Represents the number of microseconds past the epoch and does not include time zone information.

|===

time.precision.mode=connect::
The {connector-name} connector uses defined Kafka Connect logical types. This approach is less precise than the default approach and the events could be less precise if the database column has a _fractional second precision_ value of greater than `3`. Values in only the range of `00:00:00.000` to `23:59:59.999` can be handled. Set `time.precision.mode=connect` only if you can ensure that the `TIME` values in your tables never exceed the supported ranges. The `connect` setting is expected to be removed in a future version of {prodname}.
+
.Mappings when `time.precision.mode=connect`
[cols="25%a,20%a,55%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`DATE`
|`INT32`
a|`org.apache.kafka.connect.data.Date` +
Represents the number of days since the epoch.

|`TIME[(M)]`
|`INT64`
a|`org.apache.kafka.connect.data.Time` +
Represents the time value in microseconds since midnight and does not include time zone information.

|`DATETIME[(M)]`
|`INT64`
a|`org.apache.kafka.connect.data.Timestamp` +
Represents the number of milliseconds since the epoch, and does not include time zone information.

|===

:leveloffset: 1

[id="mysql-decimal-types"]
=== Decimal types

:leveloffset: +1

{prodname} connectors handle decimals according to the setting of the xref:{context}-property-decimal-handling-mode[`decimal.handling.mode`] connector configuration property.

decimal.handling.mode=precise::
+
.Mappings when `decimal.handling.mode=precise`
[cols="30%a,15%a,55%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`NUMERIC[(M[,D])]`
|`BYTES`
a|`org.apache.kafka.connect.data.Decimal` +
The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.

|`DECIMAL[(M[,D])]`
|`BYTES`
a|`org.apache.kafka.connect.data.Decimal` +
The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.

|===

decimal.handling.mode=double::
+
.Mappings when `decimal.handling.mode=double`
[cols="30%a,30%a,40%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`NUMERIC[(M[,D])]`
|`FLOAT64`
a|_n/a_

|`DECIMAL[(M[,D])]`
|`FLOAT64`
a|_n/a_

|===

decimal.handling.mode=string::
+
.Mappings when `decimal.handling.mode=string`
[cols="30%a,30%a,40%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`NUMERIC[(M[,D])]`
|`STRING`
a|_n/a_

|`DECIMAL[(M[,D])]`
|`STRING`
a|_n/a_

|===

:leveloffset: 1

[id="mysql-boolean-values"]
=== Boolean values

:leveloffset: +1

{connector-name} handles the `BOOLEAN` value internally in a specific way.
The `BOOLEAN` column is internally mapped to the `TINYINT(1)` data type.
When the table is created during streaming then it uses proper `BOOLEAN` mapping as {prodname} receives the original DDL.
During snapshots, {prodname} executes `SHOW CREATE TABLE` to obtain table definitions that return `TINYINT(1)` for both `BOOLEAN` and `TINYINT(1)` columns. {prodname} then has no way to obtain the original type mapping and so maps to `TINYINT(1)`.

To enable you to convert source columns to Boolean data types, {prodname} provides a `TinyIntOneToBooleanConverter` {link-prefix}:{link-custom-converters}#custom-converters[custom converter] that you can use in one of the following ways:

* Map all `TINYINT(1)` or `TINYINT(1) UNSIGNED` columns to `BOOLEAN` types.
* Enumerate a subset of columns by using a comma-separated list of regular expressions. +
To use this type of conversion, you must set the xref:{context}-property-converters[`converters`] configuration property with the `selector` parameter, as shown in the following example:
+
[source]
----
converters=boolean
boolean.type=io.debezium.connector.binlog.converters.TinyIntOneToBooleanConverter
boolean.selector=db1.table1.*, db1.table2.column1
----
* NOTE: In some cases, the database may not show the length of `tinyint unsigned` when the snapshot executes `SHOW CREATE TABLE`, which means this converter doesn't work. The new option `length.checker` can solve this issue, the default value is `true`. Disable the `length.checker` and specify the columns that need to be converted to `selected` property instead of converting all columns based on type, as shown in the following example:
+
[source]
----
converters=boolean
boolean.type=io.debezium.connector.binlog.converters.TinyIntOneToBooleanConverter
boolean.length.checker=false
boolean.selector=db1.table1.*, db1.table2.column1
----

:leveloffset: 1

[id="mysql-spatial-types"]
=== Spatial types

:leveloffset: +1

Currently, the {prodname} {connector-name} connector supports the following spatial data types.

.Description of spatial type mappings
[cols="35%a,15%a,50%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`GEOMETRY, +
LINESTRING, +
POLYGON, +
MULTIPOINT, +
MULTILINESTRING, +
MULTIPOLYGON, +
GEOMETRYCOLLECTION`
|`STRUCT`
a|`io.debezium.data.geometry.Geometry` +
Contains a structure with two fields:

* `srid (INT32`: spatial reference system ID that defines the type of geometry object stored in the structure
* `wkb (BYTES)`: binary representation of the geometry object encoded in the Well-Known-Binary (wkb) format. See the link:https://www.opengeospatial.org/standards/sfa[Open Geospatial Consortium] for more details.

|===

:leveloffset: 1

// Type: concept
// Title: Custom converters for mapping {connector-name} data to alternative data types
[id="debezium-mysql-connector-converters"]
== Custom converters

:leveloffset: +1

By default, the {prodname} {connector-name} connector provides several `CustomConverter` implementations for {connector-name} data types.
These custom converters provide alternative mappings for specific data types based on the connector configuration.
To add a `CustomConverter` to the connector, follow the instructions in the {link-prefix}:{link-custom-converters}#custom-converters[Custom Converters documentation].

:leveloffset: 1

=== `TINYINT(1)` to Boolean

:leveloffset: +1

By default, during a connector snapshot, the {prodname} {connector-name} connector obtains column types from the JDBC driver, which assigns the `TINYINT(1)` type to `BOOLEAN` columns.
{prodname} then uses these JDBC column types to define the schema for the snapshot events.
After the connector transitions from the snapshot to the streaming phase, the change event schema that results from the default mapping can lead to inconsistent mappings for `BOOLEAN` columns.
To help ensure that {connector-name} emits `BOOLEAN` columns uniformly, you can apply the custom  `TinyIntOneToBooleanConverter`, as shown in the following configuration example.

.Example: `TinyIntOneToBooleanConverter` configuration
[source]
----
converters=tinyint-one-to-boolean
tinyint-one-to-boolean.type=io.debezium.connector.binlog.converters.TinyIntOneToBooleanConverter
tinyint-one-to-boolean.selector=.*.MY_TABLE.DATA
tinyint-one-to-boolean.length.checker=false
----

In the preceding example, the `selector` and `length.checker` properties are optional.
By default, the converter checks that `TINYINT` data types conform to a length of `1`.
If `length.checker` to `false`, the converter does not explicitly confirm that the `TINYINT` data type conforms to a length of `1`.
The `selector` designates the tables or columns to convert, based on the supplied regular expression.
If you omit the `selector` property, the converter maps all `TINYINT` columns to logical `BOOL` field types.
If you do not configure a `selector` option, and you want to map `TINYINT` columns to `TINYINT(1)`, omit the `length.checker` property, or set its value to `true`.

:leveloffset: 1

=== JDBC sink data types

:leveloffset: +1

If you integrate the {prodname} JDBC sink connector with a {prodname} {connector-name} source connector, the {connector-name} connector emits some column attributes differently during the snapshot and streaming phases.
For the JDBC sink connector to consistently consume changes from both the snapshot and streaming phase, you must include the `JdbcSinkDataTypesConverter` converter as part of the {connector-name} source connector configuration, as shown in the following example:

.Example: `JdbcSinkDataTypesConverter` configuration
[source]
----
converters=jdbc-sink
jdbc-sink.type=io.debezium.connector.binlog.converters.JdbcSinkDataTypesConverter
jdbc-sink.selector.boolean=.*.MY_TABLE.BOOL_COL
jdbc-sink.selector.real=.*.MY_TABLE.REAL_COL
jdbc-sink.selector.string=.*.MY_TABLE.STRING_COL
jdbc-sink.treat.real.as.double=true
----

In the preceding example, the `selector.*` and `treat.real.as.double` configuration properties are optional.

The `selector.*` properties specify comma-separated lists of regular expressions that specify which tables and columns that the converter applies to.
By default, the converter applies the following rules apply to all Boolean, real, and string-based column data types, across all tables:

* `BOOLEAN` data types are always emitted as `INT16` logical types, with `1` representing `true` and `0` representing `false`
* `REAL` data types are always emitted as `FLOAT64` logical types.
* String-based columns always include the `__debezium.source.column.character_set` schema parameter that contains the column's character set.

For each data type, you can configure a selector rule to override the default scope and apply the selector to specific tables and columns only.
For example, to set the scope of the Boolean converter, add the following rule to the connector configuration, as in the preceding example: `converters.jdbc-sink.selector.boolean=.*.MY_TABLE.BOOL_COL`

:leveloffset: 1


// Type: assembly
// ModuleID: setting-up-mysql-to-run-a-debezium-connector
// Title: Setting up MySQL to run a {prodname} connector
[[setting-up-mysql]]
== Setting up MySQL

:leveloffset: +1

Some {connector-name} setup tasks are required before you can install and run a {prodname} connector.


:leveloffset: 1

// Type: procedure
// ModuleID: creating-a-mysql-user-for-a-debezium-connector
// Title: Creating a MySQL user for a {prodname} connector
[[mysql-creating-user]]
=== Creating a user

:leveloffset: +1

A {prodname} {connector-name} connector requires a {connector-name} user account.
This {connector-name} user must have appropriate permissions on all databases for which the {prodname} {connector-name} connector captures changes.

.Prerequisites

* A {connector-name} server.
* Basic knowledge of SQL commands.

.Procedure

. Create the {connector-name} user:
+
[source,SQL,subs="+attributes"]
----
{context}> CREATE USER 'user'@'localhost' IDENTIFIED BY 'password';
----

. Grant the required permissions to the user:
+
[source,SQL,subs="+attributes"]
----
{context}> GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'user' IDENTIFIED BY 'password';
----
+
For a description of the required permissions, see xref:permissions-explained-{context}-connector[].
+
IMPORTANT: If using a hosted option such as Amazon RDS or Amazon Aurora that does not allow a global read lock, table-level locks are used to create the _consistent snapshot_. In this case, you need to also grant `LOCK TABLES` permissions to the user that you create. See xref:{context}-snapshots[snapshots] for more details.

. Finalize the user's permissions:
+
[source,SQL,subs="+attributes"]
----
{context}> FLUSH PRIVILEGES;
----

+
[id="permissions-explained-{context}-connector"]
.Descriptions of user permissions
[cols="3,7",options="header",subs="+attributes"]
|===
|Keyword |Description

|`SELECT`
|Enables the connector to select rows from tables in databases. This is used only when performing a snapshot.

|`RELOAD`
|Enables the connector the use of the `FLUSH` statement to clear or reload internal caches, flush tables, or acquire locks. This is used only when performing a snapshot.

|`SHOW DATABASES`
|Enables the connector to see database names by issuing the `SHOW DATABASE` statement. This is used only when performing a snapshot.

|`REPLICATION SLAVE`
|Enables the connector to connect to and read the {connector-name} server binlog.

|`REPLICATION CLIENT`
a|Enables the connector the use of the following statements:

* `SHOW MASTER STATUS`
* `SHOW SLAVE STATUS`
* `SHOW BINARY LOGS`

The connector always requires this.

|`ON`
|Identifies the database to which the permissions apply.

|`TO 'user'`
|Specifies the user to grant the permissions to.

|`IDENTIFIED BY 'password'`
|Specifies the user's {connector-name} password.

|===


:leveloffset: 1

// Type: procedure
// ModuleID: enabling-the-mysql-binlog-for-debezium
// Title: Enabling the MySQL binlog for {prodname}
[[enable-mysql-binlog]]
=== Enabling the binlog

:leveloffset: +1

You must enable binary logging for {connector-name} replication.
The binary logs record transaction updates in a way that enables replicas to propagate those changes.

.Prerequisites

* A {connector-name} server.
* Appropriate {connector-name} user privileges.

.Procedure

. Check whether the `log-bin` option is enabled:
+
[source,SQL]
----
// for MySQL 5.x
mysql> SELECT variable_value as "BINARY LOGGING STATUS (log-bin) ::"
FROM information_schema.global_variables WHERE variable_name='log_bin';
// for MySQL 8.x
mysql> SELECT variable_value as "BINARY LOGGING STATUS (log-bin) ::"
FROM performance_schema.global_variables WHERE variable_name='log_bin';
----
. If the binlog is `OFF`, add the properties in the following table to the configuration file for the {connector-name} server:
+
[source,properties,subs="+attributes"]
----
server-id         = 223344 # Querying variable is called server_id, e.g. SELECT variable_value FROM information_schema.global_variables WHERE variable_name='server_id';
log_bin                     = {context}-bin
binlog_format               = ROW
binlog_row_image            = FULL
binlog_expire_logs_seconds  = 864000
----

. Confirm your changes by checking the binlog status once more:
+
[source,SQL]
----
// for MySQL 5.x
{context}> SELECT variable_value as "BINARY LOGGING STATUS (log-bin) ::"
FROM information_schema.global_variables WHERE variable_name='log_bin';
// for MySQL 8.x
{context}> SELECT variable_value as "BINARY LOGGING STATUS (log-bin) ::"
FROM performance_schema.global_variables WHERE variable_name='log_bin';
----
. If you run {connector-name} on Amazon RDS, you must enable automated backups for your database instance for binary logging to occur.
If the database instance is not configured to perform automated backups, the binlog is disabled, even if you apply the settings described in the previous steps.

+
[id="binlog-configuration-properties-{context}-connector"]
.Descriptions of {connector-name} binlog configuration properties
[cols="1,4",options="header",subs="+attributes"]
|===
|Property |Description

|`server-id`
|The value for the `server-id` must be unique for each server and replication client in the {connector-name} cluster.

|`log_bin`
|The value of `log_bin` is the base name of the sequence of binlog files.

|`binlog_format`
|The `binlog-format` must be set to `ROW` or `row`.

|`binlog_row_image`
|The `binlog_row_image` must be set to `FULL` or `full`.

|`binlog_expire_logs_seconds`
|The `binlog_expire_logs_seconds` corresponds to deprecated system variable `expire_logs_days`.
This is the number of seconds for automatic binlog file removal.
The default value is `2592000`, which equals 30 days.
Set the value to match the needs of your environment.
For more information, see xref:{context}-purges-binlog-files-used-by-debezium[{connector-name} purges binlog files].

|===


:leveloffset: 1


// Type: procedure
// ModuleID: enabling-mysql-gtids-for-debezium
// Title: Enabling MySQL Global Transaction Identifiers for {prodname}
[[enable-mysql-gtids]]
=== Enabling GTIDs

Global transaction identifiers (GTIDs) uniquely identify transactions that occur on a server within a cluster. Though not required for a {prodname} MySQL connector, using GTIDs simplifies replication and enables you to more easily confirm if primary and replica servers are consistent.

GTIDs are available in MySQL 5.6.5 and later. See the link:https://dev.mysql.com/doc/refman/{mysql-version}/en/replication-options-gtids.html#option_mysqld_gtid-mode[MySQL documentation] for more details.

.Prerequisites

* A MySQL server.
* Basic knowledge of SQL commands.
* Access to the MySQL configuration file.

.Procedure

. Enable `gtid_mode`:
+
[source,SQL]
----
mysql> gtid_mode=ON
----

. Enable `enforce_gtid_consistency`:
+
[source,SQL]
----
mysql> enforce_gtid_consistency=ON
----

. Confirm the changes:
+
[source,SQL]
----
mysql> show global variables like '%GTID%';
----

+
.Result
[source,SQL]
----
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| enforce_gtid_consistency | ON    |
| gtid_mode                | ON    |
+--------------------------+-------+
----

+
.Descriptions of GTID options
[cols="3,7",options="header",subs="+attributes"]
|===
|Option |Description

|`gtid_mode`
a|Boolean that specifies whether GTID mode of the MySQL server is enabled or not.

* `ON` = enabled
* `OFF` = disabled

|`enforce_gtid_consistency`
a|Boolean that specifies whether the server enforces GTID consistency by allowing the execution of statements that can be logged in a transactionally safe manner. Required when using GTIDs.

* `ON` = enabled
* `OFF` = disabled

|===


// Type: procedure
// ModuleID: configuring-mysql-session-timeouts-for-debezium
// Title: Configuring MySQL session timesouts for {prodname}
[[mysql-session-timeouts]]
=== Configuring session timeouts

:leveloffset: +1

When an initial consistent snapshot is made for large databases, your established connection could timeout while the tables are being read.
You can prevent this behavior by configuring `interactive_timeout` and `wait_timeout` in your {connector-name} configuration file.

.Prerequisites

* A {connector-name} server.
* Basic knowledge of SQL commands.
* Access to the {connector-name} configuration file.

.Procedure

. Configure `interactive_timeout`:
+
[source,SQL,subs="+attributes,+quotes"]
----
{context}> interactive_timeout=<duration-in-seconds>
----

. Configure `wait_timeout`:
+
[source,SQL,subs="+attributes,+quotes"]
----
{context}> wait_timeout=<duration-in-seconds>
----

+
.Descriptions of {connector-name} session timeout options
[cols="3,7",options="header",subs="+attributes"]
|===
|Option |Description

|`interactive_timeout`
a|The number of seconds the server waits for activity on an interactive connection before closing it.
For more information see the:
link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_interactive_timeout[MySQL documentation].
|`wait_timeout`
a|The number of seconds that the server waits for activity on a non-interactive connection before closing it.
For more information, see the link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_interactive_timeout[MySQL documentation].
|===

:leveloffset: 1

// Type: procedure
// ModuleID: enabling-query-log-events-for-debezium-mysql-connectors
// Title: Enabling query log events for {prodname} MySQL connectors
[[enable-query-log-events]]
=== Enabling query log events

You might want to see the original `SQL` statement for each binlog event.
Enabling the `binlog_rows_query_log_events` option in the MySQL configuration file allows you to do this.

This option is available in MySQL 5.6 and later.

.Prerequisites

* A MySQL server.
* Basic knowledge of SQL commands.
* Access to the MySQL configuration file.

.Procedure

* Enable `binlog_rows_query_log_events` in MySQL:
+
[source,SQL]
----
mysql> binlog_rows_query_log_events=ON
----
+
`binlog_rows_query_log_events` is set to a value that enables/disables support for including the original `SQL` statement in the binlog entry.
+
** `ON` = enabled
** `OFF` = disabled

// Type: procedure
// ModuleID: validate-binlog-row-value-options-for-debezium-mysql-connectors
// Title: validate binlog row value options for {prodname} MySQL connectors
[[validate-binlog-row-value-options]]
=== Validating binlog row value options

:leveloffset: +1

Verify the setting of the `binlog_row_value_options` variable in the database.
To enable the connector to consume *UPDATE* events, this variable must be set to a value other than `PARTIAL_JSON`.

.Prerequisites

* A {connector-name} server.
* Basic knowledge of SQL commands.
* Access to the {connector-name} configuration file.

.Procedure

. Check current variable value
+
[source,SQL,subs="+attributes,+quotes"]
----
{context}> show global variables where variable_name = 'binlog_row_value_options';
----

+
.Result
+
[source,SQL]
----
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| binlog_row_value_options |       |
+--------------------------+-------+
----

. If the value of the variable is set to `PARTIAL_JSON`, run the following command to unset it:
+
[source,SQL,subs="+attributes,+quotes"]
----
{context}> set @@global.binlog_row_value_options="" ;
----

:leveloffset: 1


// Type: assembly
// ModuleID: deployment-of-debezium-mysql-connectors
// Title: Deployment of {prodname} MySQL connectors
[[mysql-deploying-a-connector]]
== Deployment

:leveloffset: +1

To deploy a {prodname} {connector-name} connector, you install the {prodname} {connector-name} connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect.

.Prerequisites
* link:https://zookeeper.apache.org/[Apache Zookeeper], link:http://kafka.apache.org/[Apache Kafka], and link:{link-kafka-docs}.html#connect[Kafka Connect] are installed.
* {connector-name} Server is installed and is xref:setting-up-{context}[set up to work with the {prodname} connector].

.Procedure

. Download the {prodname} link:https://repo1.maven.org/maven2/io/debezium/debezium-connector-mysql/{debezium-version}/debezium-connector-mysql-{debezium-version}-plugin.tar.gz[MySQL connector plug-in].
. Extract the files into your Kafka Connect environment.
. Add the directory with the JAR files to {link-kafka-docs}/#connectconfigs[Kafka Connect's `plugin.path`].
. xref:{context}-example-configuration[Configure the connector] and xref:{context}-adding-configuration[add the configuration to your Kafka Connect cluster.]
. Restart your Kafka Connect process to pick up the new JAR files.

If you are working with immutable containers, see link:https://quay.io/organization/debezium[{prodname}'s Container images] for Apache Zookeeper, Apache Kafka, {connector-name}, and Kafka Connect with the {connector-name} connector already installed and ready to run.

You can also xref:operations/openshift.adoc[run {prodname} on Kubernetes and OpenShift].


:leveloffset: 1


[[mysql-example-configuration]]
=== MySQL connector configuration example

:leveloffset: +1

Following is an example of the configuration for a connector instance that captures data from a {connector-name} server on port 3306 at 192.168.99.100, which we logically name `fullfillment`.
Typically, you configure the {prodname} {connector-name} connector in a JSON file by setting the configuration properties that are available for the connector.

You can choose to produce events for a subset of the schemas and tables in a database.
Optionally, you can ignore, mask, or truncate columns that contain sensitive data, that are larger than a specified size, or that you do not need.

[source,json]
----
{
    "name": "inventory-connector", // <1>
    "config": {
        "connector.class": "io.debezium.connector.{context}.{connector-name}Connector", // <2>
        "database.hostname": "192.168.99.100", // <3>
        "database.port": "3306", // <4>
        "database.user": "debezium-user", // <5>
        "database.password": "debezium-user-pw", // <6>
        "database.server.id": "184054", <7>
        "topic.prefix": "fullfillment", // <8>
        "database.include.list": "inventory", // <9>
        "schema.history.internal.kafka.bootstrap.servers": "kafka:9092", // <10>
        "schema.history.internal.kafka.topic": "schemahistory.fullfillment", // <11>
        "include.schema.changes": "true" // <12>
    }
}
----
<1> Connector's name when registered with the Kafka Connect service.
<2> Connector's class name.
<3> {connector-name} server address.
<4> {connector-name} server port number.
<5> {connector-name} user with the appropriate privileges.
<6> {connector-name} user's password.
<7> Unique ID of the connector.
<8> Topic prefix for the {connector-name} server or cluster.
<9> List of databases hosted by the specified server.
<10> List of Kafka brokers that the connector uses to write and recover DDL statements to the database schema history topic.
<11> Name of the database schema history topic. This topic is for internal use only and should not be used by consumers.
<12> Flag that specifies if the connector should generate events for DDL changes and emit them to the `fulfillment` schema change topic for use by consumers.


For the complete list of the configuration properties that you can set for the {prodname} {connector-name} connector,
see xref:{context}-connector-properties[{connector-name} connector configuration properties].

You can send this configuration with a `POST` command to a running Kafka Connect service.
The service records the configuration and starts one connector task that performs the following actions:

* Connects to the {connector-name} database.
* Reads change-data tables for tables in capture mode.
* Streams change event records to Kafka topics.

:leveloffset: 1

[[mysql-adding-configuration]]
=== Adding connector configuration

:leveloffset: +1

To start running a {connector-name} connector, configure a connector configuration, and add the configuration to your Kafka Connect cluster.

.Prerequisites

* xref:setting-up-{context}[{connector-name} is set up to work with a {prodname} connector].
* The {prodname} {connector-name} connector is installed.

.Procedure

. Create a configuration for the {connector-name} connector.

. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster.

.Results
After the connector starts, it xref:{context}-snapshots[performs a consistent snapshot] of the {connector-name} databases that the connector is configured for.
The connector then starts generating data change events for row-level operations and streaming change event records to Kafka topics.


:leveloffset: 1


// Type: reference
// Title: Descriptions of {prodname} MySQL connector configuration properties
[[mysql-connector-properties]]
=== Connector properties

:leveloffset: +1

The {prodname} {connector-name} connector has numerous configuration properties that you can use to achieve the right connector behavior for your application.
Many properties have default values.
Information about the properties is organized as follows:

* xref:{context}-required-connector-configuration-properties[Required connector configuration properties]
* xref:{context}-advanced-connector-configuration-properties[Advanced connector configuration properties]
* xref:debezium-{context}-connector-database-history-configuration-properties[Database schema history connector configuration properties] that control how {prodname} processes events that it reads from the database schema history topic.
** xref:{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[Pass-through database schema history properties]
* xref:debezium-{context}-connector-pass-through-database-driver-configuration-properties[Pass-through database driver properties] that control the behavior of the database driver.


:leveloffset: 1

[id="mysql-required-connector-configuration-properties"]
==== Required {prodname} MySQL connector configuration properties

:leveloffset: +1

The following configuration properties are _required_ unless a default value is available.

[id="{context}-property-bigint-unsigned-handling-mode"]
xref:{context}-property-bigint-unsigned-handling-mode[`bigint.unsigned.handling.mode`]::
 +
Default value: `long` +
Specifies how the connector represents BIGINT UNSIGNED columns in change events.
Set one of the following options:

`long`::: Uses Java `long` data types to represent BIGINT UNSIGNED column values.
Although the `long` type does not offer the greatest precision, it is easy implement in most consumers.
In most environments, this is the preferred setting.

`precise`::: Uses `java.math.BigDecimal` data types to represent values.
The connector uses the Kafka Connect `org.apache.kafka.connect.data.Decimal` data type to represent values in encoded binary format.
Set this option if the connector typically works with values larger than 2^63.
The `long` data type cannot convey values of that size.



[id="{context}-property-binary-handling-mode"]
xref:{context}-property-binary-handling-mode[`binary.handling.mode`]::
Default value: `bytes` +
Specifies how the connector represents values for binary columns, such as, `blob`, `binary`, `varbinary`, in change events. +
Set one of the following options:
`bytes`::: Represents binary data as a byte array.

`base64`::: Represents binary data as a base64-encoded String.

`base64-url-safe`::: Represents binary data as a base64-url-safe-encoded String.

`hex`::: Represents binary data as a hex-encoded (base16) String.


[id="{context}-property-column-exclude-list"]
xref:{context}-property-column-exclude-list[`column.exclude.list`]::
Default value: _empty string_ +
An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to exclude from change event record values.
Other columns in the source record are captured as usual.
Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_. +
+
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; it does not match substrings that might be present in a column name.
If you include this property in the configuration, do not also set the `column.include.list` property.



[id="{context}-property-column-include-list"]
xref:{context}-property-column-include-list[`column.include.list`]::
Default value:  _empty string_ +
An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to include in change event record values.
Other columns are omitted from the event record.
Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_. +
+
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; it does not match substrings that might be present in a column name. +
If you include this property in the configuration, do not set the `column.exclude.list` property.

////
[id="{context}-property-column-mask-hash"]
[id="{context}-property-column-mask-hash-v2"]
xref:{context}-property-column-mask-hash[`column.mask.hash._hashAlgorithm_.with.salt._salt_`] +
xref:{context}-property-column-mask-hash-v2[`column.mask.hash.v2._hashAlgorithm_.with.salt._salt_`]::
////
[id="{context}-property-column-mask-hash"]
xref:{context}-property-column-mask-hash[`column.mask.hash._hashAlgorithm_.with.salt._salt_`]::
[id="{context}-property-column-mask-hash-v2"]
xref:{context}-property-column-mask-hash-v2[`column.mask.hash.v2._hashAlgorithm_.with.salt._salt_`]::
Default value: No default +
An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Fully-qualified names for columns are of the form `_<databaseName>_._<tableName>_._<columnName>_`. +
To match the name of a column {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.
In the resulting change event record, the values for the specified columns are replaced with pseudonyms.
 +
A pseudonym consists of the hashed value that results from applying the specified _hashAlgorithm_ and _salt_.
Based on the hash function that is used, referential integrity is maintained, while column values are replaced with pseudonyms.
Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation. +
+
In the following example, `CzQMA0cB5K` is a randomly selected salt.
+
----
column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName
----
+
If necessary, the pseudonym is automatically shortened to the length of the column.
The connector configuration can include multiple properties that specify different hash algorithms and salts. +
+
Depending on the _hashAlgorithm_ used, the _salt_ selected, and the actual data set, the resulting data set might not be completely masked. +
+
Hashing strategy version 2 ensures fidelity of values that are hashed in different places or systems.



[id="{context}-property-column-mask-with-length-chars"]
xref:{context}-property-column-mask-with-length-chars[`column.mask.with._length_.chars`]::
Default value: No default +
An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want the connector to mask the values for a set of columns, for example, if they contain sensitive data.
Set `_length_` to a positive integer to replace data in the specified columns with the number of asterisk (`*`) characters specified by the _length_ in the property name.
Set _length_ to `0` (zero) to replace data in the specified columns with an empty string.
+
The fully-qualified name of a column observes the following format: _databaseName_._tableName_._columnName_.
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.
+
You can specify multiple properties with different lengths in a single configuration.



[id="{context}-property-column-propagate-source-type"]
xref:{context}-property-column-propagate-source-type[`column.propagate.source.type`]::
Default value: No default +
An optional, comma-separated list of regular expressions that match the fully-qualified names of columns for which you want the connector to emit extra parameters that represent column metadata.
When this property is set, the connector adds the following fields to the schema of event records:

* `pass:[_]pass:[_]debezium.source.column.type`
* `pass:[_]pass:[_]debezium.source.column.length`
* `pass:[_]pass:[_]debezium.source.column.scale` +
 +
These parameters propagate a column's original type name and length (for variable-width types), respectively. +
Enabling the connector to emit this extra data can assist in properly sizing specific numeric or character-based columns in sink databases. +
 +
The fully-qualified name of a column observes one of the following formats: _databaseName_._tableName_._columnName_, or _databaseName_._schemaName_._tableName_._columnName_. +
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.



[id="{context}-property-column-truncate-to-length-chars"]
xref:{context}-property-column-truncate-to-length-chars[`column.truncate.to._length_.chars`]::
Default value: No default +
An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want to truncate the data in a set of columns when it exceeds the number of characters specified by the _length_ in the property name.
Set `length` to a positive integer value, for example, `column.truncate.to.20.chars`.
+
The fully-qualified name of a column observes the following format: _databaseName_._tableName_._columnName_.
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.
+
You can specify multiple properties with different lengths in a single configuration.



[id="{context}-property-connect-timeout-ms"]
xref:{context}-property-connect-timeout-ms[`connect.timeout.ms`]::
Default value: `30000` (30 seconds) +
A positive integer value that specifies the maximum time in milliseconds that the connector waits to establish a connection to the {connector-name} database server before the connection request times out.



[id="{context}-property-connector-class"]
xref:{context}-property-connector-class[`connector.class`]::
Default value: No default +
The name of the Java class for the connector.
Always specify
`io.debezium.connector.mysql.MySqlConnector`
for the {connector-name} connector.


[id="{context}-property-database-exclude-list"]
xref:{context}-property-database-exclude-list[`database.exclude.list`]::
Default value: _empty string_ +
An optional, comma-separated list of regular expressions that match the names of databases from which you do not want the connector to capture changes.
The connector captures changes in any database that is not named in the `database.exclude.list`. +
+
To match the name of a database, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the database; it does not match substrings that might be present in a database name. +
If you include this property in the configuration, do not also set the `database.include.list` property.


[id="{context}-property-database-hostname"]
xref:{context}-property-database-hostname[`database.hostname`]::
Default value: No default +
The IP address or hostname of the {connector-name} database server.



[id="{context}-property-database-include-list"]
xref:{context}-property-database-include-list[`database.include.list`]::
Default value: _empty string_ +
An optional, comma-separated list of regular expressions that match the names of the databases from which the connector captures changes.
The connector does not capture changes in any database whose name is not in `database.include.list`.
By default, the connector captures changes in all databases. +
+
To match the name of a database, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the database; it does not match substrings that might be present in a database name. +
If you include this property in the configuration, do not also set the `database.exclude.list` property.


[id="{context}-property-database-jdbc-driver"]
xref:{context}-property-database-jdbc-driver[`database.jdbc.driver`]::
Default value: `com.mysql.cj.jdbc.Driver` +
Specifies the name of the driver class that the connector uses.
You can use this setting to specify a driver other than the one that is packaged with the connector.


[id="{context}-property-database-password"]
xref:{context}-property-database-password[`database.password`]::
Default value: No default +
The password of the {connector-name} user that the connector uses to connect to the {connector-name} database server.


[id="{context}-property-database-port"]
xref:{context}-property-database-port[`database.port`]::
Default value: `3306` +
Integer port number of the {connector-name} database server.


[id="{context}-property-database-protocol"]
xref:{context}-property-database-protocol[`database.protocol`]::
Default value: `jdbc:mysql` +
Specifies the JDBC protocol that the driver connection string uses to connect to the database.


[id="{context}-property-database-server-id"]
xref:{context}-property-database-server-id[`database.server.id`]::
Default value: No default +
The numeric ID of this database client.
The specified ID must be unique across all currently running database processes in the {connector-name} cluster.
To enable it to read the binlog, the connector uses this unique ID to join the {connector-name} database cluster as another server.



[id="{context}-property-database-user"]
xref:{context}-property-database-user[`database.user`]::
Default value: No default +
The name of the {connector-name} user that the connector uses to connect to the {connector-name} database server.



[id="{context}-property-decimal-handling-mode"]
xref:{context}-property-decimal-handling-mode[`decimal.handling.mode`]::
Default value: `precise` +
Specifies how the connector handles values for `DECIMAL` and `NUMERIC` columns in change events. +
Set one of the following options:

`precise` (default)::: Uses `java.math.BigDecimal` values in binary form to represent values precisely.

`double`::: Uses the `double` data type to represent values.
This option can result in a loss of precision, but it is easier for most consumers to use.

`string`::: Encodes values as formatted strings.
This option is easy to consume, but can result in the loss of semantic information about the real type.




[id="{context}-property-event-deserialization-failure-handling-mode"]
xref:{context}-property-event-deserialization-failure-handling-mode[`event.deserialization.failure.handling.mode`]::
Default value: `fail` +
Specifies how the connector reacts after an exception occurs during deserialization of binlog events.
This option is deprecated, please use xref:{context}-property-event-processing-failure-handling-mode[`event.processing.failure.handling.mode`] option instead.

`fail`::: Propagates the exception, which indicates the problematic event and its binlog offset, and causes the connector to stop.

`warn`::: Logs the problematic event and its binlog offset and then skips the event.

`ignore`::: Passes over the problematic event and does not log anything.



[id="{context}-property-field-name-adjustment-mode"]
xref:{context}-property-field-name-adjustment-mode[`field.name.adjustment.mode`]::
Default value: No default +
Specifies how field names should be adjusted for compatibility with the message converter used by the connector.
Set one of the following options:

`none`::: No adjustment.
`avro`::: Replaces characters that are not valid in Avro names with underscore characters.
`avro_unicode`::: Replaces underscore characters or characters that cannot be used in Avro names with corresponding unicode, such as `$$_$$uxxxx`. +
+
[NOTE]
====
 `_` is an escape sequence, similar to a backslash in Java
====
+
For more information, see: {link-prefix}:{link-avro-serialization}#avro-naming[Avro naming].



[id="{context}-property-gtid-source-excludes"]
xref:{context}-property-gtid-source-excludes[`gtid.source.excludes`]::
Default value: No default +
A comma-separated list of regular expressions that match source domain IDs in the GTID set that the connector uses to find the binlog position on the {connector-name} server.
When this property is set, the connector uses only the GTID ranges that have source UUIDs that do not match any of the specified `exclude` patterns. +
 +
To match the value of a GTID, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the GTID's domain identifier. +
If you include this property in the configuration, do not also set the `gtid.source.includes` property.



[id="{context}-property-gtid-source-includes"]
xref:{context}-property-gtid-source-includes[`gtid.source.includes`]::
Default value: No default +
A comma-separated list of regular expressions that match source domain IDs in the GTID set used that the connector uses to find the binlog position on the {connector-name} server.
When this property is set, the connector uses only the GTID ranges that have source UUIDs that match one of the specified `include` patterns. +
 +
To match the value of a GTID, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the GTID's domain identifier. +
If you include this property in the configuration, do not also set the `gtid.source.excludes` property.


[id="{context}-property-include-query"]
xref:{context}-property-include-query[`include.query`]::
Default value: `false` +
Boolean value that specifies whether the connector should include the original SQL query that generated the change event. +
 +
If you set this option to `true` then you must also configure {connector-name} with the `binlog_annotate_row_events` option set to `ON`.
When `include.query` is `true`, the query is not present for events that the snapshot process generates. +
 +
Setting `include.query` to `true` might expose tables or fields that are explicitly excluded or masked by including the original SQL statement in the change event.
For this reason, the default setting is `false`. +
 +
For more information about configuring the database to return the original `SQL` statement for each log event, see xref:enable-query-log-events[Enabling query log events].




[id="{context}-property-include-schema-changes"]
xref:{context}-property-include-schema-changes[`include.schema.changes`]::
Default value: `true` +
Boolean value that specifies whether the connector publishes changes that occur to the database schema to a Kafka topic with the name of the database server ID.
Each schema change event that the connector captures uses a key that contains the database name and a value that includes the DDL statements that describe the change.
This setting does not affect how the connector records schema changes in its internal database schema history.



[id="{context}-property-include-schema-comments"]
xref:{context}-property-include-schema-comments[`include.schema.comments`]::
Default value: `false` +
Boolean value that specifies whether the connector parses and publishes table and column comments on metadata objects. +
+
NOTE: When you set this option to `true`, the schema comments that the connector includes can add a significant amount of string data to each schema object.
Increasing the number and size of logical schema objects increases the amount of memory that the connector uses.



[id="{context}-property-inconsistent-schema-handling-mode"]
xref:{context}-property-inconsistent-schema-handling-mode[`inconsistent.schema.handling.mode`]::
Default value: `fail` +
Specifies how the connector responds to binlog events that refer to tables that are not present in the internal schema representation.
That is, the internal representation is not consistent with the database. +
Set one of the following options:

`fail`::: The connector throws an exception that reports the problematic event and its binlog offset.
The connector then stops.

`warn`::: The connector logs the problematic event and its binlog offset, and then skips the event.

`skip`::: The connector skips the problematic event and does not report it in the log.



[id="{context}-property-message-key-columns"]
xref:{context}-property-message-key-columns[`message.key.columns`]::
Default value: No default +
A list of expressions that specify the columns that the connector uses to form custom message keys for change event records that it publishes to the Kafka topics for specified tables. +
By default, {prodname} uses the primary key column of a table as the message key for records that it emits.
In place of the default, or to specify a key for tables that lack a primary key, you can configure custom message keys based on one or more columns.
 +
To establish a custom message key for a table, list the table, followed by the columns to use as the message key.
Each list entry takes the following format: +
 +
`_<fully-qualified_tableName>_:__<keyColumn>__,_<keyColumn>_` +
 +
To base a table key on multiple column names, insert commas between the column names.
 +
Each fully-qualified table name is a regular expression in the following format:
 +
`_<databaseName>_._<tableName>_` +
 +
The property can include entries for multiple tables.
Use a semicolon to separate table entries in the list. +
 +
The following example sets the message key for the tables `inventory.customers` and `purchase.orders`: +
 +
`inventory.customers:pk1,pk2;(.*).purchaseorders:pk3,pk4` +
 +
For the table `inventory.customer`, the columns `pk1` and `pk2` are specified as the message key.
For the `purchaseorders` tables in any database, the columns `pk3` and `pk4` server as the message key.
 +
There is no limit to the number of columns that you use to create custom message keys.
However, it's best to use the minimum number that are required to specify a unique key.



[id="{context}-property-name"]
xref:{context}-property-name[`name`]::
Default value: No default +
Unique name for the connector.
If you attempt to use the same name to register another connector, registration fails.
This property is required by all Kafka Connect connectors.


[id="{context}-property-schema-name-adjustment-mode"]
xref:{context}-property-schema-name-adjustment-mode[`schema.name.adjustment.mode`]::
Default value: No default +
Specifies how the connector adjusts schema names for compatibility with the message converter used by the connector.
Set one of the following options:

`none`::: No adjustment.
`avro`::: Replaces characters that are not valid in Avro names with underscore characters.
`avro_unicode`::: Replaces underscore characters or characters that cannot be used in Avro names with corresponding unicode, such as `$$_$$uxxxx.` +
 +
NOTE: `_` is an escape sequence, similar to a backslash in Java



[id="{context}-property-skip-messages-without-change"]
xref:{context}-property-skip-messages-without-change[`skip.messages.without.change`]::
Default value: `false` +
Specifies whether the connector emits messages for records when it does not detect a change in the included columns.
Columns are considered to be included if they are listed in the `column.include.list`, or are not listed in the `column.exclude.list`.
Set the value to `true` to prevent the connector from capturing records when no changes are present in the included columns.


[id="{context}-property-table-exclude-list"]
xref:{context}-property-table-exclude-list[`table-exclude-list`]::
Default value: _empty string_ +
An optional, comma-separated list of regular expressions that match fully-qualified table identifiers of tables from which you do not want the connector to capture changes.
The connector captures changes in any table that is not included in `table.exclude.list`.
Each identifier is of the form _databaseName_._tableName_. +
+
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name. +
If you include this property in the configuration, do not also set the `table.include.list` property.



[id="{context}-property-table-include-list"]
xref:{context}-property-table-include-list[`table.include.list`]::
Default value: _empty string_ +
An optional, comma-separated list of regular expressions that match fully-qualified table identifiers of tables whose changes you want to capture.
The connector does not capture changes in any table that is not included in `table.include.list`.
Each identifier is of the form _databaseName_._tableName_.
By default, the connector captures changes in all non-system tables in every database from which it is configured to captures changes. +
+
To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name. +
If you include this property in the configuration, do not also set the `table.exclude.list` property.



[id="{context}-property-tasks-max"]
xref:{context}-property-tasks-max[`tasks.max`]::
Default value: `1` +
The maximum number of tasks to create for this connector.
Because the {connector-name} connector always uses a single task, changing the default value has no effect.




[id="{context}-property-time-precision-mode"]
xref:{context}-property-time-precision-mode[`time.precision.mode`]::
Default value: `adaptive_time_microseconds` +
Specifies the type of precision that the connector uses to represent time, date, and timestamps values.
Set one of the following options: +
+
`adaptive_time_microseconds` (default)::: The connector captures the date, datetime and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type, with the exception of TIME type fields, which are always captured as microseconds. +
+
`adaptive` (deprecated)::: The connector captures time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the data type of the column. +
+
`connect`::: The connector always represents time and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which use millisecond precision regardless of the database columns' precision.



[id="{context}-property-tombstones-on-delete"]
xref:{context}-property-tombstones-on-delete[`tombstones.on.delete`]::
Default value: `true` +
Specifies whether a _delete_ event is followed by a tombstone event.
After a source record is deleted, the connector can emit a tombstone event (the default behavior) to enable Kafka to completely delete all events that pertain to the key of the deleted row in case {link-kafka-docs}/#compaction[log compaction] is enabled for the topic.
Set one of the following options: +
+
`true` (default)::: The connector represents delete operations by emitting a _delete_ event and a subsequent tombstone event. +

`false`::: The connector emits only _delete_ events. +



[id="{context}-property-topic-prefix"]
xref:{context}-property-topic-prefix[`topic.prefix`]::
Default value: No default +
Topic prefix that provides a namespace for the particular {connector-name} database server or cluster in which {prodname} is capturing changes.
Because the topic prefix is used to name all of the Kafka topics that receive events that this connector emits, it's important that the topic prefix is unique across all connectors.
Values must contain only alphanumeric characters, hyphens, dots, and underscores. +
+
[WARNING]
====
After you set this property, do not change its value.
If you change the value, after the connector restarts, instead of continuing to emit events to the original topics, the connector emits subsequent events to topics whose names are based on the new value.
The connector is also unable to recover its database schema history topic.
====

:leveloffset: 1

[id="mysql-advanced-connector-configuration-properties"]
==== Advanced {prodname} MySQL connector configuration properties

:leveloffset: +1

The following list describes advanced {connector-name} connector configuration properties.
The default values for these properties rarely require changes.
Therefore, you do not need to specify them in the connector configuration.

[id="{context}-property-binlog-buffer-size"]
xref:{context}-property-binlog-buffer-size[`binlog.buffer.size`]::
*Default value:* `0` +
The size of a look-ahead buffer used by the binlog reader.
The default setting of `0` disables buffering. +
+
Under specific conditions, it is possible that the {connector-name} binlog contains uncommitted data finished by a `ROLLBACK` statement.
Typical examples are using savepoints or mixing temporary and regular table changes in a single transaction. +
+
When a beginning of a transaction is detected then {prodname} tries to roll forward the binlog position and find either `COMMIT` or `ROLLBACK` so it can determine whether to stream the changes from the transaction.
The size of the binlog buffer defines the maximum number of changes in the transaction that {prodname} can buffer while searching for transaction boundaries.
If the size of the transaction is larger than the buffer then {prodname} must rewind and re-read the events that have not fit into the buffer while streaming. +
+
NOTE: This feature is incubating. Feedback is encouraged. It is expected that this feature is not completely polished.


[id="{context}-property-connect-keep-alive"]
xref:{context}-property-connect-keep-alive[`connect.keep.alive`]::
Default value: `true` +
A Boolean value that specifies whether a separate thread should be used to ensure that the connection to the {connector-name} server or cluster is kept alive.


[id="{context}-property-converters"]
xref:{context}-property-converters[`converters`]::
Default value: No default +
Enumerates a comma-separated list of the symbolic names of the {link-prefix}:{link-custom-converters}#custom-converters[custom converter] instances that the connector can use. +
For example, `boolean`. +
This property is required to enable the connector to use a custom converter.
 +
For each converter that you configure for a connector, you must also add a `.type` property, which specifies the fully-qualified name of the class that implements the converter interface.
The `.type` property uses the following format: +
+
`_<converterSymbolicName>_.type`
+
For example, +
+
 boolean.type: io.debezium.connector.binlog.converters.TinyIntOneToBooleanConverter
+
If you want to further control the behavior of a configured converter, you can add one or more configuration parameters to pass values to the converter.
To associate these additional configuration parameter with a converter, prefix the parameter name with the symbolic name of the converter. +
+
For example, to define a `selector` parameter that specifies the subset of columns that the `boolean` converter processes, add the following property: +

 boolean.selector=db1.table1.*, db1.table2.column1



[id="{context}-property-custom-metric-tags"]
xref:{context}-property-custom-metric-tags[`custom.metric.tags`]::
Default value: No default +
Defines tags that customize MBean object names by adding metadata that provides contextual information.
Specify a comma-separated list of key-value pairs.
Each key represents a tag for the MBean object name, and the corresponding value represents a value for the key, for example,  +
`k1=v1,k2=v2` +
 +
The connector appends the specified tags to the base MBean object name.
Tags can help you to organize and categorize metrics data.
You can define tags to identify particular application instances, environments, regions, versions, and so forth.
For more information, see xref:customized-mbean-names[Customized MBean names].

[id="{context}-property-database-initial-statements"]
xref:{context}-property-database-initial-statements[`database.initial.statements`]::
Default value: No default +
A semicolon separated list of SQL statements to be executed when a JDBC connection, not the connection that is reading the transaction log, to the database is established.
To specify a semicolon as a character in a SQL statement and not as a delimiter, use two semicolons, (`;;`). +
+
The connector might establish JDBC connections at its own discretion, so this property is ony for configuring session parameters. It is not for executing DML statements.


[id="{context}-property-database-query-timeout-ms"]
xref:{context}-property-database-query-timeout-ms[`database.query.timeout.ms`]::
Default value: `600000` (10 minutes) +
Specifies the time, in milliseconds, that the connector waits for a query to complete.
Set the value to `0` (zero) to remove the timeout limit.



[id="{context}-property-database-ssl-keystore"]
xref:{context}-property-database-ssl-keystore[`database.ssl.keystore`]::
Default value: No default +
An optional setting that specifies the location of the key store file.
A key store file can be used for two-way authentication between the client and the {connector-name} server.


[id="{context}-property-database-ssl-keystore-password"]
xref:{context}-property-database-ssl-keystore-password[`database.ssl.keystore.password`]::
Default value: No default +
The password for the key store file.
Specify a password only if the xref:{context}-property-database-ssl-keystore[`database.ssl.keystore`] is configured.


[id="{context}-property-database-ssl-mode"]
xref:{context}-property-database-ssl-mode[`database.ssl.mode`]::
Default value: `preferred` +
Specifies whether the connector uses an encrypted connection.
The following settings are available:

`disabled`::: Specifies the use of an unencrypted connection.

`preferred` (Default)::: The connector establishes an encrypted connection if the server supports secure connections.
If the server does not support secure connections, the connector falls back to using an unencrypted connection.

`required`::: The connector establishes an encrypted connection.
If it is unable to establish an encrypted connection, the connector fails.

`verify_ca`::: The connector behaves as when you set the `required` option, but it also verifies the server TLS certificate against the configured Certificate Authority (CA) certificates.
If the server TLS certificate does not match any valid CA certificates, the connector fails. +

`verify_identity`::: The connector behaves as when you set the `verify_ca` option, but it also verifies that the server certificate matches the host of the remote connection.

[id="{context}-property-database-ssl-truststore"]
xref:{context}-property-database-ssl-truststore[`database.ssl.truststore`]::
Default value: No default +
The location of the trust store file for the server certificate verification.



[id="{context}-property-database-ssl-truststore-password"]
xref:{context}-property-database-ssl-truststore-password[`database.ssl.truststore.password`]::
Default value: No default +
The password for the trust store file.
Used to check the integrity of the truststore, and unlock the truststore.


[id="{context}-property-enable-time-adjuster"]
xref:{context}-property-enable-time-adjuster[`enable.time.adjuster`]::
Default value: `true` +
Boolean value that indicates whether the connector converts a 2-digit year specification to 4 digits.
Set the value to `false` when conversion is fully delegated to the database. +
+
{connector-name} users can insert year values with either 2-digits or 4-digits.
2-digit values are mapped to a year in the range 1970 - 2069.
By default, the connector performs the conversion.



[id="{context}-property-errors-max-retries"]
xref:{context}-property-errors-max-retries[`errors.max.retries`]::
Default value: `-1` +
Specifies how the connector responds after an operation that results in a retriable error, such as a connection error. +
Set one of the following options:

`-1`::: No limit.
The connector always restarts automatically, and retries the operation, regardless of the number of previous failures.

`0`::: Disabled.
The connector fails immediately, and never retries the operation.
User intervention is required to restart the connector.

`> 0`::: The connector restarts automatically until it reaches the specified maximum number of retries.
After the next failure, the connector stops, and user intervention is required to restart it.



[id="{context}-property-event-converting-failure-handling-mode"]
xref:{context}-property-event-converting-failure-handling-mode[`event.converting.failure.handling.mode`]::
Default value: `warn` +
Specifies how the connector responds when it cannot convert a table record due to a mismatch between the data type of a column and the type specified by the {prodname} internal schema. +
Set one of the following options:

`fail`:::  An exception reports that conversion failed because the data type of the field did not match the schema type, and indicates that it might be necessary to restart the connector in `schema _only_recovery` mode to enable a successful conversion.
`warn`::: The connector writes a `null` value to the event field for the column that failed conversion, writes a message to the warning log . +
`skip`:::  The connector writes a `null` value to the event field for the column that failed conversion, and writes a message to the debug log.



[id="{context}-property-event-processing-failure-handling-mode"]
xref:{context}-property-event-processing-failure-handling-mode[`event.processing.failure.handling.mode`]::
Default value: `fail` +
Specifies how the connector handles failures that occur when processing events, for example, if it encounters a corrupted event.
The following settings are available:

`fail`::: The connector raises an exception that reports the problematic event and its position.
The connector then stops.

`warn`::: The connector does not raise an exception.
Instead, it logs the problematic event and its position, and then skips the event.

`ignore`::: The connector ignores the problematic event, and does not generate a log entry.



[id="{context}-property-heartbeat-action-query"]
xref:{context}-property-heartbeat-action-query[`heartbeat.action.query`]::
Default value: No default +
Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. +
+
For example, the following query periodically captures the state of the executed GTID set in the source database. +
+
`INSERT INTO gtid_history_table (select @gtid_executed)`



[id="{context}-property-heartbeat-interval-ms"]
xref:{context}-property-heartbeat-interval-ms[`heartbeat.interval.ms`]::
Default value: `0` +
Specifies how frequently the connector sends heartbeat messages to a Kafka topic.
By default, the connector does not send heartbeat messages. +
+
Heartbeat messages are useful for monitoring whether the connector is receiving change events from the database. Heartbeat messages might help decrease the number of change events that need to be re-sent when a connector restarts. To send heartbeat messages, set this property to a positive integer, which indicates the number of milliseconds between heartbeat messages.



[id="{context}-property-incremental-snapshot-allow-schema-changes"]
xref:{context}-property-incremental-snapshot-allow-schema-changes[`incremental.snapshot.allow.schema.changes`]::
Default value: `false` +
Specifies whether the connector allows schema changes during an incremental snapshot.
When the value is set to `true`, the connector detects schema change during an incremental snapshot, and re-select a current chunk to avoid locking DDLs. +
 +
Changes to a primary key are not supported.
Changing the primary during an incremental snapshot, can lead to incorrect results.
A further limitation is that if a schema change affects only the default values of columns, then the change is not detected until the DDL is processed from the binlog stream.
This does not affect the values of snapshot events, but the schema of these snapshot events may have outdated defaults.



[id="{context}-property-incremental-snapshot-chunk-size"]
xref:{context}-property-incremental-snapshot-chunk-size[`incremental.snapshot.chunk.size`]::
Default value: `1024` +
The maximum number of rows that the connector fetches and reads into memory when it retrieves an incremental snapshot chunk.
Increasing the chunk size provides greater efficiency, because the snapshot runs fewer snapshot queries of a greater size.
However, larger chunk sizes also require more memory to buffer the snapshot data.
Adjust the chunk size to a value that provides the best performance in your environment.



[id="{context}-property-incremental-snapshot-watermarking-strategy"]
xref:{context}-property-incremental-snapshot-watermarking-strategy[`incremental.snapshot.watermarking.strategy`]::
Default value: `insert_insert` +
Specifies the watermarking mechanism that the connector uses during an incremental snapshot to deduplicate events that might be captured by an incremental snapshot and then recaptured after streaming resumes. +
You can specify one of the following options:

`insert_insert` (default)::: When you send a signal to initiate an incremental snapshot, for every chunk that {prodname} reads during the snapshot, it writes an entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, {prodname} inserts a second entry that records the signal to close the window.

`insert_delete`::: When you send a signal to initiate an incremental snapshot, for every chunk that {prodname} reads, it writes a single entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, this entry is removed.
No entry is created for the signal to close the snapshot window.
Set this option to prevent rapid growth of the signaling data collection.



[id="{context}-property-max-batch-size"]
xref:{context}-property-max-batch-size[`max.batch.size`]::
Default value: `2048` +
Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector.



[id="{context}-property-max-queue-size"]
xref:{context}-property-max-queue-size[`max.queue.size`]::
Default value: `8192` +
A positive integer value that specifies the maximum number of records that the blocking queue can hold.
When {prodname} reads events streamed from the database, it places the events in the blocking queue before it writes them to Kafka.
The blocking queue can provide backpressure for reading change events from the database
in cases where the connector ingests messages faster than it can write them to Kafka, or when Kafka becomes unavailable.
Events that are held in the queue are disregarded when the connector periodically records offsets.
Always set `max.queue.size` to a value that is larger than the value of xref:{context}-property-max-batch-size[`max.batch.size`].



[id="{context}-property-max-queue-size-in-bytes"]
xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`]::
Default value: `0` +
A long integer value that specifies the maximum volume of the blocking queue in bytes.
By default, volume limits are not specified for the blocking queue.
To specify the number of bytes that the queue can consume, set this property to a positive long value. +
If xref:{context}-property-max-queue-size[`max.queue.size`] is also set, writing to the queue is blocked when the size of the queue reaches the limit specified by either property.
For example, if you set `max.queue.size=1000`, and `max.queue.size.in.bytes=5000`, writing to the queue is blocked after the queue contains 1000 records, or after the volume of the records in the queue reaches 5000 bytes.



[id="{context}-property-min-row-count-to-stream-results"]
xref:{context}-property-min-row-count-to-stream-results[`min.row.count.to.stream.results`]::
Default value: `1000` +
During a snapshot, the connector queries each table for which the connector is configured to capture changes. The connector uses each query result to produce a read event that contains data for all rows in that table.
This property determines whether the {connector-name} connector puts results for a table into memory, which is fast but requires large amounts of memory, or streams the results, which can be slower but work for very large tables. The setting of this property specifies the minimum number of rows a table must contain before the connector streams results. +
+
To skip all table size checks and always stream all results during a snapshot, set this property to `0`.



[id="{context}-property-notification-enabled-channels"]
xref:{context}-property-notification-enabled-channels[`notification.enabled.channels`]::
Default value: No default +
List of notification channel names that are enabled for the connector.
By default, the following channels are available:

* `sink`
* `log`
* `jmx`

+
Optionally, you can also implement a {link-prefix}:{link-notification}#debezium-notification-custom-channel[custom notification channel].



[id="{context}-property-poll-interval-ms"]
xref:{context}-property-poll-interval-ms[`poll.interval.ms`]::
Default value: `500` (0.5 seconds) +
Positive integer value that specifies the number of milliseconds the connector waits for new change events to appear before it starts processing a batch of events.



[id="{context}-property-provide-transaction-metadata"]
xref:{context}-property-provide-transaction-metadata[`provide.transaction.metadata`]::
Default value: `false` +
Determines whether the connector generates events with transaction boundaries and enriches change event envelopes with transaction metadata. Specify `true` if you want the connector to do this.
For more information, see xref:{context}-transaction-metadata[Transaction metadata].



[id="{context}-property-read-only"]
xref:{context}-property-read-only[`read.only`]::
Default value: `false` +
Specifies whether a connector writes watermarks to the signal data collection to track the progress of an incremental snapshot.
Set the value to `true` to enable a connector that has a read-only connection to the database to use an incremental snapshot watermarking strategy that does not require writing to the signal data collection.

[id="{context}-property-signal-data-collection"]
xref:{context}-property-signal-data-collection[`signal.data.collection`]::
Default value: No default +
Fully-qualified name of the data collection that is used to send {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[signals] to the connector. +
Use the following format to specify the collection name: +
`_<databaseName>_._<tableName>_`



[id="{context}-property-signal-enabled-channels"]
xref:{context}-property-signal-enabled-channels[`signal.enabled.channels`]::
Default value: No default +
List of the signaling channel names that are enabled for the connector.
By default, the following channels are available:

* `source`
* `kafka`
* `file`
* `jmx`

+
Optionally, you can also implement a {link-prefix}:{link-signalling}#debezium-signaling-enabling-custom-signaling-channel[custom signaling channel].



[id="{context}-property-skipped-operations"]
xref:{context}-property-skipped-operations[`skipped.operations`]::
Default value: `t` +
A comma-separated list of operation types that will be skipped during streaming.
The operations include: `c` for inserts/create, `u` for updates, `d` for deletes, `t` for truncates, and `none` to not skip any operations.
By default, truncate operations are skipped.



[id="{context}-property-snapshot-delay-ms"]
xref:{context}-property-snapshot-delay-ms[`snapshot.delay.ms`]::
Default value: No default +
An interval in milliseconds that the connector should wait before performing a snapshot when the connector starts. If you are starting multiple connectors in a cluster, this property is useful for avoiding snapshot interruptions, which might cause re-balancing of connectors.



[id="{context}-property-snapshot-fetch-size"]
xref:{context}-property-snapshot-fetch-size[`snapshot.fetch.size`]::
Default value: No default +
During a snapshot, the connector reads table content in batches of rows.
This property specifies the maximum number of rows in a batch.


[id="{context}-property-snapshot-include-collection-list"]
xref:{context}-property-snapshot-include-collection-list[`snapshot.include.collection.list`]::
Default value: All tables specified in the `table.include.list`. +
An optional, comma-separated list of regular expressions that match the fully-qualified names (`_<databaseName>.<tableName>_`) of the tables to include in a snapshot.
The specified items must be named in the connector's xref:{context}-property-table-include-list[`table.include.list`] property.
This property takes effect only if the connector's xref:{context}-property-snapshot-mode[`snapshot.mode`] property is set to a value other than `never`. +
This property does not affect the behavior of incremental snapshots. +
 +
To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name.



[id="{context}-property-snapshot-lock-timeout-ms"]
xref:{context}-property-snapshot-lock-timeout-ms[`snapshot.lock.timeout.ms`]::
Default value: `10000` +
Positive integer that specifies the maximum amount of time (in milliseconds) to wait to obtain table locks when performing a snapshot. If the connector cannot acquire table locks in this time interval, the snapshot fails.
For more information, see
xref:mysql-snapshots[how {connector-name} connectors perform database snapshots].



[id="{context}-property-snapshot-locking-mode"]
xref:{context}-property-snapshot-locking-mode[`snapshot.locking.mode`]::
Default value: `minimal` +
Specifies whether and for how long the connector holds the global {connector-name} read lock, which prevents any updates to the database while the connector is performing a snapshot.
The following settings are available:

`minimal`::: The connector holds the global read lock for only the initial phase of the snapshot during which it reads the database schemas and other metadata.
During the next phase of the snapshot, the connector releases the lock as it selects all rows from each table.
To perform the SELECT operation in a consistent fashion, the connector uses a REPEATABLE READ transaction.
Although the release of the global read lock permits other {connector-name} clients to update the database, use of REPEATABLE READ isolation ensures a consistent snapshot, because the connector continues to read the same data for the duration of  the transaction. +

`extended`::: Blocks all write operations for the duration of the snapshot.
Use this setting if clients submit concurrent operations that are incompatible with the REPEATABLE READ isolation level in {connector-name}. +

`none`::: Prevents the connector from acquiring any table locks during the snapshot.
Although this option is allowed with all snapshot modes, it is safe to use _only_ if no schema changes occur while the snapshot is running.
Tables that are defined with the MyISAM engine always acquire a table lock.
As a result, such tables are locked even if you set this option.
This behavior differs from tables that are defined by the InnoDB engine, which acquire row-level locks.

`custom`::: The connector performs a snapshot according to the implementation specified by the xref:{context}-property-snapshot-locking-mode-custom-name[`snapshot.locking.mode.custom.name`] property, which is a custom implementation of the `io.debezium.spi.snapshot.SnapshotLock` interface.



[id="{context}-property-snapshot-locking-mode-custom-name"]
xref:{context}-property-snapshot-locking-mode-custom-name[`snapshot.locking.mode.custom.name`]::
Default value: No default +
When xref:{context}-property-snapshot-locking-mode[`snapshot.locking.mode`] is set to `custom`, use this setting to specify the name of the custom implementation provided in the `name()` method that is defined by the 'io.debezium.spi.snapshot.SnapshotLock' interface.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].



[id="{context}-property-snapshot-max-threads"]
xref:{context}-property-snapshot-max-threads[`snapshot.max.threads`]::
Default value: `1` +
Specifies the number of threads that the connector uses when performing an initial snapshot.
To enable parallel initial snapshots, set the property to a value greater than 1.
In a parallel initial snapshot, the connector processes multiple tables concurrently. +
+
NOTE: Parallel initial snapshots is an incubating feature.



[id="{context}-property-snapshot-mode"]
xref:{context}-property-snapshot-mode[`snapshot.mode`]::
Default value: `initial` +
Specifies the criteria for running a snapshot when the connector starts.
The following settings are available:

`always`::: The connector performs a snapshot every time that it starts.
The snapshot includes the structure and data of the captured tables.
Specify this value to populate topics with a complete representation of the data from the captured tables every time that the connector starts.

`initial` (default)::: The connector runs a snapshot only when no offsets have been recorded for the logical server name, or if it detects that an earlier snapshot failed to complete.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

`initial_only`::: The connector runs a snapshot only when no offsets have been recorded for the logical server name.
After the snapshot completes, the connector stops.
It does not transition to streaming to read change events from the binlog.

`schema_only`::: Deprecated, see `no_data`.

`no_data`::: The connector runs a snapshot that captures only the schema, but not any table data.
Set this option if you do not need the topics to contain a consistent snapshot of the data, but you want to capture any schema changes that were applied after the last connector restart.

`schema_only_recovery`::: Deprecated, see `recovery`.

`recovery`:::  Set this option to restore a database schema history topic that is lost or corrupted.
After a restart, the connector runs a snapshot that rebuilds the topic from the source tables.
You can also set the property to periodically prune a database schema history topic that experiences unexpected growth. +
+
[WARNING]
====
Do not use this mode to perform a snapshot if schema changes were committed to the database after the last connector shutdown.
====
`never`::: When the connector starts, rather than performing a snapshot, it immediately begins to stream event records for subsequent database changes.
This option is under consideration for future deprecation, in favor of the `no_data` option.

`when_needed`::: After the connector starts, it performs a snapshot only if it detects one of the following circumstances:

* It cannot detect any topic offsets.
* A previously recorded offset specifies a binlog position or GTID that is not available on the server.

`configuration_based`::: With this option, you control snapshot behavior through a set of connector properties that have the prefix 'snapshot.mode.configuration.based'.

`custom`::: The connector performs a snapshot according to the implementation specified by the xref:{context}-property-snapshot-mode-custom-name[`snapshot.mode.custom.name`] property, which defines a custom implementation of the `io.debezium.spi.snapshot.Snapshotter` interface.



[id="{context}-property-snapshot-mode-configuration-based-snapshot-data"]
xref:{context}-property-snapshot-mode-configuration-based-snapshot-data[`snapshot.mode.configuration.based.snapshot.data`]::
Default value: `false` +
If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table data when it performs a snapshot.

[id="{context}-property-snapshot-mode-configuration-based-snapshot-on-data-error"]
xref:{context}-property-snapshot-mode-configuration-based-snapshot-on-data-error[`snapshot.mode.configuration.based.snapshot.on.data.error`]::
Default value: `false` +
If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table data in a snapshot in the event that data is no longer available in the transaction log.

[id="{context}-property-snapshot-mode-configuration-based-snapshot-on-schema-error"]
xref:{context}-property-snapshot-mode-configuration-based-snapshot-on-schema-error[`snapshot.mode.configuration.based.snapshot.on.schema.error`]::
Default value: `false` +
If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table schema in a snapshot if the schema history topic is not available.

[id="{context}-property-snapshot-mode-configuration-based-snapshot-schema"]
xref:{context}-property-snapshot-mode-configuration-based-snapshot-schema[`snapshot.mode.configuration.based.snapshot.schema`]::
Default value: `false` +
If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes the table schema when it performs a snapshot.

[id="{context}-property-snapshot-mode-configuration-based-start-stream"]
xref:{context}-property-snapshot-mode-configuration-based-start-stream[`snapshot.mode.configuration.based.start.stream`]::
Default value: `false` +
If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector begins to stream change events after a snapshot completes.

[id="{context}-property-snapshot-mode-custom-name"]
xref:{context}-property-snapshot-mode-custom-name[`snapshot.mode.custom.name`]::
Default value: No default +
If `snapshot.mode` is set to `custom`, use this setting to specify the name of the custom implementation that is provided in the `name()` method that is defined in the 'io.debezium.spi.snapshot.Snapshotter' interface.
After a connector restart, {prodname} calls the specified custom implementation to determine whether to perform a snapshot.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

[id="{context}-property-snapshot-query-mode"]
xref:{context}-property-snapshot-query-mode[`snapshot.query.mode`]::
Default value: `select_all` +
Specifies how the connector queries data while performing a snapshot. +
Set one of the following options:

`select_all` (default)::: The connector uses a `select all` query to retrieve rows from captured tables, optionally adjusting the columns selected based on the column `include` and `exclude` list configurations.

`custom`::: The connector performs a snapshot query according to the implementation specified by the xref:{context}-property-snapshot-snapshot-query-mode-custom-name[`snapshot.query.mode.custom.name`] property, which defines a custom implementation of the `io.debezium.spi.snapshot.SnapshotQuery` interface. +
+
This setting enables you to manage snapshot content in a more flexible manner compared to using the xref:{context}-property-snapshot-select-statement-overrides[`snapshot.select.statement.overrides`] property.



[id="{context}-property-snapshot-snapshot-query-mode-custom-name"]
xref:{context}-property-snapshot-snapshot-query-mode-custom-name[`snapshot.query.mode.custom.name`]::
Default value: No default +
When xref:{context}-property-snapshot-query-mode[`snapshot.query.mode`] is set as `custom`, use this setting to specify the name of the custom implementation provided in the `name()` method that is defined by the 'io.debezium.spi.snapshot.SnapshotQuery' interface.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

[id="{context}-property-snapshot-select-statement-overrides"]
xref:{context}-property-snapshot-select-statement-overrides[`snapshot.select.statement.overrides`]::
Default value: No default +
Specifies the table rows to include in a snapshot.
Use the property if you want a snapshot to include only a subset of the rows in a table.
This property affects snapshots only.
It does not apply to events that the connector reads from the log.
 +
The property contains a comma-separated list of fully-qualified table names in the form `_<databaseName>.<tableName>_`. For example, +
+
`+"snapshot.select.statement.overrides": "inventory.products,customers.orders"+` +
+
For each table in the list, add a further configuration property that specifies the `SELECT` statement for the connector to run on the table when it takes a snapshot.
The specified `SELECT` statement determines the subset of table rows to include in the snapshot.
Use the following format to specify the name of this `SELECT` statement property: +
+
`snapshot.select.statement.overrides._<databaseName>_._<tableName>_`
For example,
`snapshot.select.statement.overrides.customers.orders` +
 +
From a `customers.orders` table that includes the soft-delete column, `delete_flag`, add the following properties if you want a snapshot to include only those records that are not soft-deleted:
+
----
"snapshot.select.statement.overrides": "customer.orders",
"snapshot.select.statement.overrides.customer.orders": "SELECT * FROM [customers].[orders] WHERE delete_flag = 0 ORDER BY id DESC"
----
+
In the resulting snapshot, the connector includes only the records for which `delete_flag = 0`.


[id="{context}-property-snapshot-tables-order-by-row-count"]
xref:{context}-property-snapshot-tables-order-by-row-count[`snapshot.tables.order.by.row.count`]::
Default value: `disabled` +
Specifies the order in which the connector processes tables when it performs an initial snapshot.
Set one of the following options:

`descending`::: The connector snapshots tables in order, based on the number of rows from the highest to the lowest.
`ascending`::: The connector snapshots tables in order, based on the number of rows, from lowest to highest.
`disabled`::: The connector disregards row count when performing an initial snapshot.



[id="{context}-property-source-struct-version"]
xref:{context}-property-source-struct-version[`source.struct.version`]::
Default value: `v2` +
Schema version for the `source` block in {prodname} events.  {prodname} 0.10 introduced a few breaking changes to the structure of the `source` block in order to unify the exposed structure across all the connectors. +
+
By setting this option to `v1`, the structure used in earlier versions can be produced. However, this setting is not recommended and is planned for removal in a future {prodname} version.



[id="{context}-property-streaming-delay-ms"]
xref:{context}-property-streaming-delay-ms[`streaming.delay.ms`]::
Default value: `0` +
Specifies the time, in milliseconds, that the connector delays the start of the streaming process after it completes a snapshot.
Setting a delay interval helps to prevent the connector from restarting snapshots in the event that a failure occurs immediately after the snapshot completes, but before the streaming process begins.
Set a delay value that is higher than the value of the {link-kafka-docs}/#connectconfigs_offset.flush.interval.ms[`offset.flush.interval.ms`] property that is set for the Kafka Connect worker.



[id="{context}-property-table-ignore-builtin"]
xref:{context}-property-table-ignore-builtin[`table.ignore.builtin`]::
Default value: `true` +
A Boolean value that specifies whether built-in system tables should be ignored.
This applies regardless of the table include and exclude lists.
By default, changes that occur to the values in system tables are excluded from capture, and {prodname} does not generate events for system table changes.



[id="{context}-property-topic-cache-size"]
xref:{context}-property-topic-cache-size[`topic.cache.size`]::
Default value: `10000` +
Specifies the number of topic names that can be stored in memory in a bounded concurrent hash map.
The connector uses the cache to help determine the topic name that corresponds to a data collection.



[id="{context}-property-topic-delimiter"]
xref:{context}-property-topic-delimiter[`topic.delimiter`]::
Default value: `.` +
Specifies the delimiter that the connector inserts between components of the topic name.



[id="{context}-property-topic-heartbeat-prefix"]
xref:{context}-property-topic-heartbeat-prefix[`topic.heartbeat.prefix`]::
Default value: `__debezium-heartbeat` +
Specifies the name of the topic to which the connector sends heartbeat messages.
The topic name takes the following format: +
+
_topic.heartbeat.prefix_._topic.prefix_ +
+
For example, if the topic prefix is `fulfillment`, the default topic name is `__debezium-heartbeat.fulfillment`.



[id="{context}-property-topic-naming-strategy"]
xref:{context}-property-topic-naming-strategy[`topic.naming.strategy`]::
Default value: `io.debezium.schema.DefaultTopicNamingStrategy` +
The name of the `TopicNamingStrategy` class that the connector uses.
The specified strategy determines how the connector names the topics that store event records for data changes, schema changes, transactions, heartbeats, and so forth.



[id="{context}-property-topic-transaction"]
xref:{context}-property-topic-transaction[`topic.transaction`]::
Default value: `transaction` +
Specifies the name of the topic to which the connector sends transaction metadata messages.
The topic name takes the following pattern: +
+
_topic.prefix_._topic.transaction_ +
+
For example, if the topic prefix is `fulfillment`, the default topic name is `fulfillment.transaction`.



[id="{context}-property-use-nongraceful-disconnect"]
xref:{context}-property-use-nongraceful-disconnect[`use.nongraceful.disconnect`]::
Default value: false +
A Boolean value that specifies whether the binary log client's keepalive thread sets the `SO_LINGER` socket option to  `0` to immediately close stale TCP connections. +
Set the value to `true` if the connector experiences deadlocks in `SSLSocketImpl.close`. +
For more information, see https://github.com/osheroff/mysql-binlog-connector-java/issues/133[Issue 133] in the https://github.com/osheroff/mysql-binlog-connector-java[mysql-binlog-connector-java] GitHub repository.

:leveloffset: 1

/
[id="debezium-mysql-connector-database-history-configuration-properties"]
==== {prodname} connector database schema history configuration properties

:leveloffset: +1

{prodname} provides a set of `schema.history.internal.*` properties that control how the connector interacts with the schema history topic.

The following table describes the `schema.history.internal` properties for configuring the {prodname} connector.

.Connector database schema history configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-database-history-kafka-topic]]<<{context}-property-database-history-kafka-topic, `+schema.history.internal.kafka.topic+`>>
|No default
|The full name of the Kafka topic where the connector stores the database schema history.

|[[{context}-property-database-history-kafka-bootstrap-servers]]<<{context}-property-database-history-kafka-bootstrap-servers, `+schema.history.internal.kafka.bootstrap.servers+`>>
|No default
|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster. This connection is used for retrieving the database schema history previously stored by the connector, and for writing each DDL statement read from the source database. Each pair should point to the same Kafka cluster used by the Kafka Connect process.

|[[{context}-property-database-history-kafka-recovery-poll-interval-ms]]<<{context}-property-database-history-kafka-recovery-poll-interval-ms, `+schema.history.internal.kafka.recovery.poll.interval.ms+`>>
|`100`
|An integer value that specifies the maximum number of milliseconds the connector should wait during startup/recovery while polling for persisted data. The default is 100ms.

|[[{context}-property-database-history-kafka-query-timeout-ms]]<<{context}-property-database-history-kafka-query-timeout-ms, `+schema.history.internal.kafka.query.timeout.ms+`>>
|`3000`
|An integer value that specifies the maximum number of milliseconds the connector should wait while fetching cluster information using Kafka admin client.

|[[{context}-property-database-history-kafka-create-timeout-ms]]<<{context}-property-database-history-kafka-create-timeout-ms, `+schema.history.internal.kafka.create.timeout.ms+`>>
|`30000`
|An integer value that specifies the maximum number of milliseconds the connector should wait while create kafka history topic using Kafka admin client.

|[[{context}-property-database-history-kafka-recovery-attempts]]<<{context}-property-database-history-kafka-recovery-attempts, `+schema.history.internal.kafka.recovery.attempts+`>>
|`100`
|The maximum number of times that the connector should try to read persisted history data before the connector recovery fails with an error. The maximum amount of time to wait after receiving no data is `recovery.attempts` × `recovery.poll.interval.ms`.

|[[{context}-property-database-history-skip-unparseable-ddl]]<<{context}-property-database-history-skip-unparseable-ddl, `+schema.history.internal.skip.unparseable.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector should ignore malformed or unknown database statements or stop processing so a human can fix the issue.
The safe default is `false`.
Skipping should be used only with care as it can lead to data loss or mangling when the binlog is being processed.

|[[{context}-property-database-history-store-only-captured-tables-ddl]]<<{context}-property-database-history-store-only-captured-tables-ddl, `+schema.history.internal.store.only.captured.tables.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector records schema structures from all tables in a schema or database, or only from tables that are designated for capture. +
Specify one of the following values:

`false` (default):: During a database snapshot, the connector records the schema data for all non-system tables in the database, including tables that are not designated for capture.
It's best to retain the default setting.
If you later decide to capture changes from tables that you did not originally designate for capture, the connector can easily begin to capture data from those tables, because their schema structure is already stored in the schema history topic.
{prodname} requires the schema history of a table so that it can identify the structure that was present at the time that a change event occurred.

`true`:: During a database snapshot, the connector records the table schemas only for the tables from which {prodname} captures change events.
If you change the default value, and you later configure the connector to capture data from other tables in the database, the connector lacks the schema information that it requires to capture change events from the tables. +

|[[{context}-property-database-history-store-only-captured-databases-ddl]]<<{context}-property-database-history-store-only-captured-databases-ddl, `+schema.history.internal.store.only.captured.databases.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector records schema structures from all logical databases in the database instance. +
Specify one of the following values:

`true`:: The connector records schema structures only for tables in the logical database and schema from which {prodname} captures change events.
`false`:: The connector records schema structures for all logical databases. +

NOTE: The default value is `true` for MySQL Connector +

|===

[id="{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients"]
.Pass-through database schema history properties for configuring producer and consumer clients
{empty} +
{prodname} relies on a Kafka producer to write schema changes to database schema history topics.
Similarly, it relies on a Kafka consumer to read from database schema history topics when a connector starts.
You define the configuration for the Kafka producer and consumer clients by assigning values to a set of pass-through configuration properties that begin with the `schema.history.internal.producer.\*` and `schema.history.internal.consumer.*` prefixes.
The pass-through producer and consumer database schema history properties control a range of behaviors, such as how these clients secure connections with the Kafka broker, as shown in the following example:

[source,indent=0]
----
schema.history.internal.producer.security.protocol=SSL
schema.history.internal.producer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
schema.history.internal.producer.ssl.keystore.password=test1234
schema.history.internal.producer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
schema.history.internal.producer.ssl.truststore.password=test1234
schema.history.internal.producer.ssl.key.password=test1234

schema.history.internal.consumer.security.protocol=SSL
schema.history.internal.consumer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
schema.history.internal.consumer.ssl.keystore.password=test1234
schema.history.internal.consumer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
schema.history.internal.consumer.ssl.truststore.password=test1234
schema.history.internal.consumer.ssl.key.password=test1234
----

{prodname} strips the prefix from the property name before it passes the property to the Kafka client.

See the Kafka documentation for more details about link:https://kafka.apache.org/documentation.html#producerconfigs[Kafka producer configuration properties] and link:https://kafka.apache.org/documentation.html#consumerconfigs[Kafka consumer configuration properties].

:leveloffset: 1

[id="debezium-{context}-connector-kafka-signals-configuration-properties"]
==== {prodname} connector Kafka signals configuration properties

:leveloffset: +1

{prodname} provides a set of `signal.*` properties that control how the connector interacts with the Kafka signals topic.

The following table describes the Kafka `signal` properties.

.Kafka signals configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-signal-kafka-topic]]<<{context}-property-signal-kafka-topic, `+signal.kafka.topic+`>>
|<topic.prefix>-signal
|The name of the Kafka topic that the connector monitors for ad hoc signals.
[NOTE]
====
If {link-prefix}:{link-topic-auto-creation}#topic-auto-create-config[automatic topic creation] is disabled, you must manually create the required signaling topic.
A signaling topic is required to preserve signal ordering.
The signaling topic must have a single partition.
====

|[[{context}-property-signal-kafka-groupId]]<<{context}-property-signal-kafka-groupId, `+signal.kafka.groupId+`>>
|kafka-signal
|The name of the group ID  that is used by Kafka consumers.

|[[{context}-property-signal-kafka-bootstrap-servers]]<<{context}-property-signal-kafka-bootstrap-servers, `+signal.kafka.bootstrap.servers+`>>
|No default
|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster.
Each pair references the Kafka cluster that is used by the {prodname} Kafka Connect process.

|[[{context}-property-signal-kafka-poll-timeout-ms]]<<{context}-property-signal-kafka-poll-timeout-ms, `+signal.kafka.poll.timeout.ms+`>>
|`100`
|An integer value that specifies the maximum number of milliseconds that the connector waits when polling signals.

|[[{context}-kafka-consumer-offset-commit-enabled]]<<{context}-kafka-consumer-offset-commit-enabled, `+kafka.consumer.offset.commit.enabled+`>>
|`false`
|Enable the offset commit for the signal topic in order to guarantee At-Least-Once delivery. If disabled, only signals received when the consumer is up&running are processed. Any signals received when the consumer is down are lost.

|===

[id="debezium-{context}-connector-pass-through-signals-kafka-consumer-configuration-properties"]
=== {prodname} connector pass-through signals Kafka consumer client configuration properties

The {prodname} connector provides for pass-through configuration of the signals Kafka consumer.
Pass-through signals properties begin with the prefix `signals.consumer.*`.
For example, the connector passes properties such as `signal.consumer.security.protocol=SSL` to the Kafka consumer.

{prodname} strips the prefixes from the properties before it passes the properties to the Kafka signals consumer.

:leveloffset: 1

[id="debezium-{context}-connector-kafka-notifications-configuration-properties"]
==== {prodname} connector sink notifications configuration properties

:leveloffset: +1

The following table describes the `notification` properties.

.Sink notification configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-notification-sink-topic-name]]<<{context}-property-notification-sink-topic-name, `+notification.sink.topic.name+`>>
|No default
|The name of the topic that receives notifications from {prodname}.
This property is required when you configure the xref:{context}-property-notification-enabled-channels[`notification.enabled.channels`] property to include `sink` as one of the enabled notification channels.
|===

:leveloffset: 1

[id="debezium-{context}-connector-pass-through-database-driver-configuration-properties"]
==== {prodname} connector pass-through database driver configuration properties

:leveloffset: +1

The {prodname} connector provides for pass-through configuration of the database driver.
Pass-through database properties begin with the prefix `driver.*`.
For example, the connector passes properties such as `driver.foobar=false` to the JDBC URL.

As is the case with the xref:{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[pass-through properties for database schema history clients], {prodname} strips the prefixes from the properties before it passes them to the database driver.

:leveloffset: 1

// Type: assembly
// ModuleID: monitoring-debezium-mysql-connector-performance
// Title: Monitoring {prodname} MySQL connector performance
[[mysql-monitoring]]
== Monitoring

:leveloffset: +1

The {prodname} {connector-name} connector provides three types of metrics that are in addition to the built-in support for JMX metrics that Zookeeper, Kafka, and Kafka Connect provide.

* xref:{context}-snapshot-metrics[Snapshot metrics] provide information about connector operation while performing a snapshot.
* xref:{context}-streaming-metrics[Streaming metrics] provide information about connector operation when the connector is reading the binlog.
* xref:{context}-schema-history-metrics[Schema history metrics] provide information about the status of the connector's schema history.

{link-prefix}:{link-debezium-monitoring}#monitoring-debezium[{prodname} monitoring documentation] provides details for how to expose these metrics by using JMX.


:leveloffset: 1

// Type: concept
// ModuleID: monitoring-debezium-mysql-connectors-customized-mbean-names
// Title: Customized names for MySQL connector snapshot and streaming MBean objects
=== Customized MBean names

:leveloffset: +1

{prodname} connectors expose metrics via the MBean name for the connector.
These metrics, which are specific to each connector instance, provide data about the behavior of the connector's snapshot, streaming, and schema history processes.

By default, when you deploy a correctly configured connector, {prodname} generates a unique MBean name for each of the different connector metrics.
To view the metrics for a connector process, you configure your observability stack to monitor its MBean.
But these default MBean names depend on the connector configuration; configuration changes can result in changes to the MBean names.
A change to the MBean name breaks the linkage between the connector instance and the MBean, disrupting monitoring activity.
In this scenario, you must reconfigure the observability stack to use the new MBean name if you want to resume monitoring.

To prevent monitoring disruptions that result from MBean name changes, you can configure custom metrics tags.
You configure custom metrics by adding the `custom.metric.tags` property to the connector configuration.
The property accepts key-value pairs in which each key represents a tag for the MBean object name, and the corresponding value represents the value of that tag.
For example: `k1=v1,k2=v2`.
{prodname} appends the specified tags to the MBean name of the connector.

After you configure the `custom.metric.tags` property for a connector, you can configure the observability stack to retrieve metrics associated with the specified tags.
The observability stack then uses the specified tags, rather than the mutable MBean names to uniquely identify connectors.
Later, if {prodname} redefines how it constructs MBean names, or if the `topic.prefix` in the connector configuration changes, metrics collection is uninterrupted,
because the metrics scrape task uses the specified tag patterns to identify the connector.

A further benefit of using custom tags, is that you can use tags that reflect the architecture of your data pipeline, so that metrics are organized in a way that suits you operational needs.
For example, you might specify tags with values that declare the type of connector activity, the application context, or the data source, for example, `db1-streaming-for-application-abc`.
If you specify multiple key-value pairs, all of the specified pairs are appended to the connector's MBean name.

The following example illustrates how tags modify the default MBean name.

.How custom tags modify the connector MBean name
=======
By default, the {connector-name} connector uses the following MBean name for streaming metrics:
 +
[source,subs="attributes+,quotes"]
----
debezium.{context}:type=connector-metrics,context=streaming,server=_<topic.prefix>_
----

If you set the value of `custom.metric.tags` to `database=salesdb-streaming,table=inventory`, {prodname} generates the following custom MBean name:

[source,subs="attributes+,quotes"]
----
debezium.{context}:type=connector-metrics,context=streaming,server=_<topic.prefix>_,database=salesdb-streaming,table=inventory
----
=======


:leveloffset: 1

// Type: reference
// Title: Monitoring {prodname} during snapshots of MySQL databases
[[mysql-snapshot-metrics]]
=== Snapshot metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=snapshot,server=_<topic.prefix>_`.

:leveloffset: 1

:leveloffset: +1

Snapshot metrics are not exposed unless a snapshot operation is active, or if a snapshot has occurred since the last connector start.

The following table lists the snapshot metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-snaps-metric-lastevent_{context}]]<<connectors-snaps-metric-lastevent_{context}, `LastEvent`>>
|`string`
|The last snapshot event that the connector has read.

|[[connectors-snaps-metric-millisecondssincelastevent_{context}]]<<connectors-snaps-metric-millisecondssincelastevent_{context}, `MilliSecondsSinceLastEvent`>>
|`long`
|The number of milliseconds since the connector has read and processed the most recent event.

|[[connectors-snaps-metric-totalnumberofeventsseen_{context}]]<<connectors-snaps-metric-totalnumberofeventsseen_{context}, `TotalNumberOfEventsSeen`>>
|`long`
|The total number of events that this connector has seen since last started or reset.

|[[connectors-snaps-metric-numberofeventsfiltered_{context}]]<<connectors-snaps-metric-numberofeventsfiltered_{context}, `NumberOfEventsFiltered`>>
|`long`
| The number of events that have been filtered by include/exclude list filtering rules configured on the connector.

|[[connectors-snaps-metric-capturedtables_{context}]]<<connectors-snaps-metric-capturedtables_{context}, `CapturedTables`>>
|`string[]`
|The list of tables that are captured by the connector.

|[[connectors-snaps-metric-queuetotalcapacity_{context}]]<<connectors-snaps-metric-queuetotalcapacity_{context}, `QueueTotalCapacity`>>
|`int`
|The length the queue used to pass events between the snapshotter and the main Kafka Connect loop.

|[[connectors-snaps-metric-queueremainingcapacity_{context}]]<<connectors-snaps-metric-queueremainingcapacity_{context}, `QueueRemainingCapacity`>>
|`int`
|The free capacity of the queue used to pass events between the snapshotter and the main Kafka Connect loop.

|[[connectors-snaps-metric-totaltablecount_{context}]]<<connectors-snaps-metric-totaltablecount_{context}, `TotalTableCount`>>
|`int`
|The total number of tables that are being included in the snapshot.

|[[connectors-snaps-metric-remainingtablecount_{context}]]<<connectors-snaps-metric-remainingtablecount_{context}, `RemainingTableCount`>>
|`int`
|The number of tables that the snapshot has yet to copy.

|[[connectors-snaps-metric-snapshotrunning_{context}]]<<connectors-snaps-metric-snapshotrunning_{context}, `SnapshotRunning`>>
|`boolean`
|Whether the snapshot was started.

|[[connectors-snaps-metric-snapshotpaused_{context}]]<<connectors-snaps-metric-snapshotpaused_{context}, `SnapshotPaused`>>
|`boolean`
|Whether the snapshot was paused.

|[[connectors-snaps-metric-snapshotaborted_{context}]]<<connectors-snaps-metric-snapshotaborted_{context}, `SnapshotAborted`>>
|`boolean`
|Whether the snapshot was aborted.

|[[connectors-snaps-metric-snapshotcompleted_{context}]]<<connectors-snaps-metric-snapshotcompleted_{context}, `SnapshotCompleted`>>
|`boolean`
|Whether the snapshot completed.

|[[connectors-snaps-metric-snapshotdurationinseconds_{context}]]<<connectors-snaps-metric-snapshotdurationinseconds_{context}, `SnapshotDurationInSeconds`>>
|`long`
|The total number of seconds that the snapshot has taken so far, even if not complete. Includes also time when snapshot was paused.

|[[connectors-snaps-metric-snapshotpauseddurationinseconds_{context}]]<<connectors-snaps-metric-snapshotpauseddurationinseconds_{context}, `SnapshotPausedDurationInSeconds`>>
|`long`
|The total number of seconds that the snapshot was paused. If the snapshot was paused several times, the paused time adds up.

|[[connectors-snaps-metric-rowsscanned_{context}]]<<connectors-snaps-metric-rowsscanned_{context}, `RowsScanned`>>
|`Map<String, Long>`
|Map containing the number of rows scanned for each table in the snapshot.
Tables are incrementally added to the Map during processing.
Updates every 10,000 rows scanned and upon completing a table.

|[[connectors-snaps-metric-maxqueuesizeinbytes_{context}]]<<connectors-snaps-metric-maxqueuesizeinbytes_{context}, `MaxQueueSizeInBytes`>>
|`long`
|The maximum buffer of the queue in bytes. This metric is available if xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`] is set to a positive long value.

|[[connectors-snaps-metric-currentqueuesizeinbytes_{context}]]<<connectors-snaps-metric-currentqueuesizeinbytes_{context}, `CurrentQueueSizeInBytes`>>
|`long`
|The current volume, in bytes, of records in the queue.

|===

:leveloffset: 1

:leveloffset: +1

The connector also provides the following additional snapshot metrics when an incremental snapshot is executed:

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-insnap-metric-chunkid_{context}]]<<connectors-insnap-metric-chunkid_{context}, `ChunkId`>>
|`string`
|The identifier of the current snapshot chunk.

|[[connectors-insnap-metric-chunkfrom_{context}]]<<connectors-insnap-metric-chunkfrom_{context}, `ChunkFrom`>>
|`string`
|The lower bound of the primary key set defining the current chunk.

|[[connectors-insnap-metric-chunkto_{context}]]<<connectors-insnap-metric-chunkto_{context}, `ChunkTo`>>
|`string`
|The upper bound of the primary key set defining the current chunk.

|[[connectors-insnap-metric-tablefrom_{context}]]<<connectors-insnap-metric-tablefrom_{context}, `TableFrom`>>
|`string`
|The lower bound of the primary key set of the currently snapshotted table.

|[[connectors-insnap-metric-tableto_{context}]]<<connectors-insnap-metric-tableto_{context}, `TableTo`>>
|`string`
|The upper bound of the primary key set of the currently snapshotted table.

|===

The {prodname} {connector-name} connector also provides the `HoldingGlobalLock` custom snapshot metric.
This metric is set to a Boolean value that indicates whether the connector currently holds a global or table write lock.

:leveloffset: 1

// Type: reference
// Title: Monitoring {prodname} MySQL connector record streaming
[[mysql-streaming-metrics]]
=== Streaming metrics

:leveloffset: +1

The {prodname} {connector-name} connector provides three types of metrics that are in addition to the built-in support for JMX metrics that Zookeeper, Kafka, and Kafka Connect provide.

* xref:{context}-snapshot-metrics[Snapshot metrics] provide information about connector operation while performing a snapshot.
* xref:{context}-streaming-metrics[Streaming metrics] provide information about connector operation when the connector is reading the binlog.
* xref:{context}-schema-history-metrics[Schema history metrics] provide information about the status of the connector's schema history.

{link-prefix}:{link-debezium-monitoring}#monitoring-debezium[{prodname} monitoring documentation] provides details for how to expose these metrics by using JMX.


:leveloffset: 1

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=streaming,server=_<topic.prefix>_`.

:leveloffset: 1

:leveloffset: +1

The following table lists the streaming metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-strm-metric-lastevent_{context}]]<<connectors-strm-metric-lastevent_{context}, `LastEvent`>>
|`string`
|The last streaming event that the connector has read.

|[[connectors-strm-metric-millisecondssincelastevent_{context}]]<<connectors-strm-metric-millisecondssincelastevent_{context}, `MilliSecondsSinceLastEvent`>>
|`long`
|The number of milliseconds since the connector has read and processed the most recent event.

|[[connectors-strm-metric-totalnumberofeventsseen_{context}]]<<connectors-strm-metric-totalnumberofeventsseen_{context}, `TotalNumberOfEventsSeen`>>
|`long`
|The total number of data change events reported by the source database since the last connector start, or since a metrics reset.
Represents the data change workload for {prodname} to process.

|[[connectors-strm-metric-totalnumberofcreateeventsseen_{context}]]<<connectors-strm-metric-totalnumberofcreateeventsseen_{context}, `TotalNumberOfCreateEventsSeen`>>
|`long`
|The total number of create events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-totalnumberofupdateeventsseen_{context}]]<<connectors-strm-metric-totalnumberofupdateeventsseen_{context}, `TotalNumberOfUpdateEventsSeen`>>
|`long`
|The total number of update events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-totalnumberofdeleteeventsseen_{context}]]<<connectors-strm-metric-totalnumberofdeleteeventsseen_{context}, `TotalNumberOfDeleteEventsSeen`>>
|`long`
|The total number of delete events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-numberofeventsfiltered_{context}]]<<connectors-strm-metric-numberofeventsfiltered_{context}, `NumberOfEventsFiltered`>>
|`long`
|The number of events that have been filtered by include/exclude list filtering rules configured on the connector.

|[[connectors-strm-metric-capturedtables_{context}]]<<connectors-strm-metric-capturedtables_{context}, `CapturedTables`>>
|`string[]`
|The list of tables that are captured by the connector.

|[[connectors-strm-metric-queuetotalcapacity_{context}]]<<connectors-strm-metric-queuetotalcapacity_{context}, `QueueTotalCapacity`>>
|`int`
|The length the queue used to pass events between the streamer and the main Kafka Connect loop.

|[[connectors-strm-metric-queueremainingcapacity_{context}]]<<connectors-strm-metric-queueremainingcapacity_{context}, `QueueRemainingCapacity`>>
|`int`
|The free capacity of the queue used to pass events between the streamer and the main Kafka Connect loop.

|[[connectors-strm-metric-connected_{context}]]<<connectors-strm-metric-connected_{context}, `Connected`>>
|`boolean`
|Flag that denotes whether the connector is currently connected to the database server.

|[[connectors-strm-metric-millisecondsbehindsource_{context}]]<<connectors-strm-metric-millisecondsbehindsource_{context}, `MilliSecondsBehindSource`>>
|`long`
|The number of milliseconds between the last change event's timestamp and the connector processing it.
The values will incorporate any differences between the clocks on the machines where the database server and the connector are running.

|[[connectors-strm-metric-numberofcommittedtransactions_{context}]]<<connectors-strm-metric-numberofcommittedtransactions_{context}, `NumberOfCommittedTransactions`>>
|`long`
|The number of processed transactions that were committed.

|[[connectors-strm-metric-sourceeventposition_{context}]]<<connectors-strm-metric-sourceeventposition_{context}, `SourceEventPosition`>>
|`Map<String, String>`
|The coordinates of the last received event.

|[[connectors-strm-metric-lasttransactionid_{context}]]<<connectors-strm-metric-lasttransactionid_{context}, `LastTransactionId`>>
|`string`
|Transaction identifier of the last processed transaction.

|[[connectors-strm-metric-maxqueuesizeinbytes_{context}]]<<connectors-strm-metric-maxqueuesizeinbytes_{context}, `MaxQueueSizeInBytes`>>
|`long`
|The maximum buffer of the queue in bytes. This metric is available if xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`] is set to a positive long value.

|[[connectors-strm-metric-currentqueuesizeinbytes_{context}]]<<connectors-strm-metric-currentqueuesizeinbytes_{context}, `CurrentQueueSizeInBytes`>>
|`long`
|The current volume, in bytes, of records in the queue.

|===

The {prodname} {connector-name} connector also provides the following additional streaming metrics:

.Descriptions of additional {connector-name} streaming metrics
[cols="3,2,5",options="header"]
|===
|Attribute |Type |Description

|[[binlog-filename]]<<binlog-filename,`+BinlogFilename+`>>
|`string`
|The name of the binlog file that the connector has most recently read.

|[[binlog-position]]<<binlog-position,`+BinlogPosition+`>>
|`long`
|The most recent position (in bytes) within the binlog that the connector has read.

|[[is-gtid-mode-enabled]]<<is-gtid-mode-enabled,`+IsGtidModeEnabled+`>>
|`boolean`
|Flag that denotes whether the connector is currently tracking GTIDs from {connector-name} server.

|[[gtid-set]]<<gtid-set,`+GtidSet+`>>
|`string`
|The string representation of the most recent GTID set processed by the connector when reading the binlog.

|[[number-of-skipped-events]]<<number-of-skipped-events,`+NumberOfSkippedEvents+`>>
|`long`
|The number of events that have been skipped by the {connector-name} connector. Typically events are skipped due to a malformed or unparseable event from {connector-name}'s binlog.

|[[number-of-disconnects]]<<number-of-disconnects,`+NumberOfDisconnects+`>>
|`long`
|The number of disconnects by the {connector-name} connector.

|[[number-of-rolled-back-transactions]]<<number-of-rolled-back-transactions,`+NumberOfRolledBackTransactions+`>>
|`long`
|The number of processed transactions that were rolled back and not streamed.

|[[number-of-not-well-formed-transactions]]<<number-of-not-well-formed-transactions,`+NumberOfNotWellFormedTransactions+`>>
|`long`
|The number of transactions that have not conformed to the expected protocol of `BEGIN` + `COMMIT`/`ROLLBACK`. This value should be `0` under normal conditions.

|[[number-of-large-transactions]]<<number-of-large-transactions,`+NumberOfLargeTransactions+`>>
|`long`
|The number of transactions that have not fit into the look-ahead buffer. For optimal performance, this value should be significantly smaller than `NumberOfCommittedTransactions` and `NumberOfRolledBackTransactions`.

|===

:leveloffset: 1

// Type: reference
// Title: Monitoring {prodname} MySQL connector schema history
[[mysql-schema-history-metrics]]
=== Schema history metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=schema-history,server=_<topic.prefix>_`.

The following table lists the schema history metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-shist-metric-status_{context}]]<<connectors-shist-metric-status_{context}, `Status`>>
|`string`
|One of `STOPPED`, `RECOVERING` (recovering history from the storage), `RUNNING` describing the state of the database schema history.

|[[connectors-shist-metric-recoverystarttime_{context}]]<<connectors-shist-metric-recoverystarttime_{context}, `RecoveryStartTime`>>
|`long`
|The time in epoch seconds at what recovery has started.

|[[connectors-shist-metric-changesrecovered_{context}]]<<connectors-shist-metric-changesrecovered_{context}, `ChangesRecovered`>>
|`long`
|The number of changes that were read during recovery phase.

|[[connectors-shist-metric-changesapplied_{context}]]<<connectors-shist-metric-changesapplied_{context}, `ChangesApplied`>>
|`long`
|the total number of schema changes applied during recovery and runtime.

|[[connectors-shist-metric-millisecondssincelastrecoveredchange_{context}]]<<connectors-shist-metric-millisecondssincelastrecoveredchange_{context}, `MilliSecondsSinceLast{zwsp}RecoveredChange`>>
|`long`
|The number of milliseconds that elapsed since the last change was recovered from the history store.

|[[connectors-shist-metric-millisecondssincelastappliedchange_{context}]]<<connectors-shist-metric-millisecondssincelastappliedchange_{context}, `MilliSecondsSinceLast{zwsp}AppliedChange`>>
|`long`
|The number of milliseconds that elapsed since the last change was applied.

|[[connectors-shist-metric-lastrecoveredchange_{context}]]<<connectors-shist-metric-lastrecoveredchange_{context}, `LastRecoveredChange`>>
|`string`
|The string representation of the last change recovered from the history store.

|[[connectors-shist-metric-lastappliedchange_{context}]]<<connectors-shist-metric-lastappliedchange_{context}, `LastAppliedChange`>>
|`string`
|The string representation of the last applied change.

|===

:leveloffset: 1

// Type: concept
// Title: How {prodname} MySQL connectors handle faults and problems
[[mysql-when-things-go-wrong]]
== Behavior when things go wrong

:leveloffset: +1


{prodname} is a distributed system that captures all changes in multiple upstream databases; it never misses or loses an event.
When the system is operating normally or being managed carefully then {prodname} provides _exactly once_ delivery of every change event record.

If a fault does occur, the system does not lose any events.
However, while {prodname} is recovering from a fault, it might repeat some change events.
In these abnormal situations, {prodname}, like Kafka, provides _at least once_ delivery of change events.

The rest of this section describes how {prodname} handles various kinds of faults and problems.


[id="debezium-{context}-connector-configuration-and-startup-errors"]
Configuration and startup errors::

In the following situations, the connector fails when trying to start, reports an error or exception in the log, and stops running:

* The connector's configuration is invalid.
* The connector cannot successfully connect to the {connector-name} server by using the specified connection parameters.
* The connector is attempting to restart at a position in the binlog for which {connector-name} no longer has the history available.

In these cases, the error message has details about the problem and possibly a suggested workaround.
After you correct the configuration or address the {connector-name} problem, restart the connector.

[id="{context}-becomes-unavailable-while-debezium-is-running"]
{connector-name} becomes unavailable::

If your {connector-name} server becomes unavailable, the {prodname} {connector-name} connector fails with an error and the connector stops.
When the server is available again, restart the connector.

However, if you are connecting to a highly available {connector-name} cluster, you can restart the connector immediately.
It will connect to a different {connector-name} server in the cluster, find the location in the server's binlog that represents the last transaction, and begin reading the new server's binlog from that specific location.

[id="debezium-{context}-kafka-connect-process-stops-gracefully"]
Kafka Connect stops gracefully::

When Kafka Connect stops gracefully, there is a short delay while the {prodname} {connector-name} connector tasks are stopped and restarted on new Kafka Connect processes.

[id="debezium-{context}-kafka-connect-process-crashes"]
Kafka Connect process crashes::

If Kafka Connect crashes, the process stops and any {prodname} {connector-name} connector tasks terminate without their most recently-processed offsets being recorded.
In distributed mode, Kafka Connect restarts the connector tasks on other processes.
However, the {connector-name} connector resumes from the last offset recorded by the earlier processes.
As a result, the replacement tasks might regenerate some events that were processed before the crash, creating duplicate events.

Each change event message includes source-specific information that you can use to identify duplicate events, for example:

* Event origin
* {connector-name} server's event time
* The binlog file name and position
* GTIDs
(if used)

[id="debezium-{context}-kafka-process-becomes-unavailable"]
Kafka becomes unavailable::

The Kafka Connect framework records {prodname} change events in Kafka by using the Kafka producer API.
If the Kafka brokers become unavailable, the {prodname} {connector-name} connector pauses until the connection is reestablished, and the connector then resumes where it left off.

[id="{context}-purges-binlog-files-used-by-debezium"]
{connector-name} purges binlog files::

If the {prodname} {connector-name} connector stops for too long, the {connector-name} server purges older binlog files and the connector's last position may be lost.
When the connector is restarted, the {connector-name} server no longer has the starting point and the connector performs another initial snapshot.
If the snapshot is disabled, the connector fails with an error.

See xref:{context}-snapshots[snapshots] for details about how {connector-name} connectors perform initial snapshots.

:leveloffset: 1

:leveloffset!:
:leveloffset: +1

// Category: debezium-using
// Type: assembly
[id="debezium-connector-for-mariadb"]
= {prodname} connector for MariaDB

:context: mariadb
:data-collection: table
:database-port: 3306
:mbean-name: {context}
:connector-file: {context}
:connector-class: MariaDb
:connector-name: MariaDB
:include-list-example: inventory.*
:toc:
:toc-placement: macro
:linkattrs:
:icons: font
:source-highlighter: highlight.js
:MARIADB:

toc::[]

:leveloffset: +1

{connector-name} has a binary log (binlog) that records all operations in the order in which they are committed to the database.
This includes changes to table schemas as well as changes to the data in tables.
{connector-name} uses the binlog for replication and recovery.

The {prodname} {connector-name} connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics.
Client applications read those Kafka topics.

Because {connector-name} is typically set up to purge binlogs after a specified period of time, the {connector-name} connector performs an initial _consistent snapshot_ of each of your databases.
The {connector-name} connector reads the binlog from the point at which the snapshot was made.

For information about the {connector-name} Database versions that are compatible with this connector, see the link:https://debezium.io/releases/[{prodname} release overview].


:leveloffset: 1

// Type: assembly
// ModuleID: how-debezium-mariadb-connectors-work
// Title: How {prodname} MariaDB connectors work
[[how-the-mariadb-connector-works]]
== How the connector works

:leveloffset: +1


An overview of the {connector-name} topologies that the connector supports is useful for planning your application.
To optimally configure and run a {prodname} {connector-name} connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names.


:leveloffset: 1

// Type: concept
// ModuleID: mariadb-topologies-supported-by-debezium-connectors
// Title: MariaDB topologies supported by {prodname} connectors
[id="supported-mariadb-topologies"]
=== Supported MariaDB topologies

:leveloffset: +1

The {prodname} {connector-name} connector supports the following {connector-name} topologies:

Standalone::
When a single {connector-name} server is used, the server must have the binlog enabled so the {prodname} {connector-name} connector can monitor the server.
This is often acceptable, since the binary log can also be used as an incremental
link:https://mariadb.com/kb/en/backup-and-restore-overview/
link:https://dev.mysql.com/doc/refman/{mysql-version}/en/backup-methods.html
[backup].
In this case, the {connector-name} connector always connects to and follows this standalone {connector-name} server instance.

Primary and replica::
The {prodname} {connector-name} connector can follow one of the primary servers, or one of the replicas (_if that replica has its binlog enabled_), but the connector detects changes only in the cluster that is visible to that server.
Generally, this is not a problem except for the multi-primary topologies.
+
The connector records its position in the server’s binlog, which is different on each server in the cluster.
Therefore, the connector must follow just one {connector-name} server instance.
If that server fails, that server must be restarted or recovered before the connector can continue.

High available clusters::
A variety of
link:https://mariadb.com/docs/server/architecture/use-cases/high-availability/
https://dev.mysql.com/doc/mysql-ha-scalability/en/
[high availability] solutions exist for {connector-name}, and they make it significantly easier to tolerate and almost immediately recover from problems and failures.
Because
most
HA {connector-name} clusters use GTIDs, replicas are able to track all of the changes that occur on any primary server.



Multi-primary::
link:https://dev.mysql.com/doc/refman/{mysql-version}/en/mysql-cluster-replication-multi-source.html[Network Database (NDB) cluster replication]
link:https://mariadb.com/kb/en/galera-cluster/[Galera cluster replication]
uses one or more {connector-name} replica nodes that each replicate from multiple primary servers.
Cluster replication provides a powerful way to aggregate the replication of multiple {connector-name} clusters.
This topology requires the use of GTIDs.
+
A {prodname} {connector-name} connector can use these multi-primary {connector-name} replicas as sources, and can fail over to different multi-primary {connector-name} replicas as long as the new replica is caught up to the old replica.
That is, the new replica has all transactions that were seen on the first replica.
This works even if the connector is using only a subset of databases and/or tables, because the connector can be configured to include or exclude specific GTID sources when attempting to reconnect to a new multi-primary {connector-name} replica and find the correct position in the binlog.

Hosted::
The {prodname} {connector-name} connector can use hosted database options such as Amazon RDS and Amazon Aurora.
+
Because these hosted options do not permit the use of global read locks, the connector uses table-level locks when it creates a consistent snapshot.


:leveloffset: 1

// Type: concept
// Title: How {prodname} MariaDB connectors handle database schema changes
[[mariadb-schema-history-topic]]
=== Schema history topic

:leveloffset: +1

When a database client queries a database, the client uses the database’s current schema.
However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded.
Also, a connector cannot necessarily apply the current schema to every event.
If an event is relatively old, it's possible that it was recorded before the current schema was applied.

To ensure correct processing of events that occur after a schema change, {connector-name} includes in the transaction log not only the row-level changes that affect the data, but also the DDL statements that are applied to the database.
As the connector encounters these DDL statements in the binlog, it parses them and updates an in-memory representation of each table’s schema.
The connector uses this schema representation to identify the structure of the tables at the time of each insert, update, or delete operation and to produce the appropriate change event.
In a separate database schema history Kafka topic, the connector records all DDL statements along with the position in the binlog where each DDL statement appeared.

When the connector restarts after either a crash or a graceful stop, it starts reading the binlog from a specific position, that is, from a specific point in time.
The connector rebuilds the table structures that existed at this point in time by reading the database schema history Kafka topic and parsing all DDL statements up to the point in the binlog where the connector is starting.

This database schema history topic is for internal connector use only.
Optionally, the connector can also xref:{context}-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].

When the {connector-name} connector captures changes in a table to which a schema change tool such as `gh-ost` or `pt-online-schema-change` is applied, there are helper tables created during the migration process.
You must configure the connector to capture changes that occur in these helper tables.
If consumers do not need the records the connector generates for helper tables, configure a {link-prefix}:{link-filtering}#message-filtering[single message transform (SMT)] to remove these records from the messages that the connector emits.

.Additional resources

* xref:{context}-topic-names[Default names for topics] that receive {prodname} event records.

:leveloffset: 1

// Type: concept
// Title: How {prodname} MariaDB connectors expose database schema changes
[id="mariadb-schema-change-topic"]
=== Schema change topic

:leveloffset: +1

You can configure a {prodname} {connector-name} connector to produce schema change events that describe schema changes that are applied to tables in the database.
The connector writes schema change events to a Kafka topic named `_<topicPrefix>_`, where `_topicPrefix_` is the namespace specified in the xref:{context}-property-topic-prefix[`topic.prefix`] connector configuration property.
Messages that the connector sends to the schema change topic contain a payload, and, optionally, also contain the schema of the change event message.

The schema for the schema change event has the following elements:

`name`:: The name of the schema change event message.
`type`:: The type of the change event message.
`version`:: The version of the schema. The version is an integer that is incremented each time the schema is changed.
`fields`:: The fields that are included in the change event message.

.Example: Schema of the {connector-name} connector schema change topic
The following example shows a typical schema in JSON format.

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {
    "type": "struct",
    "fields": [
      {
        "type": "string",
        "optional": false,
        "field": "databaseName"
      }
    ],
    "optional": false,
    "name": "io.debezium.connector.{context}.SchemaChangeKey",
    "version": 1
  },
  "payload": {
    "databaseName": "inventory"
  }
}
----

The payload of a schema change event message includes the following elements:

`ddl`:: Provides the SQL `CREATE`, `ALTER`, or `DROP` statement that results in the schema change.
`databaseName`:: The name of the database to which the DDL statements are applied.
The value of `databaseName` serves as the message key.
`pos`:: The position in the binlog where the statements appear.
`tableChanges`::  A structured representation of the entire table schema after the schema change.
The `tableChanges` field contains an array that includes entries for each column of the table.
Because the structured representation presents data in JSON or Avro format, consumers can easily read messages without first processing them through a DDL parser.

[IMPORTANT]
====
For a table that is in capture mode, the connector not only stores the history of schema changes in the schema change topic, but also in an internal database schema history topic.
The internal database schema history topic is for connector use only, and it is not intended for direct use by consuming applications.
Ensure that applications that require notifications about schema changes consume that information only from the schema change topic.
====

[IMPORTANT]
====
Never partition the database schema history topic.
For the database schema history topic to function correctly, it must maintain a consistent, global order of the event records that the connector emits to it.

To ensure that the topic is not split among partitions, set the partition count for the topic by using one of the following methods:

* If you create the database schema history topic manually, specify a partition count of `1`.
* If you use the Apache Kafka broker to create the database schema history topic automatically, the topic is created, set the value of the link:{link-kafka-docs}/#brokerconfigs_num.partitions[Kafka `num.partitions`] configuration option to `1`.
====

[WARNING]
====
The format of the messages that a connector emits to its schema change topic is in an incubating state and is subject to change without notice.
====

.Example: Message emitted to the {connector-name} connector schema change topic
The following example shows a typical schema change message in JSON format.
The message contains a logical representation of the table schema.

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": { },
  "payload": {
      "source": {  // <1>
        "version": "{debezium-version}",
        "connector": "{context}",
        "name": "{context}",
        "ts_ms": 1651535750218, // <2>
        "ts_us": 1651535750218000, // <2>
        "ts_ns": 1651535750218000000, // <2>
        "snapshot": "false",
        "db": "inventory",
        "sequence": null,
        "table": "customers",
        "server_id": 223344,
        "gtid": null,
        "file": "{context}-bin.000003",
        "pos": 570,
        "row": 0,
        "thread": null,
        "query": null
      },
      "databaseName": "inventory", <3>
      "schemaName": null,
      "ddl": "ALTER TABLE customers ADD middle_name varchar(255) AFTER first_name", <4>
      "tableChanges": [  <5>
        {
          "type": "ALTER", <6>
          "id": "\"inventory\".\"customers\"", <7>
          "table": {    <8>
            "defaultCharsetName": "utf8mb4",
            "primaryKeyColumnNames": [  <9>
              "id"
            ],
            "columns": [  <10>
              {
                "name": "id",
                "jdbcType": 4,
                "nativeType": null,
                "typeName": "INT",
                "typeExpression": "INT",
                "charsetName": null,
                "length": null,
                "scale": null,
                "position": 1,
                "optional": false,
                "autoIncremented": true,
                "generated": true
              },
              {
                "name": "first_name",
                "jdbcType": 12,
                "nativeType": null,
                "typeName": "VARCHAR",
                "typeExpression": "VARCHAR",
                "charsetName": "utf8mb4",
                "length": 255,
                "scale": null,
                "position": 2,
                "optional": false,
                "autoIncremented": false,
                "generated": false
              },
              {
                "name": "middle_name",
                "jdbcType": 12,
                "nativeType": null,
                "typeName": "VARCHAR",
                "typeExpression": "VARCHAR",
                "charsetName": "utf8mb4",
                "length": 255,
                "scale": null,
                "position": 3,
                "optional": true,
                "autoIncremented": false,
                "generated": false
              },
              {
                "name": "last_name",
                "jdbcType": 12,
                "nativeType": null,
                "typeName": "VARCHAR",
                "typeExpression": "VARCHAR",
                "charsetName": "utf8mb4",
                "length": 255,
                "scale": null,
                "position": 4,
                "optional": false,
                "autoIncremented": false,
                "generated": false
              },
              {
                "name": "email",
                "jdbcType": 12,
                "nativeType": null,
                "typeName": "VARCHAR",
                "typeExpression": "VARCHAR",
                "charsetName": "utf8mb4",
                "length": 255,
                "scale": null,
                "position": 5,
                "optional": false,
                "autoIncremented": false,
                "generated": false
            }
          ],
          "attributes": [ <11>
            {
              "customAttribute": "attributeValue"
            }
          ]
        }
      }
    ]
  }
}

----

.Descriptions of fields in messages emitted to the schema change topic
[cols="1,4,5",options="header"]
|===
|Item |Field name |Description

|1
|`source`
|The `source` field is structured exactly as standard data change events that the connector writes to table-specific topics.
This field is useful to correlate events on different topics.

|2
|`ts_ms`, `ts_us`, `ts_ns`
|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task. +
 +
In the source object, ts_ms indicates the time that the change was made in the database. By comparing the value for payload.source.ts_ms with the value for payload.ts_ms, you can determine the lag between the source database update and Debezium.

|3
|`databaseName` +
`schemaName`
|Identifies the database and the schema that contains the change.
The value of the `databaseName` field is used as the message key for the record.

|4
|`ddl`
|This field contains the DDL that is responsible for the schema change.
The `ddl` field can contain multiple DDL statements.
Each statement applies to the database in the `databaseName` field.
Multiple DDL statements appear in the order in which they were applied to the database. +
 +
Clients can submit multiple DDL statements that apply to multiple databases.
If {connector-name} applies them atomically, the connector takes the DDL statements in order, groups them by database, and creates a schema change event for each group.
If {connector-name} applies them individually, the connector creates a separate schema change event for each statement.

|5
|`tableChanges`
|An array of one or more items that contain the schema changes generated by a DDL command.

|6
|`type`
a|Describes the kind of change. The value is one of the following:

`CREATE`:: Table created.
`ALTER`:: Table modified.
`DROP`:: Table deleted.

|7
|`id`
|Full identifier of the table that was created, altered, or dropped.
In the case of a table rename, this identifier is a concatenation of `_<old>_,_<new>_` table names.

|8
|`table`
|Represents table metadata after the applied change.

|9
|`primaryKeyColumnNames`
|List of columns that compose the table's primary key.

|10
|`columns`
|Metadata for each column in the changed table.

|11
|`attributes`
|Custom attribute metadata for each table change.

|===

For more information, see xref:{context}-schema-history-topic[schema history topic].

:leveloffset: 1


// Type: concept
// Title: How {prodname} MariaDB connectors perform database snapshots
[[mariadb-snapshots]]
=== Snapshots

:leveloffset: +1

When a {prodname} {connector-name} connector is first started, it performs an initial _consistent snapshot_ of your database.
This snapshot enables the connector to establish a baseline for the current state of the database.

{prodname} can use different modes when it runs a snapshot.
The snapshot mode is determined by the xref:{context}-property-snapshot-mode[`snapshot.mode`] configuration property.
The default value of the property is `initial`.
You can customize the way that the connector creates snapshots by changing the value of the `snapshot.mode` property.


The connector completes a series of tasks when it performs the snapshot.
The exact steps vary with the snapshot mode and with the table locking policy that is in effect for the database.
The {prodname} {connector-name} connector completes different steps when it performs an initial snapshot that uses a xref:{context}-initial-snapshot-workflow-with-global-read-lock[global read lock] or xref:{context}-initial-snapshot-workflow-with-table-level-locks[table-level locks].

:leveloffset: 1

// Type: concept
[id="mariadb-initial-snapshot-workflow-with-global-read-lock"]
==== Initial snapshots that use a global read lock

:leveloffset: +1

You can customize the way that the connector creates snapshots by changing the value of the `snapshot.mode` property.
If you configure a different snapshot mode, the connector completes the snapshot by using a modified version of this workflow.
For information about the snapshot process in environments that do not permit global read locks, see the xref:{context}-initial-snapshot-workflow-with-table-level-locks[snapshot workflow for table-level locks].

.Default workflow that the {prodname} {connector-name} connector uses to perform an initial snapshot with a global read lock
The following table shows the steps in the workflow that {prodname} follows to create a snapshot with a global read lock.

[cols="1a,9a",options="header",subs="+attributes"]
|===
|Step |Action

|1
a|Establish a connection to the database.

|2
|Determine the tables to be captured.
By default, the connector captures the data for all non-system tables.
After the snapshot completes, the connector continues to stream data for the specified tables.
If you want the connector to capture data only from specific tables you can direct the connector to capture the data for only a subset of tables or table elements by setting properties such as xref:{context}-property-table-include-list[`table.include.list`] or xref:{context}-property-table-exclude-list[`table.exclude.list`].

|3
|Obtain a global read lock on the tables to be captured to block _writes_ by other database clients. +
 +
The snapshot itself does not prevent other clients from applying DDL that might interfere with the connector's attempt to read the binlog position and table schemas.
The connector retains the global read lock while it reads the binlog position, and releases the lock as described in a later step.

|4
a|Start a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_. +
a|Start a transaction with link:https://mariadb.com/kb/en/set-transaction/#repeatable-read[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_. +
 +
[NOTE]
====
The use of these isolation semantics can slow the progress of the snapshot.
If the snapshot takes too long to complete, consider using a different isolation configuration, or skip the initial snapshot and run an xref:debezium-{context}-incremental-snapshots[incremental snapshot] instead.
====

|5
|Read the current binlog position.

|6
a|Capture the structure of all tables in the database, or all tables that are designated for capture.
The connector persists schema information in its internal database schema history topic, including all necessary `DROP...` and `CREATE...` DDL statements. +
The schema history provides information about the structure that is in effect when a change event occurs.
 +
[NOTE]
====
By default, the connector captures the schema of every table in the database, including tables that are not configured for capture.
If tables are not configured for capture, the initial snapshot captures only their structure; it does not capture any table data. +
 +
For more information about why snapshots persist schema information for tables that you did not include in the initial snapshot, see xref:understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables[Understanding why initial snapshots capture the schema for all tables].
====

|7
|Release the global read lock obtained in Step 3.
Other database clients can now write to the database.

|8
a|At the binlog position that the connector read in Step 5, the connector begins to scan the tables that are designated for capture.
During the scan, the connector completes the following tasks:

. Confirms that the table was created before the snapshot began.
If the table was created after the snapshot began, the connector skips the table.
After the snapshot is complete, and the connector transitions to streaming, it emits change events for any tables that were created after the snapshot began.
. Produces a `read` event for each row that is captured from a table.
All `read` events contain the same binlog position, which is the position that was obtained in step 5.
. Emits each `read` event to the Kafka topic for the source table.
. Releases data table locks, if applicable.

|9
|Commit the transaction.

|10
|Record the successful completion of the snapshot in the connector offsets.

|===

The resulting initial snapshot captures the current state of each row in the captured tables.
From this baseline state, the connector captures subsequent changes as they occur.

After the snapshot process begins, if the process is interrupted due to connector failure, rebalancing, or other reasons, the process restarts after the connector restarts.

After the connector completes the initial snapshot, it continues streaming from the position that it read in Step 5 so that it does not miss any updates.

If the connector stops again for any reason, after it restarts, it resumes streaming changes from where it previously left off.

After the connector restarts, if the logs have been pruned, the connector's position in the logs might no longer available.
The connector then fails, and returns an error that indicates that a new snapshot is required.
To configure the connector to automatically initiate a snapshot in this situation, set the value of the xref:{context}-property-snapshot-mode[`snapshot.mode`] property to `when_needed`.
For more tips on troubleshooting the {prodname} {connector-name} connector, see xref:{context}-when-things-go-wrong[behavior when things go wrong].

:leveloffset: 1

// Type: concept
[id="mariadb-initial-snapshot-workflow-with-table-level-locks"]
==== Initial snapshots that use table-level locks

:leveloffset: +1

In some database environments, administrators do not permit global read locks.
If the {prodname} {connector-name} connector detects that global read locks are not permitted, the connector uses table-level locks when it performs snapshots.
For the connector to perform a snapshot that uses table-level locks, the database account that the {prodname} connector uses to connect to {connector-name} must have `LOCK TABLES` privileges.

.Default workflow that the {prodname} {connector-name} connector uses to perform an initial snapshot with table-level locks
The following table shows the steps in the workflow that {prodname} follows to create a snapshot with table-level read locks.
For information about the snapshot process in environments that do not permit global read locks, see the xref:{context}-initial-snapshot-workflow-with-global-read-lock[snapshot workflow for global read locks].

[cols="1,9",options="header",subs="+attributes"]
|===
|Step |Action

|1
|Establish a connection to the database.

|2
|Determine the tables to be captured.
By default, the connector captures all non-system tables.
To have the connector capture a subset of tables or table elements, you can set a number of `include` and `exclude` properties to filter the data, for example, xref:{context}-property-table-include-list[`table.include.list`] or xref:{context}-property-table-exclude-list[`table.exclude.list`].

|3
|Obtain table-level locks.

|4
a|Start a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.
a|Start a transaction with link:https://mariadb.com/kb/en/set-transaction/#repeatable-read[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.

|5
a|Read the current binlog position.

|6
a|Read the schema of the databases and tables for which the connector is configured to capture changes.
The connector persists schema information in its internal database schema history topic, including all necessary `DROP...` and `CREATE...` DDL statements. +
The schema history provides information about the structure that is in effect when a change event occurs.
 +
[NOTE]
====
By default, the connector captures the schema of every table in the database, including tables that are not configured for capture.
If tables are not configured for capture, the initial snapshot captures only their structure; it does not capture any table data.

For more information about why snapshots persist schema information for tables that you did not include in the initial snapshot, see xref:understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables[Understanding why initial snapshots capture the schema for all tables].
====

|7
a|At the binlog position that the connector read in Step 5, the connector begins to scan the tables that are designated for capture.
During the scan, the connector completes the following tasks:

. Confirms that the table was created before the snapshot began.
If the table was created after the snapshot began, the connector skips the table.
After the snapshot is complete, and the connector transitions to streaming, it emits change events for any tables that were created after the snapshot began.
. Produces a `read` event for each row that is captured from a table.
All `read` events contain the same binlog position, which is the position that was obtained in step 5.
. Emits each `read` event to the Kafka topic for the source table.
. Releases data table locks, if applicable.

|8
a|Commit the transaction.

|9
|Release the table-level locks.
Other database clients can now write to any previously locked tables.

|10
a|Record the successful completion of the snapshot in the connector offsets.

|===

[id="{context}-connector-snapshot-mode-options"]
.Settings for `snapshot.mode` connector configuration property
[cols="30%a,70%a",options="header"]
|===
|Setting |Description

|`always`
|The connector performs a snapshot every time that it starts.
The snapshot includes the structure and data of the captured tables.
Specify this value to populate topics with a complete representation of the data from the captured tables every time that the connector starts.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

|`initial`
|The connector performs a database snapshot as described in the xref:{context}-initial-snapshot-workflow-with-global-read-lock[default workflow for creating an initial snapshot].
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

|`initial_only`
|The connector performs a database snapshot.
After the snapshot completes, the connector stops, and does not stream event records for subsequent database changes.

|`schema_only`
|Deprecated, see `no_data`.

|`no_data`
|The connector captures the structure of all relevant tables, performing all the steps described in the xref:{context}-initial-snapshot-workflow-with-global-read-lock[default workflow for creating an initial snapshot], except that it does not create `READ` events to represent the data set at the point of the connector's start-up (Step 7.2).

|`never`
|When the connector starts, rather than performing a snapshot, it immediately begins to stream event records for subsequent database changes.
This option is under consideration for future deprecation, in favor of the `no_data` option.

|`schema_only_recovery`
|Deprecated, see `recovery`.

|`recovery`
|Set this option to restore a database schema history topic that is lost or corrupted.
After a restart, the connector runs a snapshot that rebuilds the topic from the source tables.
You can also set the property to periodically prune a database schema history topic that experiences unexpected growth. +
 +
WARNING: Do not use this mode to perform a snapshot if schema changes were committed to the database after the last connector shutdown.

|`when_needed`
|After the connector starts, it performs a snapshot only if it detects one of the following circumstances:

* It cannot detect any topic offsets.
* A previously recorded offset specifies a log position that is not available on the server.

|`configuration_based`
|Set the snapshot mode to `configuration_based` to control snapshot behavior through the set of connector properties that have the prefix 'snapshot.mode.configuration.based'.

|`custom`
|The `custom` snapshot mode lets you inject your own implementation of the `io.debezium.spi.snapshot.Snapshotter` interface.
Set the `snapshot.mode.custom.name` configuration property to the name provided by the `name()` method of your implementation.
The name is specified on the classpath of your Kafka Connect cluster.
If you use the `EmbeddedEngine`, the name is included in the connector JAR file.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|===
For more information, see xref:{context}-property-snapshot-mode[`snapshot.mode`] in the table of connector configuration properties.

:leveloffset: 1


// ModuleID: mariadb-description-of-why-initial-snapshots-capture-the-schema-history-for-all-tables
// Title: Description of why initial snapshots capture the schema history for all tables
// Type: concept
[id="understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables"]
==== Understanding why initial snapshots capture the schema history for all tables

:leveloffset: +1

The initial snapshot that a connector runs captures two types of information:

Table data::
Information about `INSERT`, `UPDATE`, and `DELETE` operations in tables that are named in the connector's xref:{context}-property-table-include-list[`table.include.list`] property.
Schema data::
DDL statements that describe the structural changes that are applied to tables.
Schema data is persisted to both the internal schema history topic, and to the connector's schema change topic, if one is configured.

After you run an initial snapshot, you might notice that the snapshot captures schema information for tables that are not designated for capture.
By default, initial snapshots are designed to capture schema information for every table that is present in the database, not only from tables that are designated for capture.
Connectors require that the table's schema is present in the schema history topic before they can capture a table.
By enabling the initial snapshot to capture schema data for tables that are not part of the original capture set, {prodname} prepares the connector to readily capture event data from these tables should that later become necessary.
If the initial snapshot does not capture a table's schema, you must add the schema to the history topic before the connector can capture data from the table.

In some cases, you might want to limit schema capture in the initial snapshot.
This can be useful when you want to reduce the time required to complete a snapshot.
Or when {prodname} connects to the database instance through a user account that has access to multiple logical databases, but you want the connector to capture changes only from tables in a specific logic database.

.Additional information
* xref:{context}-capturing-data-from-tables-not-captured-by-the-initial-snapshot-no-schema-change[Capturing data from tables not captured by the initial snapshot (no schema change)]
* xref:{context}-capturing-data-from-new-tables-with-schema-changes[Capturing data from tables not captured by the initial snapshot (schema change)]
* Setting the xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.store.only.captured.tables.ddl`] property to specify the tables from which to capture schema information.
* Setting the xref:{context}-property-database-history-store-only-captured-databases-ddl[`schema.history.internal.store.only.captured.databases.ddl`] property to specify the logical databases from which to capture schema changes.

:leveloffset: 1


// Type: procedure
[id="mariadb-capturing-data-from-tables-not-captured-by-the-initial-snapshot-no-schema-change"]
==== Capturing data from tables not captured by the initial snapshot (no schema change)

:leveloffset: +1

In some cases, you might want the connector to capture data from a table whose schema was not captured by the initial snapshot.
Depending on the connector configuration, the initial snapshot might capture the table schema only for specific tables in the database.
If the table schema is not present in the history topic, the connector fails to capture the table, and reports a missing schema error.

You might still be able to capture data from the table, but you must perform additional steps to add the table schema.

.Prerequisites

* You want to capture data from a table with a schema that the connector did not capture during the initial snapshot.
* In the transaction log, all entries for the table use the same schema.
For information about capturing data from a new table that has undergone structural changes, see xref:{context}-capturing-data-from-new-tables-with-schema-changes[Capturing data from tables not captured by the initial snapshot (schema change)].

.Procedure

1. Stop the connector.
2. Remove the internal database schema history topic that is specified by the xref:{context}-property-database-history-kafka-topic[`schema.history.internal.kafka.topic property`].
3. Apply the following changes to the connector configuration:
.. Set the xref:{context}-property-snapshot-mode[`snapshot.mode`] to `schema_only_recovery`.
.. Set the value of xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.store.only.captured.tables.ddl`] to `false`.
.. Add the tables that you want the connector to capture to `table.include.list`.
This guarantees that in the future, the connector can reconstruct the schema history for all tables.
4. Restart the connector.
The snapshot recovery process rebuilds the schema history based on the current structure of the tables.
5. (Optional) After the snapshot completes, initiate an xref:debezium-{context}-incremental-snapshots[incremental snapshot] to capture existing data for newly added tables along with changes to other tables that occurred while that connector was off-line.
6. (Optional) Reset the `snapshot.mode` back to `schema_only` to prevent the connector from initiating recovery after a future restart.

:leveloffset: 1


// Type: procedure
[id="mariadb-capturing-data-from-new-tables-with-schema-changes"]
==== Capturing data from tables not captured by the initial snapshot (schema change)

:leveloffset: +1

If a schema change is applied to a table, records that are committed before the schema change have different structures than those that were committed after the change.
When {prodname} captures data from a table, it reads the schema history to ensure that it applies the correct schema to each event.
If the schema is not present in the schema history topic, the connector is unable to capture the table, and an error results.

If you want to capture data from a table that was not captured by the initial snapshot, and the schema of the table was modified, you must add the schema to the history topic, if it is not already available.
You can add the schema by running a new schema snapshot, or by running an initial snapshot for the table.

.Prerequisites
* You want to capture data from a table with a schema that the connector did not capture during the initial snapshot.
* A schema change was applied to the table so that the records to be captured do not have a uniform structure.

.Procedure

Initial snapshot captured the schema for all tables (`store.only.captured.tables.ddl` was set to `false`)::
1. Edit the xref:{context}-property-table-include-list[`table.include.list`] property to specify the tables that you want to capture.
2. Restart the connector.
3. Initiate an xref:debezium-{context}-incremental-snapshots[incremental snapshot] if you want to capture existing data from the newly added tables.

Initial snapshot did not capture the schema for all tables (`store.only.captured.tables.ddl` was set to `true`)::
If the initial snapshot did not save the schema of the table that you want to capture, complete one of the following procedures:

Procedure 1: Schema snapshot, followed by incremental snapshot:::
In this procedure, the connector first performs a schema snapshot.
You can then initiate an incremental snapshot to enable the connector to synchronize data.
1. Stop the connector.
2. Remove the internal database schema history topic that is specified by the xref:{context}-property-database-history-kafka-topic[`schema.history.internal.kafka.topic property`].
3. Clear the offsets in the configured Kafka Connect link:{link-kafka-docs}/#connectconfigs_offset.storage.topic[`offset.storage.topic`].
For more information about how to remove offsets, see the link:https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector[{prodname} community FAQ].
+
[WARNING]
====
Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.
====
4. Set values for properties in the connector configuration as described in the following steps:
.. Set the value of the xref:{context}-property-snapshot-mode[`snapshot.mode`] property to `schema_only`.
.. Edit the xref:{context}-property-table-include-list[`table.include.list`] to add the tables that you want to capture.
5. Restart the connector.
6. Wait for {prodname} to capture the schema of the new and existing tables.
Data changes that occurred any tables after the connector stopped are not captured.
7. To ensure that no data is lost, initiate an xref:debezium-{context}-incremental-snapshots[incremental snapshot].

Procedure 2: Initial snapshot, followed by optional incremental snapshot:::
In this procedure the connector performs a full initial snapshot of the database.
As with any initial snapshot, in a database with many large tables, running an initial snapshot can be a time-consuming operation.
After the snapshot completes, you can optionally trigger an incremental snapshot to capture any changes that occur while the connector is off-line.

1. Stop the connector.
2. Remove the internal database schema history topic that is specified by the xref:{context}-property-database-history-kafka-topic[`schema.history.internal.kafka.topic property`].
3. Clear the offsets in the configured Kafka Connect link:{link-kafka-docs}/#connectconfigs_offset.storage.topic[`offset.storage.topic`].
For more information about how to remove offsets, see the link:https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector[{prodname} community FAQ].
+
[WARNING]
====
Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.
====
4. Edit the xref:{context}-property-table-include-list[`table.include.list`] to add the tables that you want to capture.
5. Set values for properties in the connector configuration as described in the following steps:
.. Set the value of the xref:{context}-property-snapshot-mode[`snapshot.mode`] property to `initial`.
.. (Optional) Set xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.store.only.captured.tables.ddl`] to `false`.
6. Restart the connector.
The connector takes a full database snapshot.
After the snapshot completes, the connector transitions to streaming.
7. (Optional) To capture any data that changed while the connector was off-line, initiate an xref:debezium-{context}-incremental-snapshots[incremental snapshot].

:leveloffset: 1

// Type: concept
[id="debezium-mariadb-ad-hoc-snapshots"]
=== Ad hoc snapshots

:leveloffset: +1

By default, a connector runs an initial snapshot operation only after it starts for the first time.
Following this initial snapshot, under normal circumstances, the connector does not repeat the snapshot process.
Any future change event data that the connector captures comes in through the streaming process only.

However, in some situations the data that the connector obtained during the initial snapshot might become stale, lost, or incomplete.
To provide a mechanism for recapturing {data-collection} data, {prodname} includes an option to perform ad hoc snapshots.
You might want to perform an ad hoc snapshot after any of the following changes occur in your {prodname} environment:

* The connector configuration is modified to capture a different set of {data-collection}s.
* Kafka topics are deleted and must be rebuilt.
* Data corruption occurs due to a configuration error or some other problem.

You can re-run a snapshot for a {data-collection} for which you previously captured a snapshot by initiating a so-called _ad-hoc snapshot_.
Ad hoc snapshots require the use of {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[signaling {data-collection}s].
You initiate an ad hoc snapshot by sending a signal request to the {prodname} signaling {data-collection}.

When you initiate an ad hoc snapshot of an existing {data-collection}, the connector appends content to the topic that already exists for the {data-collection}.
If a previously existing topic was removed, {prodname} can create a topic automatically if {link-prefix}:{link-topic-auto-creation}#customizing-debezium-automatically-created-topics[automatic topic creation] is enabled.

Ad hoc snapshot signals specify the {data-collection}s to include in the snapshot.
The snapshot can capture the entire contents of the database, or capture only a subset of the {data-collection}s in the database.
Also, the snapshot can capture a subset of the contents of the {data-collection}(s) in the database.

You specify the {data-collection}s to capture by sending an `execute-snapshot` message to the signaling {data-collection}.
Set the type of the `execute-snapshot` signal to `incremental` or `blocking`, and provide the names of the {data-collection}s to include in the snapshot, as described in the following table:


.Example of an ad hoc `execute-snapshot` signal record
[cols="2,2,6a",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| Specifies the type of snapshot that you want to run. +
Currently, you can request `incremental` or `blocking` snapshots.


|`data-collections`
|_N/A_
| An array that contains regular expressions matching the fully-qualified names of the {data-collection} to be snapshotted. +
The format of the names is the same as for the `signal.data.collection` configuration option.

|`[.line-through]#additional-condition#`
|_N/A_
| An optional string, which specifies a condition based on the column(s) of the {data-collection}(s), to capture a
subset of the contents of the {data-collection}(s). +

[NOTE]
====
This property is deprecated.
To specify criteria for defining the subset of data that you want the snapshot to capture, use the `additional-conditions` parameter.
====

|`additional-conditions`
|_N/A_
|An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot. +
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:

`data-collection`:: The fully-qualified name of the {data-collection} that the filter applies to.
You can apply different filters to each {data-collection}.
`filter`:: Specifies column values that must be present in a database record for the snapshot to include it, for example,  `"color='blue'"`. +
 +
The values that you assign to the `filter` parameter are the same types of values that you might specify in the `WHERE` clause of `SELECT` statements when you set the `snapshot.select.statement.overrides` property for a blocking snapshot.
In earlier {prodname} releases, an explicit `filter` parameter was not defined for snapshot signals; instead, filter criteria were implied by the values that were specified for the now deprecated  `additional-condition` parameter.

|`surrogate-key`
|_N/A_
| An optional string that specifies the column name that the connector uses as the primary key of a {data-collection} during the snapshot process.

|===

.Triggering an ad hoc incremental snapshot

You initiate an ad hoc incremental snapshot by adding an entry with the `execute-snapshot` signal type to the signaling {data-collection}.
After the connector processes the message, it begins the snapshot operation.
The snapshot process reads the first and last primary key values and uses those values as the start and end point for each {data-collection}.
Based on the number of entries in the {data-collection}, and the configured chunk size, {prodname} divides the {data-collection} into chunks, and proceeds to snapshot each chunk, in succession, one at a time.

For more information, see xref:debezium-{context}-incremental-snapshots[Incremental snapshots].

.Triggering an ad hoc blocking snapshot

You initiate an ad hoc blocking snapshot by adding an entry with the `execute-snapshot` signal type to the signaling {data-collection}.
After the connector processes the message, it begins the snapshot operation.
The connector temporarily stops streaming, and then initiates a snapshot of the specified {data-collection}, following the same process that it uses during an initial snapshot.
After the snapshot completes, the connector resumes streaming.

For more information, see xref:{context}-blocking-snapshots[Blocking snapshots].

:leveloffset: 1

// Type: assembly
// ModuleID: debezium-mariadb-incremental-snapshots
[id="debezium-mariadb-incremental-snapshots"]
=== Incremental snapshots

:leveloffset: +1

To provide flexibility in managing snapshots, {prodname} includes a supplementary snapshot mechanism, known as _incremental snapshotting_.
Incremental snapshots rely on the {prodname} mechanism for {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[sending signals to a {prodname} connector].
Incremental snapshots are based on the link:https://github.com/debezium/debezium-design-documents/blob/main/DDD-3.md[DDD-3] design document.

In an incremental snapshot, instead of capturing the full state of a database all at once, as in an initial snapshot, {prodname} captures each {data-collection} in phases, in a series of configurable chunks.
You can specify the {data-collection}s that you want the snapshot to capture and the xref:{context}-property-incremental-snapshot-chunk-size[size of each chunk].
The chunk size determines the number of rows that the snapshot collects during each fetch operation on the database.
The default chunk size for incremental snapshots is 1024 rows.

As an incremental snapshot proceeds, {prodname} uses watermarks to track its progress, maintaining a record of each {data-collection} row that it captures.
This phased approach to capturing data provides the following advantages over the standard initial snapshot process:

* You can run incremental snapshots in parallel with streamed data capture, instead of postponing streaming until the snapshot completes.
  The connector continues to capture near real-time events from the change log throughout the snapshot process, and neither operation blocks the other.
* If the progress of an incremental snapshot is interrupted, you can resume it without losing any data.
  After the process resumes, the snapshot begins at the point where it stopped, rather than recapturing the {data-collection} from the beginning.
* You can run an incremental snapshot on demand at any time, and repeat the process as needed to adapt to database updates.
  For example, you might re-run a snapshot after you modify the connector configuration to add a {data-collection} to its xref:{context}-property-{data-collection}-include-list[`{data-collection}.include.list`] property.

.Incremental snapshot process
When you run an incremental snapshot, {prodname} sorts each {data-collection} by primary key and then splits the {data-collection} into chunks based on the xref:{context}-property-incremental-snapshot-chunk-size[configured chunk size].
Working chunk by chunk, it then captures each {data-collection} row in a chunk.
For each row that it captures, the snapshot emits a `READ` event.
That event represents the value of the row when the snapshot for the chunk began.

As a snapshot proceeds, it’s likely that other processes continue to access the database, potentially modifying {data-collection} records.
To reflect such changes, `INSERT`, `UPDATE`, or `DELETE` operations are committed to the transaction log as per usual.
Similarly, the ongoing {prodname} streaming process continues to detect these change events and emits corresponding change event records to Kafka.

.How {prodname} resolves collisions among records with the same primary key
In some cases, the `UPDATE` or `DELETE` events that the streaming process emits are received out of sequence.
That is, the streaming process might emit an event that modifies a {data-collection} row before the snapshot captures the chunk that contains the `READ` event for that row.
When the snapshot eventually emits the corresponding `READ` event for the row, its value is already superseded.
To ensure that incremental snapshot events that arrive out of sequence are processed in the correct logical order, {prodname} employs a buffering scheme for resolving collisions.
Only after collisions between the snapshot events and the streamed events are resolved does {prodname} emit an event record to Kafka.

.Snapshot window
To assist in resolving collisions between late-arriving `READ` events and streamed events that modify the same {data-collection} row, {prodname} employs a so-called _snapshot window_.
The snapshot windows demarcates the interval during which an incremental snapshot captures data for a specified {data-collection} chunk.
Before the snapshot window for a chunk opens, {prodname} follows its usual behavior and emits events from the transaction log directly downstream to the target Kafka topic.
But from the moment that the snapshot for a particular chunk opens, until it closes, {prodname} performs a de-duplication step to resolve collisions between events that have the same primary key..

For each data collection, the {prodname} emits two types of events, and stores the records for them both in a single destination Kafka topic.
The snapshot records that it  captures directly from a table are emitted as `READ` operations.
Meanwhile, as users continue to update records in the data collection, and the transaction log is updated to reflect each commit, {prodname} emits `UPDATE` or `DELETE` operations for each change.

As the snapshot window opens, and {prodname} begins processing a snapshot chunk, it delivers snapshot records to a memory buffer.
During the snapshot windows, the primary keys of the `READ` events in the buffer are compared to the primary keys of the incoming streamed events.
If no match is found, the streamed event record is sent directly to Kafka.
If {prodname} detects a match, it discards the buffered `READ` event, and writes the streamed record to the destination topic, because the streamed event logically supersede the static snapshot event.
After the snapshot window for the chunk closes, the buffer contains only `READ` events for which no related transaction log events exist.
{prodname} emits these remaining `READ` events to the {data-collection}'s Kafka topic.

The connector repeats the process for each snapshot chunk.

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-mariadb-triggering-an-incremental-snapshot
[id="mariadb-triggering-an-incremental-snapshot"]
==== Triggering an incremental snapshot

:leveloffset: +1

Currently, the only way to initiate an incremental snapshot is to send an {link-prefix}:{link-signalling}#debezium-signaling-ad-hoc-snapshots[ad hoc snapshot signal] to the signaling {data-collection} on the source database.

You submit a signal to the signaling {data-collection} as SQL `INSERT` queries.

After {prodname} detects the change in the signaling {data-collection}, it reads the signal, and runs the requested snapshot operation.

The query that you submit specifies the {data-collection}s to include in the snapshot, and, optionally, specifies the type of snapshot operation.
Currently supports the `incremental` and `blocking` types.

To specify the {data-collection}s to include in the snapshot, provide a `data-collections` array that lists the {data-collection}s or an array of regular expressions used to match {data-collection}s, for example, +

`{"data-collections": ["public.MyFirstTable", "public.MySecondTable"]}` +

The `data-collections` array for an incremental snapshot signal has no default value.
If the `data-collections` array is empty, {prodname} detects that no action is required and does not perform a snapshot.

[NOTE]
====
If the name of a {data-collection} that you want to include in a snapshot contains a dot (`.`) in the name of the database, schema, or table, to add the {data-collection} to the `data-collections` array, you must escape each part of the name in double quotes. +
 +
For example, to include a table that exists in the `*public*` schema and that has the name `*My.Table*`, use the following format: `*"public"."My.Table"*`.
====

.Prerequisites

* {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[Signaling is enabled]. +
** A signaling data collection exists on the source database.
** The signaling data collection is specified in the xref:{context}-property-signal-data-collection[`signal.data.collection`] property.

.Using a source signaling channel to trigger an incremental snapshot

. Send a SQL query to add the ad hoc incremental snapshot request to the signaling {data-collection}:
+
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) VALUES (_'<id>'_, _'<snapshotType>'_, '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"_<snapshotType>_","additional-conditions":[{"data-collection": "_<tableName>_", "filter": "_<additional-condition>_"}]}');
----
+
For example,
+
[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) // <1>
values ('ad-hoc-1',   // <2>
    'execute-snapshot',  // <3>
    '{"data-collections": ["schema1.table1", "schema2.table2"], // <4>
    "type":"incremental", // <5>
    "additional-conditions":[{"data-collection": "schema1.table1" ,"filter":"color=\'blue\'"}]}'); // <6>
----
+
The values of the `id`,`type`, and `data` parameters in the command correspond to the {link-prefix}:{link-signalling}#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection[fields of the signaling {data-collection}].
+
The following table describes the parameters in the example:
+
.Descriptions of fields in a SQL command for sending an incremental snapshot signal to the signaling {data-collection}
[cols="1,2,6",options="header"]
|===
|Item |Value |Description

|1
|`myschema.debezium_signal`
|Specifies the fully-qualified name of the signaling {data-collection} on the source database.

|2
|`ad-hoc-1`
|The `id` parameter specifies an arbitrary string that is assigned as the `id` identifier for the signal request. +
Use this string to identify logging messages to entries in the signaling {data-collection}.
{prodname} does not use this string.
Rather, during the snapshot, {prodname} generates its own `id` string as a watermarking signal.

|3
|`execute-snapshot`
|The `type` parameter specifies the operation that the signal is intended to trigger. +

|4
|`data-collections`
|A required component of the `data` field of a signal that specifies an array of {data-collection} names or regular expressions to match {data-collection} names to include in the snapshot. +
The array lists regular expressions which match {data-collection}s by their fully-qualified names, using the same format as you use to specify the name of the connector's signaling {data-collection} in the xref:{context}-property-signal-data-collection[`signal.data.collection`] configuration property.

|5
|`incremental`
|An optional `type` component of the `data` field of a signal that specifies the type of snapshot operation to run. +
Currently supports the `incremental` and `blocking` types. +
If you do not specify a value, the connector runs an incremental snapshot.

|6
|`additional-conditions`
| An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot. +
Each additional condition is an object with `data-collection` and `filter` properties.
You can specify different filters for each data collection. +
* The `data-collection` property is the fully-qualified name of the data collection for which the filter will be applied.
For more information about the `additional-conditions` parameter, see xref:{context}-incremental-snapshots-additional-conditions[].
|===

[id="{context}-incremental-snapshots-additional-conditions"]
.Ad hoc incremental snapshots with `additional-conditions`

If you want a snapshot to include only a subset of the content in a {data-collection}, you can modify the signal request by appending an `additional-conditions` parameter to the snapshot signal.

The SQL query for a typical snapshot takes the following form:

[source,sql,subs="+attributes,+quotes"]
----
SELECT * FROM _<tableName>_ ....
----

By adding an `additional-conditions` parameter, you append a `WHERE` condition to the SQL query, as in the following example:

[source,sql,subs="+attributes,+quotes"]
----
SELECT * FROM _<data-collection>_ WHERE _<filter>_ ....
----

The following example shows a SQL query to send an ad hoc incremental snapshot request with an additional condition to the signaling {data-collection}:
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) VALUES (_'<id>'_, _'<snapshotType>'_, '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"_<snapshotType>_","additional-conditions":[{"data-collection": "_<tableName>_", "filter": "_<additional-condition>_"}]}');
----

For example, suppose you have a `products` {data-collection} that contains the following columns:

* `id` (primary key)
* `color`
* `quantity`

If you want an incremental snapshot of the `products` {data-collection} to include only the data items where `color=blue`, you can use the following SQL statement to trigger the snapshot:

[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) VALUES('ad-hoc-1', 'execute-snapshot', '{"data-collections": ["schema1.products"],"type":"incremental", "additional-conditions":[{"data-collection": "schema1.products", "filter": "color=blue"}]}');
----

The `additional-conditions` parameter also enables you to pass conditions that are based on more than one column.
For example, using the `products` {data-collection} from the previous example, you can submit a query that triggers an incremental snapshot that includes the data of only those items for which `color=blue` and `quantity>10`:

[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) VALUES('ad-hoc-1', 'execute-snapshot', '{"data-collections": ["schema1.products"],"type":"incremental", "additional-conditions":[{"data-collection": "schema1.products", "filter": "color=blue AND quantity>10"}]}');
----

The following example, shows the JSON for an incremental snapshot event that is captured by a connector.

.Example: Incremental snapshot event message
[source,json,index=0]
----
{
    "before":null,
    "after": {
        "pk":"1",
        "value":"New data"
    },
    "source": {
        ...
        "snapshot":"incremental" <1>
    },
    "op":"r", <2>
    "ts_ms":"1620393591654",
    "ts_us":"1620393591654547",
    "ts_ns":"1620393591654547920",
    "transaction":null
}
----
[cols="1,1,4",options="header"]
|===
|Item |Field name |Description
|1
|`snapshot`
|Specifies the type of snapshot operation to run. +
Currently, the only valid options are `blocking` and `incremental`. +
Specifying a `type` value in the SQL query that you submit to the signaling {data-collection} is optional. +
If you do not specify a value, the connector runs an incremental snapshot.

|2
|`op`
|Specifies the event type. +
The value for snapshot events is `r`, signifying a `READ` operation.

|===

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-mariadb-using-the-kafka-signaling-channel-to-trigger-an-incremental-snapshot
[id="mariadb-triggering-an-incremental-snapshot-kafka"]
==== Using the Kafka signaling channel to trigger an incremental snapshot

:leveloffset: +1

You can send a message to the {link-prefix}:{link-signalling}#debezium-signaling-enabling-kafka-signaling-channel[configured Kafka topic] to request the connector to run an ad hoc incremental snapshot.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value of the message is a JSON object with `type` and `data` fields.

The signal type is `execute-snapshot`, and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6a",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed.
Currently {prodname} supports the `incremental` and `blocking` types. +
See the next section for more details.

|`data-collections`
|_N/A_
| An array of comma-separated regular expressions that match the fully-qualified names of tables to include in the snapshot. +
Specify the names by using the same format as is required for the xref:{context}-property-signal-data-collection[signal.data.collection] configuration option.

|`[.line-through]#additional-condition#`
|_N/A_
| An optional string that specifies a condition that the connector evaluates to designate a subset of records to include in a snapshot. +

[NOTE]
====
This property is deprecated and should be replaced by the `additional-conditions` property.
====

|`additional-conditions`
|_N/A_
| An optional array of additional conditions that specifies criteria that the connector evaluates to designate a subset of records to include in a snapshot. +
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:
`data-collection`:: The fully-qualified name of the {data-collection} that the filter applies to.
You can apply different filters to each {data-collection}.
`filter`:: Specifies column values that must be present in a database record for the snapshot to include it, for example,  `"color='blue'"`. +
 +
The values that you assign to the `filter` parameter are the same types of values that you might specify in the `WHERE` clause of `SELECT` statements when you set the `snapshot.select.statement.overrides` property for a blocking snapshot.
In earlier {prodname} releases, an explicit `filter` parameter was not defined for snapshot signals; instead, filter criteria were implied by the values that were specified for the now deprecated `additional-condition` parameter.
|===

An example of the execute-snapshot Kafka message:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

.Ad hoc incremental snapshots with additional-conditions

{prodname} uses the `additional-conditions` field to select a subset of a {data-collection}'s content.

Typically, when {prodname} runs a snapshot, it runs a SQL query such as:

`SELECT * FROM _<tableName>_ ....`

When the snapshot request includes an `additional-conditions` property, the `data-collection` and `filter` parameters of the  property are appended to the SQL query, for example:

`SELECT * FROM _<data-collection>_ WHERE _<filter>_ ....`

For example, given a `products` {data-collection} with the columns `id` (primary key), `color`, and `brand`, if you want a snapshot to include only content for which `color='blue'`, when you request the snapshot, you could add the `additional-conditions` property to filter the content:
----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "schema1.products" ,"filter":"color='blue'"}]}}`
----

You can use the `additional-conditions` property to pass conditions based on multiple columns.
For example, using the same `products` {data-collection} as in the previous example, if you want a snapshot to include only the content from the `products` {data-collection} for which `color='blue'`, and `brand='MyBrand'`, you could send the following request:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "schema1.products" ,"filter":"color='blue' AND brand='MyBrand'"}]}}`
----

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-mariadb-stopping-an-incremental-snapshot
[id="mariadb-stopping-an-incremental-snapshot"]
==== Stopping an incremental snapshot

:leveloffset: +1

You can also stop an incremental snapshot by sending a signal to the {data-collection} on the source database.
You submit a stop snapshot signal to the {data-collection} by sending a SQL `INSERT` query.

After {prodname} detects the change in the signaling {data-collection}, it reads the signal, and stops the incremental snapshot operation if it's in progress.

The query that you submit specifies the snapshot operation of `incremental`, and, optionally, the {data-collection}s of the current running snapshot to be removed.

.Prerequisites

* {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[Signaling is enabled]. +
** A signaling data collection exists on the source database.
** The signaling data collection is specified in the xref:{context}-property-signal-data-collection[`signal.data.collection`] property.

.Using a source signaling channel to stop an incremental snapshot

. Send a SQL query to stop the ad hoc incremental snapshot to the signaling {data-collection}:
+
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) values (_'<id>'_, 'stop-snapshot', '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"incremental"}');
----
+
For example,
+
[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) // <1>
values ('ad-hoc-1',   // <2>
    'stop-snapshot',  // <3>
    '{"data-collections": ["schema1.table1", "schema2.table2"], // <4>
    "type":"incremental"}'); // <5>
----
+
The values of the `id`, `type`, and `data` parameters in the signal command correspond to the {link-prefix}:{link-signalling}#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection[fields of the signaling {data-collection}].
+
The following table describes the parameters in the example:
+
.Descriptions of fields in a SQL command for sending a stop incremental snapshot signal to the signaling {data-collection}
[cols="1,2,6",options="header"]
|===
|Item|Value |Description

|1
|`myschema.debezium_signal`
|Specifies the fully-qualified name of the signaling {data-collection} on the source database.

|2
|`ad-hoc-1`
| The `id` parameter specifies an arbitrary string that is assigned as the `id` identifier for the signal request. +
Use this string to identify logging messages to entries in the signaling {data-collection}.
{prodname} does not use this string.

|3
|`stop-snapshot`
| Specifies `type` parameter specifies the operation that the signal is intended to trigger. +

|4
|`data-collections`
|An optional component of the `data` field of a signal that specifies an array of {data-collection} names or regular expressions to match {data-collection} names to remove from the snapshot. +
The array lists regular expressions which match {data-collection}s by their fully-qualified names, using the same format as you use to specify the name of the connector's signaling {data-collection} in the xref:{context}-property-signal-data-collection[`signal.data.collection`] configuration property.
If this component of the `data` field is omitted, the signal stops the entire incremental snapshot that is in progress.

|5
|`incremental`
|A required component of the `data` field of a signal that specifies the type of snapshot operation that is to be stopped. +
Currently, the only valid option is `incremental`. +
If you do not specify a `type` value, the signal fails to stop the incremental snapshot.
|===

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-mariadb-using-the-kafka-signaling-channel-to-stop-an-incremental-snapshot
[id="mariadb-stopping-an-incremental-snapshot-kafka"]
==== Using the Kafka signaling channel to stop an incremental snapshot

:leveloffset: +1

You can send a signal message to the {link-prefix}:{link-signalling}#debezium-signaling-enabling-kafka-signaling-channel[configured Kafka signaling topic] to stop an ad hoc incremental snapshot.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value of the message is a JSON object with `type` and `data` fields.

The signal type is `stop-snapshot`, and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed.
Currently {prodname} supports only the `incremental` type.  +
See the next section for more details.

|`data-collections`
|_N/A_
| An optional array of comma-separated regular expressions that match the fully-qualified names of the tables to include in the snapshot. +
Specify the names by using the same format as is required for the xref:{context}-property-signal-data-collection[signal.data.collection] configuration option.

|===

The following example shows a typical `stop-snapshot` Kafka message:

----
Key = `test_connector`

Value = `{"type":"stop-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

:leveloffset: 1

[id="mariadb-read-only-incremental-snapshots"]
==== Read-only incremental snapshots

:leveloffset: +1

The {prodname} {connector-name} connector allows for running incremental snapshots with a read-only connection to the database.
To run an incremental snapshot with read-only access, the connector uses the executed global transaction IDs (GTID) set as high and low watermarks.
The state of a chunk's window is updated by comparing the GTIDs of binary log (binlog) events or the server's heartbeats against low and high watermarks.

To switch to a read-only implementation, set the value of the xref:{context}-property-read-only[`read.only`] property to `true`.

.Prerequisites

* xref:enable-{context}-gtids[Enable {connector-name} GTIDs].
* If the connector reads from a multi-threaded replica (that is, a replica for which the value of `replica_parallel_workers` is greater than `0`)
you must set one of the following options:

** `replica_preserve_commit_order=ON`
** `slave_preserve_commit_order=ON`

:leveloffset: 1

==== Ad hoc read-only incremental snapshots

:leveloffset: +1

When the {connector-name} connection is read-only, you can use any of the {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[available signaling channels] without the requirement to use the `source` channel.

:leveloffset: 1


[[connector-custom-snapshot]]
=== Custom snapshotter SPI
:leveloffset: +3

For more advanced uses, you can fine-tune control of the snapshot by implementing one of the following interfaces:

`io.debezium.snapshot.spi.Snapshotter`:: Controls whether the connector takes a snapshot.
`io.debezium.snapshot.spi.SnapshotQuery`:: Controls how data is queried during a snapshot.
`io.debezium.snapshot.spi.SnapshotLock`:: Controls whether the connector locks tables when taking a snapshot.


[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.Snapshotter interface. All built-in snapshot modes implement this interface.
----
/**
 * {@link Snapshotter} is used to determine the following details about the snapshot process:
 * <p>
 * - Whether a snapshot occurs. <br>
 * - Whether streaming continues during the snapshot. <br>
 * - Whether the snapshot includes schema (if supported). <br>
 * - Whether to snapshot data or schema following an error.
 * <p>
 * Although Debezium provides many default snapshot modes,
 * to provide more advanced functionality, such as partial snapshots,
 * you can customize implementation of the interface.
 * For more information, see the documentation.
 *
 *
 *
 */
@Incubating
public interface Snapshotter extends Configurable {

    /**
     * @return the name of the snapshotter.
     *
     *
     */
    String name();

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a data snapshot
     */
    boolean shouldSnapshotData(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a schema snapshot
     */
    boolean shouldSnapshotSchema(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @return {@code true} if the snapshotter should stream after taking a snapshot
     */
    boolean shouldStream();

    /**
     * @return {@code true} whether the schema can be recovered if database schema history is corrupted.
     */
    boolean shouldSnapshotOnSchemaError();

    /**
     * @return {@code true} whether the snapshot should be re-executed when there is a gap in data stream.
     */
    boolean shouldSnapshotOnDataError();

    /**
     *
     * @return {@code true} if streaming should resume from the start of the snapshot
     * transaction, or {@code false} for when a connector resumes and takes a snapshot,
     * streaming should resume from where streaming previously left off.
     */
    default boolean shouldStreamEventsStartingFromSnapshot() {
        return true;
    }

    /**
     * Lifecycle hook called after the snapshot phase is successful.
     */
    default void snapshotCompleted() {
        // no operation
    }

    /**
     * Lifecycle hook called after the snapshot phase is aborted.
     */
    default void snapshotAborted() {
        // no operation
    }
}
----

[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.SnapshotQuery interface. All built-in snapshot query modes implement this interface.
----
/**
 * {@link SnapshotQuery} is used to determine the query used during a data snapshot
 *
 *
 */
public interface SnapshotQuery extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Generate a valid query string for the specified table, or an empty {@link Optional}
     * to skip snapshotting this table (but that table will still be streamed from)
     *
     * @param tableId the table to generate a query for
     * @param snapshotSelectColumns the columns to be used in the snapshot select based on the column
     *                              include/exclude filters
     * @return a valid query string, or none to skip snapshotting this table
     */
    Optional<String> snapshotQuery(String tableId, List<String> snapshotSelectColumns);

}
----

[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.SnapshotLock interface. All built-in snapshot lock modes implement this interface.
----
/**
 * {@link SnapshotLock} is used to determine the table lock mode used during schema snapshot
 *
 *
 */
public interface SnapshotLock extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Returns a SQL statement for locking the given table during snapshotting, if required by the specific snapshotter
     * implementation.
     */
    Optional<String> tableLockingStatement(Duration lockTimeout, String tableId);

}
----

:leveloffset: 1

// Type: concept
[id="mariadb-blocking-snapshots"]
=== Blocking snapshots

:leveloffset: +3

To provide more flexibility in managing snapshots, {prodname} includes a supplementary ad hoc snapshot mechanism, known as a _blocking snapshot_.
Blocking snapshots rely on the {prodname} mechanism for {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[sending signals to a {prodname} connector].

A blocking snapshot behaves just like an _initial snapshot_, except that you can trigger it at run time.

You might want to run a blocking snapshot rather than use the standard initial snapshot process in the following situations:

* You add a new {data-collection} and you want to complete the snapshot while the connector is running.
* You add a large {data-collection}, and you want the snapshot to complete in less time than is possible with an incremental snapshot.

.Blocking snapshot process
When you run a blocking snapshot, {prodname} stops streaming, and then initiates a snapshot of the specified {data-collection}, following the same process that it uses during an initial snapshot.
After the snapshot completes, the streaming is resumed.

.Configure snapshot

You can set the following properties in the `data` component of a signal:

 * data-collections: to specify which {data-collection}s must be snapshot
 * additional-conditions: You can specify different filters for different {data-collection}. +
 ** The `data-collection` property is the fully-qualified name of the {data-collection} for which the filter will be applied.
 ** The `filter` property will have the same value used in the  `snapshot.select.statement.overrides`

For example:
[source,json]
----
  {"type": "blocking", "data-collections": ["schema1.table1", "schema1.table2"], "additional-conditions": [{"data-collection": "schema1.table1", "filter": "SELECT * FROM [schema1].[table1] WHERE column1 = 0 ORDER BY column2 DESC"}, {"data-collection": "schema1.table2", "filter": "SELECT * FROM [schema1].[table2] WHERE column2 > 0"}]}
----

.Possible duplicates
A delay might exist between the time that you send the signal to trigger the snapshot, and the time when streaming stops and the snapshot starts.
As a result of this delay, after the snapshot completes, the connector might emit some event records that duplicate records captured by the snapshot.

:leveloffset: 1

// Type: concept
// Title: Default names of Kafka topics that receive {prodname} MariaDB change event records
[[mariadb-topic-names]]
=== Topic names

:leveloffset: +1

By default, the {connector-name} connector writes change events for all of the `INSERT`, `UPDATE`, and `DELETE` operations that occur in a table to a single Apache Kafka topic that is specific to that table.

The connector uses the following convention to name change event topics:

_topicPrefix.databaseName.tableName_

Suppose that `fulfillment` is the topic prefix, `inventory` is the database name, and the database contains tables named `orders`, `customers`, and `products`.
The {prodname} {connector-name} connector emits events to three Kafka topics, one for each table in the database:

----
fulfillment.inventory.orders
fulfillment.inventory.customers
fulfillment.inventory.products
----

The following list provides definitions for the components of the default name:

_topicPrefix_:: The topic prefix as specified by the xref:{context}-property-topic-prefix[`topic.prefix`] connector configuration property.

_schemaName_:: The name of the schema in which the operation occurred.

_tableName_:: The name of the table in which the operation occurred.

The connector applies similar naming conventions to label its internal database schema history topics, xref:{context}-schema-change-topic[schema change topics], and xref:{context}-transaction-metadata[transaction metadata topics].

If the default topic name do not meet your requirements, you can configure custom topic names.
To configure custom topic names, you specify regular expressions in the logical topic routing SMT.
For more information about using the logical topic routing SMT to customize topic naming, see {link-prefix}:{link-topic-routing}#topic-routing[Topic routing].

:leveloffset: 1

[[mariadb-transaction-metadata]]
=== Transaction metadata

:leveloffset: +1

{prodname} can generate events that represent transaction boundaries and that enrich data change event messages.

[NOTE]
.Limits on when {prodname} receives transaction metadata
====
{prodname} registers and receives metadata only for transactions that occur after you deploy the connector.
Metadata for transactions that occur before you deploy the connector is not available.
====

{prodname} generates transaction boundary events for the `BEGIN` and `END` delimiters in every transaction.
Transaction boundary events contain the following fields:

`status`:: `BEGIN` or `END`.
`id`:: String representation of the unique transaction identifier.
`ts_ms`:: The time of a transaction boundary event (`BEGIN` or `END` event) at the data source.
If the data source does not provide {prodname} with the event time, then the field instead represents the time at which {prodname} processes the event.
`event_count` (for `END` events):: Total number of events emitted by the transaction.
`data_collections` (for `END` events):: An array of pairs of `data_collection` and `event_count` elements that indicates the number of events that the connector emits for changes that originate from a data collection.

.Example

[source,json,indent=0,subs="+attributes"]
----
{
  "status": "BEGIN",
  "id": "0e4d5dcd-a33b-11ea-80f1-02010a22a99e:10",
  "ts_ms": 1486500577125,
  "event_count": null,
  "data_collections": null
}

{
  "status": "END",
  "id": "0e4d5dcd-a33b-11ea-80f1-02010a22a99e:10",
  "ts_ms": 1486500577691,
  "event_count": 2,
  "data_collections": [
    {
      "data_collection": "s1.a",
      "event_count": 1
    },
    {
      "data_collection": "s2.a",
      "event_count": 1
    }
  ]
}
----

Unless overridden via the xref:{context}-property-topic-transaction[`topic.transaction`] option,
the connector emits transaction events to the xref:{context}-property-topic-prefix[`_<topic.prefix>_`]`.transaction` topic.

.Change data event enrichment

When transaction metadata is enabled the data message `Envelope` is enriched with a new `transaction` field.
This field provides information about every event in the form of a composite of fields:

`id`:: String representation of unique transaction identifier.
`total_order`:: The absolute position of the event among all events generated by the transaction.
`data_collection_order`:: The per-data collection position of the event among all events that were emitted by the transaction.

Following is an example of a message:

[source,json,indent=0,subs="+attributes"]
----
{
  "before": null,
  "after": {
    "pk": "2",
    "aa": "1"
  },
  "source": {
...
  },
  "op": "c",
  "ts_ms": "1580390884335",
  "ts_us": "1580390884335472",
  "ts_ns": "1580390884335472987",
  "transaction": {
    "id": "0e4d5dcd-a33b-11ea-80f1-02010a22a99e:10",
    "total_order": "1",
    "data_collection_order": "1"
  }
}
----

:leveloffset: 1

// Type: assembly
// ModuleID: descriptions-of-debezium-mariadb-connector-data-change-events
// Title: Descriptions of {prodname} MariaDB connector data change events
[[mariadb-events]]
== Data change events

:leveloffset: +1

The {prodname} {connector-name} connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed.

{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained.

The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converter and you configure it to produce all four basic change event parts, change events have this structure:

[source,json,index=0]
----
{
 "schema": { //<1>
   ...
  },
 "payload": { //<2>
   ...
 },
 "schema": { //<3>
   ...
 },
 "payload": { //<4>
   ...
 },
}
----

.Overview of change event basic content
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +
 +
It is possible to override the table's primary key by setting the xref:{context}-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.

|2
|`payload`
|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field, and it contains the key for the row that was changed.

|3
|`schema`
|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas.

|4
|`payload`
|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.

|===

By default, the connector streams change event records to topics with names that are the same as the event's originating table. See xref:{context}-topic-names[topic names].

[WARNING]
====
The {connector-name} connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or pass:[_]. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or pass:[_]. If there is an invalid character it is replaced with an underscore character.

This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.
====


:leveloffset: 1

// Type: concept
// ModuleID: about-keys-in-debezium-mariadb-change-events
// Title: About keys in {prodname} MariaDB change events
[[mariadb-change-event-keys]]
=== Change event keys

:leveloffset: +1

A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.

Consider the following `customers` table, which is followed by an example of a change event key for this table.

[source,sql]
----
CREATE TABLE customers (
  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE KEY
) AUTO_INCREMENT=1001;
----

Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:

[source,json,index=0,subs="+attributes"]
----
{
 "schema": { <1>
    "type": "struct",
    "name": "{context}-server-1.inventory.customers.Key", <2>
    "optional": false, <3>
    "fields": [ <4>
      {
        "field": "id",
        "type": "int32",
        "optional": false
      }
    ]
  },
 "payload": { <5>
    "id": 1001
  }
}
----

.Description of change event key
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion.

|2
|`{context}-server-1.inventory.customers.Key`
a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: +

* `{context}-server-1` is the name of the connector that generated this event. +
* `inventory` is the database that contains the table that was changed. +
* `customers` is the table that was updated.

|3
|`optional`
|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.

|4
|`fields`
|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.

|5
|`payload`
|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1001`.

|===

:leveloffset: 1

// Type: concept
// ModuleID: about-values-in-debezium-mariadb-change-events
// Title: About values in {prodname} MariaDB change events
[[mariadb-change-event-values]]
=== Change event values

:leveloffset: +1

The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure.

Consider the same sample table that was used to show an example of a change event key:

[source,sql]
----
CREATE TABLE customers (
  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE KEY
) AUTO_INCREMENT=1001;
----

The value portion of a change event for a change to this table is described for:

* <<{context}-create-events,_create_ events>>
* <<{context}-update-events,_update_ events>>
* <<{context}-primary-key-updates,Primary key updates>>
* <<{context}-delete-events,_delete_ events>>
* <<{context}-tombstone-events,Tombstone events>>
* <<{context}-truncate-events,_truncate_ events>>

:leveloffset: 1


// Type: continue
[id="mariadb-create-events"]
=== _create_ events

:leveloffset: +1


The following example shows the value portion of a change event that the connector generates for an operation that creates data in the `customers` table:

[source,json,options="nowrap",subs="+attributes"]
----
{
  "schema": { // <1>
    "type": "struct",
    "fields": [
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "id"
          },
          {
            "type": "string",
            "optional": false,
            "field": "first_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "last_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "email"
          }
        ],
        "optional": true,
        "name": "{context}-server-1.inventory.customers.Value", // <2>
        "field": "before"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "id"
          },
          {
            "type": "string",
            "optional": false,
            "field": "first_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "last_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "email"
          }
        ],
        "optional": true,
        "name": "{context}-server-1.inventory.customers.Value",
        "field": "after"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "string",
            "optional": false,
            "field": "version"
          },
          {
            "type": "string",
            "optional": false,
            "field": "connector"
          },
          {
            "type": "string",
            "optional": false,
            "field": "name"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ms"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_us"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ns"
          },
          {
            "type": "boolean",
            "optional": true,
            "default": false,
            "field": "snapshot"
          },
          {
            "type": "string",
            "optional": false,
            "field": "db"
          },
          {
            "type": "string",
            "optional": true,
            "field": "table"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "server_id"
          },
          {
            "type": "string",
            "optional": true,
            "field": "gtid"
          },
          {
            "type": "string",
            "optional": false,
            "field": "file"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "pos"
          },
          {
            "type": "int32",
            "optional": false,
            "field": "row"
          },
          {
            "type": "int64",
            "optional": true,
            "field": "thread"
          },
          {
            "type": "string",
            "optional": true,
            "field": "query"
          }
        ],
        "optional": false,
        "name": "io.debezium.connector.{context}.Source", // <3>
        "field": "source"
      },
      {
        "type": "string",
        "optional": false,
        "field": "op"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ms"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_us"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ns"
      }
    ],
    "optional": false,
    "name": "{context}-server-1.inventory.customers.Envelope" // <4>
  },
  "payload": { // <5>
    "op": "c", // <6>
    "ts_ms": 1465491411815, // <7>
    "ts_us": 1465491411815437, // <7>
    "ts_ns": 1465491411815437158, // <7>
    "before": null, // <8>
    "after": { // <9>
      "id": 1004,
      "first_name": "Anne",
      "last_name": "Kretchmar",
      "email": "annek@noanswer.org"
    },
    "source": { // <10>
      "version": "{debezium-version}",
      "connector": "{context}",
      "name": "{context}-server-1",
      "ts_ms": 0,
      "ts_us": 0,
      "ts_ns": 0,
      "snapshot": false,
      "db": "inventory",
      "table": "customers",
      "server_id": 0,
      "gtid": null,
      "file": "{context}-bin.000003",
      "pos": 154,
      "row": 0,
      "thread": 7,
      "query": "INSERT INTO customers (first_name, last_name, email) VALUES ('Anne', 'Kretchmar', 'annek@noanswer.org')"
    }
  }
}
----

.Descriptions of _create_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The value's schema, which describes the structure of the value's payload.
A change event's value schema is the same in every change event that the connector generates for a particular table.

|2
|`name`
a|In the `schema` section, each `name` field specifies the schema for a field in the value's payload. +
 +
`{context}-server-1.inventory.customers.Value` is the schema for the payload's `before` and `after` fields.
This schema is specific to the `customers` table. +
 +
Names of schemas for `before` and `after` fields are of the form `_logicalName_._tableName_.Value`, which ensures that the schema name is unique in the database.
This means that when using the {link-prefix}:{link-avro-serialization}#avro-serialization[Avro converter], the resulting Avro schema for each table in each logical source has its own evolution and history.

|3
|`name`
|`io.debezium.connector.{context}.Source` is the schema for the payload's `source` field.
This schema is specific to the {connector-name} connector.
The connector uses it for all events that it generates.

|4
|`name`
|`{context}-server-1.inventory.customers.Envelope` is the schema for the overall structure of the payload, where `{context}-server-1` is the connector name, `inventory` is the database, and `customers` is the table.

|5
|`payload`
|The value's actual data.
This is the information that the change event is providing. +
 +
It may appear that the JSON representations of the events are much larger than the rows they describe.
This is because the JSON representation must include the schema and the payload portions of the message.
However, by using the {link-prefix}:{link-avro-serialization}#avro-serialization[Avro converter], you can significantly decrease the size of the messages that the connector streams to Kafka topics.

|6
|`op`
a| Mandatory string that describes the type of operation that caused the connector to generate the event.
In this example, `c` indicates that the operation created a row. Valid values are:

* `c` = create
* `u` = update
* `d` = delete
* `r` = read (applies to only snapshots)

|7
|`ts_ms`, `ts_us`, `ts_ns`
a| Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database.
By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|8
|`before`
| An optional field that specifies the state of the row before the event occurred.
When the `op` field is `c` for create, as it is in this example, the `before` field is `null` since this change event is for new content.

|9
|`after`
| An optional field that specifies the state of the row after the event occurred.
In this example, the `after` field contains the values of the new row's `id`, `first_name`, `last_name`, and `email` columns.

|10
|`source`
a| Mandatory field that describes the source metadata for the event.
This field contains information that you can use to compare this event with other events, with regard to the origin of the events, the order in which the events occurred, and whether events were part of the same transaction. The source metadata includes:

* {prodname} version
* Connector name
* binlog name where the event was recorded
* binlog position
* Row within the event
* If the event was part of a snapshot
* Name of the database and table that contain the new row
* ID of the {connector-name} thread that created the event (non-snapshot only)
* {connector-name} server ID (if available)
* Timestamp for when the change was made in the database

If the xref:enable-query-log-events[`binlog_annotate_row_events`] MariaDB configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.

|===

:leveloffset: 1

// Type: continue
[id="mariadb-update-events"]
=== _update_ events

:leveloffset: +1

The value of a change event for an update in the sample `customers` table has the same schema as a _create_ event for that table. Likewise, the event value's payload has the same structure. However, the event value payload contains different values in an _update_ event. Here is an example of a change event value in an event that the connector generates for an update in the `customers` table:

[source,json,options="nowrap",subs="+attributes"]
----
{
  "schema": { ... },
  "payload": {
    "before": { // <1>
      "id": 1004,
      "first_name": "Anne",
      "last_name": "Kretchmar",
      "email": "annek@noanswer.org"
    },
    "after": { // <2>
      "id": 1004,
      "first_name": "Anne Marie",
      "last_name": "Kretchmar",
      "email": "annek@noanswer.org"
    },
    "source": { // <3>
      "version": "{debezium-version}",
      "name": "{context}-server-1",
      "connector": "{context}",
      "name": "{context}-server-1",
      "ts_ms": 1465581029100,
      "ts_ms": 1465581029100000,
      "ts_ms": 1465581029100000000,
      "snapshot": false,
      "db": "inventory",
      "table": "customers",
      "server_id": 223344,
      "gtid": null,
      "file": "{context}-bin.000003",
      "pos": 484,
      "row": 0,
      "thread": 7,
      "query": "UPDATE customers SET first_name='Anne Marie' WHERE id=1004"
    },
    "op": "u", // <4>
    "ts_ms": 1465581029523, // <5>
    "ts_ms": 1465581029523758, // <6>
    "ts_ms": 1465581029523758914 // <7>
  }
}
----

.Descriptions of _update_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|An optional field that specifies the state of the row before the event occurred. In an _update_ event value, the `before` field contains a field for each table column and the value that was in that column before the database commit. In this example, the `first_name` value is `Anne.`

|2
|`after`
| An optional field that specifies the state of the row after the event occurred. You can compare the `before` and `after` structures to determine what the update to this row was. In the example, the `first_name` value is now `Anne Marie`.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. The `source` field structure has the same fields as in a _create_ event, but some values are different, for example, the sample _update_ event is from a different position in the binlog. The source metadata includes:

* {prodname} version
* Connector name
* binlog name where the event was recorded
* binlog position
* Row within the event
* If the event was part of a snapshot
* Name of the database and table that contain the updated row
* ID of the {connector-name} thread that created the event (non-snapshot only)
* {connector-name} server ID (if available)
* Timestamp for when the change was made in the database

If the xref:enable-query-log-events[`binlog_annotate_row_events`] MariaDB configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.

|4
|`op`
a|Mandatory string that describes the type of operation. In an _update_ event value, the `op` field value is `u`, signifying that this row changed because of an update.

|5
|`ts_ms`
a| Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|6
|`ts_us`
a|Optional field that displays the time at which the connector processed the event, in microseconds.
The time is based on the system clock in the JVM running the Kafka Connect task.

|7
|`ts_ns`
a|Optional field that displays the time at which the connector processed the event, in nanoseconds.
The time is based on the system clock in the JVM running the Kafka Connect task.

|===

[NOTE]
====
Updating the columns for a row's primary/unique key changes the value of the row's key. When a key changes, {prodname} outputs _three_ events: a `DELETE` event and a xref:{context}-tombstone-events[tombstone event] with the old key for the row, followed by an event with the new key for the row. Details are in the next section.
====


:leveloffset: 1

// Type: continue
[id="mariadb-primary-key-updates"]
=== Primary key updates

:leveloffset: +1

An `UPDATE` operation that changes a row's primary key field(s) is known
as a primary key change. For a primary key change, in place of an `UPDATE` event record, the connector emits a `DELETE` event record for the old key and a `CREATE` event record for the new (updated) key. These events have the usual structure and content, and in addition, each one has a message header related to the primary key change:

* The `DELETE` event record has `__debezium.newkey` as a message header. The value of this header is the new primary key for the updated row.

* The `CREATE` event record has `__debezium.oldkey` as a message header. The value of this header is the previous (old) primary key that the updated row had.


:leveloffset: 1


// Type: continue
[id="mariadb-delete-events"]
=== _delete_ events

:leveloffset: +1

The value in a _delete_ change event has the same `schema` portion as _create_ and _update_ events for the same table. The `payload` portion in a _delete_ event for the sample `customers` table looks like this:

[source,json,options="nowrap",subs="+attributes"]
----
{
  "schema": { ... },
  "payload": {
    "before": { // <1>
      "id": 1004,
      "first_name": "Anne Marie",
      "last_name": "Kretchmar",
      "email": "annek@noanswer.org"
    },
    "after": null, // <2>
    "source": { // <3>
      "version": "{debezium-version}",
      "connector": "{context}",
      "name": "{context}-server-1",
      "ts_ms": 1465581902300,
      "ts_us": 1465581902300000,
      "ts_ns": 1465581902300000000,
      "snapshot": false,
      "db": "inventory",
      "table": "customers",
      "server_id": 223344,
      "gtid": null,
      "file": "{context}-bin.000003",
      "pos": 805,
      "row": 0,
      "thread": 7,
      "query": "DELETE FROM customers WHERE id=1004"
    },
    "op": "d", // <4>
    "ts_ms": 1465581902461, // <5>
    "ts_us": 1465581902461842, // <6>
    "ts_ns": 1465581902461842579 // <7>
  }
}
----

.Descriptions of _delete_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|Optional field that specifies the state of the row before the event occurred. In a _delete_ event value, the `before` field contains the values that were in the row before it was deleted with the database commit.

|2
|`after`
| Optional field that specifies the state of the row after the event occurred. In a _delete_ event value, the `after` field is `null`, signifying that the row no longer exists.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. In a _delete_ event value, the `source` field structure is the same as for _create_ and _update_ events for the same table. Many `source` field values are also the same. In a _delete_ event value, the `ts_ms` and `pos` field values, as well as other values, might have changed. But the `source` field in a _delete_ event value provides the same metadata:

* {prodname} version
* Connector name
* binlog name where the event was recorded
* binlog position
* Row within the event
* If the event was part of a snapshot
* Name of the database and table that contain the updated row
* ID of the {connector-name} thread that created the event (non-snapshot only)
* {connector-name} server ID (if available)
* Timestamp for when the change was made in the database

If the xref:enable-query-log-events[`binlog_annotate_row_events`] MariaDB configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.

|4
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `d`, signifying that this row was deleted.

|5
|`ts_ms`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|6
|`ts_us`
a|Optional field that displays the time at which the connector processed the event, in microseconds.
The time is based on the system clock in the JVM running the Kafka Connect task.

|7
|`ts_ns`
a|Optional field that displays the time at which the connector processed the event, in nanoseconds.
The time is based on the system clock in the JVM running the Kafka Connect task.

|===

A _delete_ change event record provides a consumer with the information it needs to process the removal of this row. The old values are included because some consumers might require them in order to properly handle the removal.

{connector-name} connector events are designed to work with link:{link-kafka-docs}/#compaction[Kafka log compaction]. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.

:leveloffset: 1

// Type: continue
[id="mariadb-tombstone-events"]
=== Tombstone events

:leveloffset: +1

When a row is deleted, the _delete_ event value still works with log compaction, because Kafka can remove all earlier messages that have that same key.
However, for Kafka to remove all messages that have that same key, the message value must be `null`.
To make this possible, after the {prodname} {connector-name} connector emits a _delete_ event, the connector emits a special tombstone event that has the same key but a `null` value.

:leveloffset: 1

// Type: continue
[id="mariadb-truncate-events"]
=== _truncate_ events

:leveloffset: +1

A  _truncate_ change event signals that a table has been truncated.
The message key of a _truncate_ event is `null`.
The message value resembles the following example:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "source": { // <1>
            "version": "{debezium-version}",
            "name": "{context}-server-1",
            "connector": "{context}",
            "name": "{context}-server-1",
            "ts_ms": 1465581029100,
            "ts_us": 1465581029100000,
            "ts_ns": 1465581029100000000,
            "snapshot": false,
            "db": "inventory",
            "table": "customers",
            "server_id": 223344,
            "gtid": null,
            "file": "{context}-bin.000003",
            "pos": 484,
            "row": 0,
            "thread": 7,
            "query": "UPDATE customers SET first_name='Anne Marie' WHERE id=1004"
        },
        "op": "t", // <2>
        "ts_ms": 1465581029523, // <3>
        "ts_us": 1465581029523468, // <4>
        "ts_ns": 1465581029523468471 // <5>
    }
}
----

.Descriptions of _truncate_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`source`
a|Mandatory field that describes the source metadata for the event. In a _truncate_ event value, the `source` field structure is the same as for _create_, _update_, and _delete_ events for the same table, provides this metadata:

* {prodname} version
* Connector type and name
* Binlog name where the event was recorded
* Binlog position
* Row within the event
* If the event was part of a snapshot
* Name of the database and table
* ID of the {connector-name} thread that truncated the event (non-snapshot only)
* {connector-name} server ID (if available)
* Timestamp for when the change was made in the database

|2
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `t`, signifying that this table was truncated.

|3
|`ts_ms`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|4
|`ts_us`
a|Optional field that displays the time at which the connector processed the event, in microseconds. The time is based on the system clock in the JVM running the Kafka Connect task.

|5
|`ts_ns`
a|Optional field that displays the time at which the connector processed the event, in nanoseconds. The time is based on the system clock in the JVM running the Kafka Connect task.

|===

In case a single `TRUNCATE` statement applies to multiple tables,
one _truncate_ change event record for each truncated table will be emitted.

[NOTE]
====
A _truncate_ event represents a change that applies to an entire table, and it does not have a message key.
In topics that span multiple partition, the order of change events that apply to an entire table is is not guaranteed.
That is, there is no ordering guarantee for (_create_, _update_, etc.), or for the _truncate_ events for that table.
When a consumer reads events from different partition, it might read an _update_ event for a table from one partition only after it reads a _truncate_ event for the same table from a second partition.
====

:leveloffset: 1

// Type: reference
// ModuleID: how-debezium-mariadb-connectors-map-data-types
// Title: How {prodname} MariaDB connectors map data types
[[mariadb-data-types]]
== Data type mappings

:leveloffset: +1


The {prodname} {connector-name} connector represents changes to rows with events that are structured like the table in which the row exists. The event contains a field for each column value.
The {connector-name} data type of that column dictates how {prodname} represents the value in the event.

Columns that store strings are defined in {connector-name} with a character set and collation.
The {connector-name} connector uses the column's character set when reading the binary representation of the column values in the binlog events.

The connector can map {connector-name} data types to both _literal_ and _semantic_ types.

* *Literal type*: how the value is represented using Kafka Connect schema types.
* *Semantic type*: how the Kafka Connect schema captures the meaning of the field (schema name).

If the default data type conversions do not meet your needs, you can {link-prefix}:{link-custom-converters}#custom-converters[create a custom converter] for the connector.


:leveloffset: 1

[id="mariadb-basic-types"]
=== Basic types

:leveloffset: +1

The following table shows how the connector maps basic {connector-name} data types.

.Descriptions of basic type mappings
[cols="25%a,20%a,55%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`BOOLEAN, BOOL`
|`BOOLEAN`
a|_n/a_

|`BIT(1)`
|`BOOLEAN`
a|_n/a_

|`BIT(>1)`
|`BYTES`
a|`io.debezium.data.Bits` +
 +
The `length` schema parameter contains an integer that represents the number of bits. The `byte[]` contains the bits in _little-endian_ form and is sized to contain the specified number of bits. For example, where `n` is bits: +
`numBytes = n/8 + (n%8== 0 ? 0 : 1)`

|`TINYINT`
|`INT16`
a|_n/a_

|`SMALLINT[(M)]`
|`INT16`
a|_n/a_

|`MEDIUMINT[(M)]`
|`INT32`
a|_n/a_

|`INT, INTEGER[(M)]`
|`INT32`
a|_n/a_

|`BIGINT[(M)]`
|`INT64`
a|_n/a_

|`REAL[(M,D)]`
|`FLOAT32`
a|_n/a_

|`FLOAT[(P)]`
|`FLOAT32` or `FLOAT64`
a|The precision is used only to determine storage size.
A precision `P` from 0 to 23 results in a 4-byte single-precision `FLOAT32` column.
A precision `P` from 24 to 53 results in an 8-byte double-precision `FLOAT64` column.

|`FLOAT(M,D)`
|`FLOAT64`
a|_n/a_

|`DOUBLE[(M,D)]`
|`FLOAT64`
a|_n/a_

|`CHAR(M)]`
|`STRING`
a|_n/a_

|`VARCHAR(M)]`
|`STRING`
a|_n/a_

|`BINARY(M)]`
|`BYTES` or `STRING`
a|_n/a_ +
 +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{context}-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`VARBINARY(M)]`
|`BYTES` or `STRING`
a|_n/a_ +
 +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{context}-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`TINYBLOB`
|`BYTES` or `STRING`
a|_n/a_ +
 +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{context}-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`TINYTEXT`
|`STRING`
a|_n/a_

|`BLOB`
|`BYTES` or `STRING`
a|_n/a_ +
 +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{context}-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting. +
 +
Only values with a size of up to 2GB are supported. It is recommended to externalize large column values, using the claim check pattern.

|`TEXT`
|`STRING`
a|_n/a_ +
 +
Only values with a size of up to 2GB are supported. It is recommended to externalize large column values, using the claim check pattern.

|`MEDIUMBLOB`
|`BYTES` or `STRING`
a|_n/a_ +
 +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{context}-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.

|`MEDIUMTEXT`
|`STRING`
a|_n/a_

|`LONGBLOB`
|`BYTES` or `STRING`
a|_n/a_ +
 +
Either the raw bytes (the default), a base64-encoded String, or a base64-url-safe-encoded String, or a hex-encoded String, based on the xref:{context}-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting. +
 +
Only values with a size of up to 2GB are supported. It is recommended to externalize large column values, using the claim check pattern.

|`LONGTEXT`
|`STRING`
a|_n/a_ +
 +
Only values with a size of up to 2GB are supported. It is recommended to externalize large column values, using the claim check pattern.

|`JSON`
|`STRING`
a|`io.debezium.data.Json` +
 +
Contains the string representation of a `JSON` document, array, or scalar.

|`ENUM`
|`STRING`
a|`io.debezium.data.Enum` +
 +
The `allowed` schema parameter contains the comma-separated list of allowed values.

|`SET`
|`STRING`
a|`io.debezium.data.EnumSet` +
 +
The `allowed` schema parameter contains the comma-separated list of allowed values.

|`YEAR[(2\|4)]`
|`INT32`
|`io.debezium.time.Year`

|`TIMESTAMP[(M)]`
|`STRING`
a|`io.debezium.time.ZonedTimestamp` +
 +
In link:https://www.iso.org/iso-8601-date-and-time-format.html[ISO 8601] format with microsecond precision.
{connector-name} allows `M` to be in the range of `0-6`.

|===

:leveloffset: 1


[id="mariadb-temporal-types"]
=== Temporal types

:leveloffset: +1

Excluding the `TIMESTAMP` data type, {connector-name} temporal types depend on the value of the `time.precision.mode` connector configuration property. For `TIMESTAMP` columns whose default value is specified as `CURRENT_TIMESTAMP` or `NOW`, the value `1970-01-01 00:00:00` is used as the default value in the Kafka Connect schema.

{connector-name} allows zero-values for `DATE`, `DATETIME`, and `TIMESTAMP` columns because zero-values are sometimes preferred over null values.
The {connector-name} connector represents zero-values as null values when the column definition allows null values, or as the epoch day when the column does not allow null values.

.Temporal values without time zones
The `DATETIME` type represents a local date and time such as "2018-01-13 09:48:27". As you can see, there is no time zone information. Such columns are converted into epoch milliseconds or microseconds based on the column’s precision by using UTC.
The `TIMESTAMP` type represents a timestamp without time zone information.
It is converted by {connector-name} from the server (or session’s) current time zone into UTC when writing and from UTC into the server (or session's) current time zone when reading back the value. For example:

* `DATETIME` with a value of `2018-06-20 06:37:03` becomes `1529476623000`.
* `TIMESTAMP` with a value of `2018-06-20 06:37:03` becomes `2018-06-20T13:37:03Z`.

Such columns are converted into an equivalent `io.debezium.time.ZonedTimestamp` in UTC based on the server (or session’s) current time zone.
The time zone will be queried from the server by default.

If this fails, it must be specified explicitly by the database `timezone` {connector-name} configuration option.
For example, if the database’s time zone (either globally or configured for the connector by means of the `timezone` option) is "America/Los_Angeles", the TIMESTAMP value "2018-06-20 06:37:03" is represented by a `ZonedTimestamp` with the value "2018-06-20T13:37:03Z".

The time zone of the JVM running Kafka Connect and {prodname} does not affect these conversions.

More details about properties related to temporal values are in the documentation for xref:{context}-connector-properties[{connector-name} connector configuration properties].

time.precision.mode=adaptive_time_microseconds(default)::
The {connector-name} connector determines the literal type and semantic type based on the column's data type definition so that events represent exactly the values in the database. All time fields are in microseconds. Only positive `TIME` field values in the range of `00:00:00.000000` to `23:59:59.999999` can be captured correctly.
+
.Mappings when `time.precision.mode=adaptive_time_microseconds`
[cols="25%a,20%a,55%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`DATE`
|`INT32`
a|`io.debezium.time.Date` +
Represents the number of days since the epoch.

|`TIME[(M)]`
|`INT64`
a|`io.debezium.time.MicroTime` +
Represents the time value in microseconds and does not include time zone information.
{connector-name} allows `M` to be in the range of `0-6`.

|`DATETIME, DATETIME(0), DATETIME(1), DATETIME(2), DATETIME(3)`
|`INT64`
a|`io.debezium.time.Timestamp` +
Represents the number of milliseconds past the epoch and does not include time zone information.

|`DATETIME(4), DATETIME(5), DATETIME(6)`
|`INT64`
a|`io.debezium.time.MicroTimestamp` +
Represents the number of microseconds past the epoch and does not include time zone information.

|===

time.precision.mode=connect::
The {connector-name} connector uses defined Kafka Connect logical types. This approach is less precise than the default approach and the events could be less precise if the database column has a _fractional second precision_ value of greater than `3`. Values in only the range of `00:00:00.000` to `23:59:59.999` can be handled. Set `time.precision.mode=connect` only if you can ensure that the `TIME` values in your tables never exceed the supported ranges. The `connect` setting is expected to be removed in a future version of {prodname}.
+
.Mappings when `time.precision.mode=connect`
[cols="25%a,20%a,55%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`DATE`
|`INT32`
a|`org.apache.kafka.connect.data.Date` +
Represents the number of days since the epoch.

|`TIME[(M)]`
|`INT64`
a|`org.apache.kafka.connect.data.Time` +
Represents the time value in microseconds since midnight and does not include time zone information.

|`DATETIME[(M)]`
|`INT64`
a|`org.apache.kafka.connect.data.Timestamp` +
Represents the number of milliseconds since the epoch, and does not include time zone information.

|===

:leveloffset: 1

[id="mariadb-decimal-types"]
=== Decimal types

:leveloffset: +1

{prodname} connectors handle decimals according to the setting of the xref:{context}-property-decimal-handling-mode[`decimal.handling.mode`] connector configuration property.

decimal.handling.mode=precise::
+
.Mappings when `decimal.handling.mode=precise`
[cols="30%a,15%a,55%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`NUMERIC[(M[,D])]`
|`BYTES`
a|`org.apache.kafka.connect.data.Decimal` +
The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.

|`DECIMAL[(M[,D])]`
|`BYTES`
a|`org.apache.kafka.connect.data.Decimal` +
The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.

|===

decimal.handling.mode=double::
+
.Mappings when `decimal.handling.mode=double`
[cols="30%a,30%a,40%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`NUMERIC[(M[,D])]`
|`FLOAT64`
a|_n/a_

|`DECIMAL[(M[,D])]`
|`FLOAT64`
a|_n/a_

|===

decimal.handling.mode=string::
+
.Mappings when `decimal.handling.mode=string`
[cols="30%a,30%a,40%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`NUMERIC[(M[,D])]`
|`STRING`
a|_n/a_

|`DECIMAL[(M[,D])]`
|`STRING`
a|_n/a_

|===

:leveloffset: 1

[id="mariadb-boolean-values"]
=== Boolean values

:leveloffset: +1

{connector-name} handles the `BOOLEAN` value internally in a specific way.
The `BOOLEAN` column is internally mapped to the `TINYINT(1)` data type.
When the table is created during streaming then it uses proper `BOOLEAN` mapping as {prodname} receives the original DDL.
During snapshots, {prodname} executes `SHOW CREATE TABLE` to obtain table definitions that return `TINYINT(1)` for both `BOOLEAN` and `TINYINT(1)` columns. {prodname} then has no way to obtain the original type mapping and so maps to `TINYINT(1)`.

To enable you to convert source columns to Boolean data types, {prodname} provides a `TinyIntOneToBooleanConverter` {link-prefix}:{link-custom-converters}#custom-converters[custom converter] that you can use in one of the following ways:

* Map all `TINYINT(1)` or `TINYINT(1) UNSIGNED` columns to `BOOLEAN` types.
* Enumerate a subset of columns by using a comma-separated list of regular expressions. +
To use this type of conversion, you must set the xref:{context}-property-converters[`converters`] configuration property with the `selector` parameter, as shown in the following example:
+
[source]
----
converters=boolean
boolean.type=io.debezium.connector.binlog.converters.TinyIntOneToBooleanConverter
boolean.selector=db1.table1.*, db1.table2.column1
----
* NOTE: In some cases, the database may not show the length of `tinyint unsigned` when the snapshot executes `SHOW CREATE TABLE`, which means this converter doesn't work. The new option `length.checker` can solve this issue, the default value is `true`. Disable the `length.checker` and specify the columns that need to be converted to `selected` property instead of converting all columns based on type, as shown in the following example:
+
[source]
----
converters=boolean
boolean.type=io.debezium.connector.binlog.converters.TinyIntOneToBooleanConverter
boolean.length.checker=false
boolean.selector=db1.table1.*, db1.table2.column1
----

:leveloffset: 1

[id="mariadb-spatial-types"]
=== Spatial types

:leveloffset: +1

Currently, the {prodname} {connector-name} connector supports the following spatial data types.

.Description of spatial type mappings
[cols="35%a,15%a,50%a",options="header",subs="+attributes"]
|===
|{connector-name} type |Literal type |Semantic type

|`GEOMETRY, +
LINESTRING, +
POLYGON, +
MULTIPOINT, +
MULTILINESTRING, +
MULTIPOLYGON, +
GEOMETRYCOLLECTION`
|`STRUCT`
a|`io.debezium.data.geometry.Geometry` +
Contains a structure with two fields:

* `srid (INT32`: spatial reference system ID that defines the type of geometry object stored in the structure
* `wkb (BYTES)`: binary representation of the geometry object encoded in the Well-Known-Binary (wkb) format. See the link:https://www.opengeospatial.org/standards/sfa[Open Geospatial Consortium] for more details.

|===

:leveloffset: 1

// Type: concept
// Title: Custom converters for mapping {connector-name} data to alternative data types
[id="debezium-mariadb-connector-converters"]
== Custom converters

:leveloffset: +1

By default, the {prodname} {connector-name} connector provides several `CustomConverter` implementations for {connector-name} data types.
These custom converters provide alternative mappings for specific data types based on the connector configuration.
To add a `CustomConverter` to the connector, follow the instructions in the {link-prefix}:{link-custom-converters}#custom-converters[Custom Converters documentation].

:leveloffset: 1

=== `TINYINT(1)` to Boolean

:leveloffset: +1

By default, during a connector snapshot, the {prodname} {connector-name} connector obtains column types from the JDBC driver, which assigns the `TINYINT(1)` type to `BOOLEAN` columns.
{prodname} then uses these JDBC column types to define the schema for the snapshot events.
After the connector transitions from the snapshot to the streaming phase, the change event schema that results from the default mapping can lead to inconsistent mappings for `BOOLEAN` columns.
To help ensure that {connector-name} emits `BOOLEAN` columns uniformly, you can apply the custom  `TinyIntOneToBooleanConverter`, as shown in the following configuration example.

.Example: `TinyIntOneToBooleanConverter` configuration
[source]
----
converters=tinyint-one-to-boolean
tinyint-one-to-boolean.type=io.debezium.connector.binlog.converters.TinyIntOneToBooleanConverter
tinyint-one-to-boolean.selector=.*.MY_TABLE.DATA
tinyint-one-to-boolean.length.checker=false
----

In the preceding example, the `selector` and `length.checker` properties are optional.
By default, the converter checks that `TINYINT` data types conform to a length of `1`.
If `length.checker` to `false`, the converter does not explicitly confirm that the `TINYINT` data type conforms to a length of `1`.
The `selector` designates the tables or columns to convert, based on the supplied regular expression.
If you omit the `selector` property, the converter maps all `TINYINT` columns to logical `BOOL` field types.
If you do not configure a `selector` option, and you want to map `TINYINT` columns to `TINYINT(1)`, omit the `length.checker` property, or set its value to `true`.

:leveloffset: 1

=== JDBC sink data types

:leveloffset: +1

If you integrate the {prodname} JDBC sink connector with a {prodname} {connector-name} source connector, the {connector-name} connector emits some column attributes differently during the snapshot and streaming phases.
For the JDBC sink connector to consistently consume changes from both the snapshot and streaming phase, you must include the `JdbcSinkDataTypesConverter` converter as part of the {connector-name} source connector configuration, as shown in the following example:

.Example: `JdbcSinkDataTypesConverter` configuration
[source]
----
converters=jdbc-sink
jdbc-sink.type=io.debezium.connector.binlog.converters.JdbcSinkDataTypesConverter
jdbc-sink.selector.boolean=.*.MY_TABLE.BOOL_COL
jdbc-sink.selector.real=.*.MY_TABLE.REAL_COL
jdbc-sink.selector.string=.*.MY_TABLE.STRING_COL
jdbc-sink.treat.real.as.double=true
----

In the preceding example, the `selector.*` and `treat.real.as.double` configuration properties are optional.

The `selector.*` properties specify comma-separated lists of regular expressions that specify which tables and columns that the converter applies to.
By default, the converter applies the following rules apply to all Boolean, real, and string-based column data types, across all tables:

* `BOOLEAN` data types are always emitted as `INT16` logical types, with `1` representing `true` and `0` representing `false`
* `REAL` data types are always emitted as `FLOAT64` logical types.
* String-based columns always include the `__debezium.source.column.character_set` schema parameter that contains the column's character set.

For each data type, you can configure a selector rule to override the default scope and apply the selector to specific tables and columns only.
For example, to set the scope of the Boolean converter, add the following rule to the connector configuration, as in the preceding example: `converters.jdbc-sink.selector.boolean=.*.MY_TABLE.BOOL_COL`

:leveloffset: 1


// Type: assembly
// ModuleID: setting-up-mariadb-to-run-a-debezium-connector
// Title: Setting up MariaDB to run a {prodname} connector
[[setting-up-mariadb]]
== Setting up MariaDB

:leveloffset: +1

Some {connector-name} setup tasks are required before you can install and run a {prodname} connector.


:leveloffset: 1

// Type: procedure
// ModuleID: creating-a-mariadb-user-for-a-debezium-connector
// Title: Creating a MariaDB user for a {prodname} connector
[[mariadb-creating-user]]
=== Creating a user

:leveloffset: +1

A {prodname} {connector-name} connector requires a {connector-name} user account.
This {connector-name} user must have appropriate permissions on all databases for which the {prodname} {connector-name} connector captures changes.

.Prerequisites

* A {connector-name} server.
* Basic knowledge of SQL commands.

.Procedure

. Create the {connector-name} user:
+
[source,SQL,subs="+attributes"]
----
{context}> CREATE USER 'user'@'localhost' IDENTIFIED BY 'password';
----

. Grant the required permissions to the user:
+
[source,SQL,subs="+attributes"]
----
{context}> GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'user' IDENTIFIED BY 'password';
----
+
For a description of the required permissions, see xref:permissions-explained-{context}-connector[].
+
IMPORTANT: If using a hosted option such as Amazon RDS or Amazon Aurora that does not allow a global read lock, table-level locks are used to create the _consistent snapshot_. In this case, you need to also grant `LOCK TABLES` permissions to the user that you create. See xref:{context}-snapshots[snapshots] for more details.

. Finalize the user's permissions:
+
[source,SQL,subs="+attributes"]
----
{context}> FLUSH PRIVILEGES;
----

+
[id="permissions-explained-{context}-connector"]
.Descriptions of user permissions
[cols="3,7",options="header",subs="+attributes"]
|===
|Keyword |Description

|`SELECT`
|Enables the connector to select rows from tables in databases. This is used only when performing a snapshot.

|`RELOAD`
|Enables the connector the use of the `FLUSH` statement to clear or reload internal caches, flush tables, or acquire locks. This is used only when performing a snapshot.

|`SHOW DATABASES`
|Enables the connector to see database names by issuing the `SHOW DATABASE` statement. This is used only when performing a snapshot.

|`REPLICATION SLAVE`
|Enables the connector to connect to and read the {connector-name} server binlog.

|`REPLICATION CLIENT`
a|Enables the connector the use of the following statements:

* `SHOW MASTER STATUS`
* `SHOW SLAVE STATUS`
* `SHOW BINARY LOGS`

The connector always requires this.

|`ON`
|Identifies the database to which the permissions apply.

|`TO 'user'`
|Specifies the user to grant the permissions to.

|`IDENTIFIED BY 'password'`
|Specifies the user's {connector-name} password.

|===


:leveloffset: 1

// Type: procedure
// ModuleID: enabling-the-mariadb-binlog-for-debezium
// Title: Enabling the MariaDB binlog for {prodname}
[[enable-mariadb-binlog]]
=== Enabling the binlog

:leveloffset: +1

You must enable binary logging for {connector-name} replication.
The binary logs record transaction updates in a way that enables replicas to propagate those changes.

.Prerequisites

* A {connector-name} server.
* Appropriate {connector-name} user privileges.

.Procedure

. Check whether the `log-bin` option is enabled:
+
[source,SQL]
----
mariadb> SHOW VARIABLES LIKE '%log_bin%';
----
[source,SQL]
----
// for MySQL 5.x
mysql> SELECT variable_value as "BINARY LOGGING STATUS (log-bin) ::"
FROM information_schema.global_variables WHERE variable_name='log_bin';
// for MySQL 8.x
mysql> SELECT variable_value as "BINARY LOGGING STATUS (log-bin) ::"
FROM performance_schema.global_variables WHERE variable_name='log_bin';
----
. If the binlog is `OFF`, add the properties in the following table to the configuration file for the {connector-name} server:
+
[source,properties,subs="+attributes"]
----
server-id         = 223344 # Querying variable is called server_id, e.g. SELECT variable_value FROM information_schema.global_variables WHERE variable_name='server_id';
log_bin                     = {context}-bin
binlog_format               = ROW
binlog_row_image            = FULL
binlog_expire_logs_seconds  = 864000
----

. Confirm your changes by checking the binlog status once more:
+
[source,SQL,subs="+attributes"]
----
{context}> SHOW VARIABLES LIKE '%log_bin%';
----
[source,SQL]
----
// for MySQL 5.x
{context}> SELECT variable_value as "BINARY LOGGING STATUS (log-bin) ::"
FROM information_schema.global_variables WHERE variable_name='log_bin';
// for MySQL 8.x
{context}> SELECT variable_value as "BINARY LOGGING STATUS (log-bin) ::"
FROM performance_schema.global_variables WHERE variable_name='log_bin';
----
. If you run {connector-name} on Amazon RDS, you must enable automated backups for your database instance for binary logging to occur.
If the database instance is not configured to perform automated backups, the binlog is disabled, even if you apply the settings described in the previous steps.

+
[id="binlog-configuration-properties-{context}-connector"]
.Descriptions of {connector-name} binlog configuration properties
[cols="1,4",options="header",subs="+attributes"]
|===
|Property |Description

|`server-id`
|The value for the `server-id` must be unique for each server and replication client in the {connector-name} cluster.

|`log_bin`
|The value of `log_bin` is the base name of the sequence of binlog files.

|`binlog_format`
|The `binlog-format` must be set to `ROW` or `row`.

|`binlog_row_image`
|The `binlog_row_image` must be set to `FULL` or `full`.

|`binlog_expire_logs_seconds`
|The `binlog_expire_logs_seconds` corresponds to deprecated system variable `expire_logs_days`.
This is the number of seconds for automatic binlog file removal.
The default value is `2592000`, which equals 30 days.
Set the value to match the needs of your environment.
For more information, see xref:{context}-purges-binlog-files-used-by-debezium[{connector-name} purges binlog files].

|===


:leveloffset: 1


// Type: procedure
// ModuleID: enabling-mariadb-gtids-for-debezium
// Title: Enabling MariaDB Global Transaction Identifiers for {prodname}
[[enable-mariadb-gtids]]
=== Enabling GTIDs

Global transaction identifiers (GTIDs) uniquely identify transactions that occur on a server within a cluster.
Although not required for a {prodname} MariaDB connector, using GTIDs simplifies replication and enables you to more easily confirm if primary and replica servers are consistent.

For MariaDB, GTIDs are enabled by default and no additional configuration is necessary.

// Type: procedure
// ModuleID: configuring-mariadb-session-timeouts-for-debezium
// Title: Configuring MariaDB session timeouts for {prodname}
[[mariadb-session-timeouts]]
=== Configuring session timeouts

:leveloffset: +1

When an initial consistent snapshot is made for large databases, your established connection could timeout while the tables are being read.
You can prevent this behavior by configuring `interactive_timeout` and `wait_timeout` in your {connector-name} configuration file.

.Prerequisites

* A {connector-name} server.
* Basic knowledge of SQL commands.
* Access to the {connector-name} configuration file.

.Procedure

. Configure `interactive_timeout`:
+
[source,SQL,subs="+attributes,+quotes"]
----
{context}> interactive_timeout=<duration-in-seconds>
----

. Configure `wait_timeout`:
+
[source,SQL,subs="+attributes,+quotes"]
----
{context}> wait_timeout=<duration-in-seconds>
----

+
.Descriptions of {connector-name} session timeout options
[cols="3,7",options="header",subs="+attributes"]
|===
|Option |Description

|`interactive_timeout`
a|The number of seconds the server waits for activity on an interactive connection before closing it.
For more information see the:
link:https://mariadb.com/kb/en/server-system-variables/#interactive_timeout[MariaDB documentation].
link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_interactive_timeout[MySQL documentation].
|`wait_timeout`
a|The number of seconds that the server waits for activity on a non-interactive connection before closing it.
For more information, see the link:https://mariadb.com/kb/en/server-system-variables/#wait_timeout[MariaDB documentation].
For more information, see the link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_interactive_timeout[MySQL documentation].
|===

:leveloffset: 1

// Type: procedure
// ModuleID: enabling-query-log-events-for-debezium-mariadb-connectors
// Title: Enabling query log events for {prodname} MariaDB connectors
[[enable-query-log-events]]
=== Enabling query log events

You might want to see the original `SQL` statement for each binlog event.
Enabling the `binlog_annotate_row_events` option in the MariaDB configuration allows you to do this.

.Prerequisites

* A MariaDB server.
* Basic knowledge of SQL commands.
* Access to the MariaDB configuration file.

.Procedure

* Enable `binlog_annotate_row_events` in MariaDB:
+
[source,SQL]
----
mariadb> binlog_annotate_row_events=ON
----
+
`binlog_annotate_row_events` is set to a value that enables/disables support for including the original `SQL` statement in the binlog entry.
+
** `ON` = enabled
** `OFF` = disabled

// Type: procedure
// ModuleID: validate-binlog-row-value-options-for-debezium-mariadb-connectors
// Title: validate binlog row value options for {prodname} MariaDB connectors
[[validate-binlog-row-value-options]]
=== Validating binlog row value options

:leveloffset: +1

Verify the setting of the `binlog_row_value_options` variable in the database.
To enable the connector to consume *UPDATE* events, this variable must be set to a value other than `PARTIAL_JSON`.

.Prerequisites

* A {connector-name} server.
* Basic knowledge of SQL commands.
* Access to the {connector-name} configuration file.

.Procedure

. Check current variable value
+
[source,SQL,subs="+attributes,+quotes"]
----
{context}> show global variables where variable_name = 'binlog_row_value_options';
----

+
.Result
+
[source,SQL]
----
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| binlog_row_value_options |       |
+--------------------------+-------+
----

. If the value of the variable is set to `PARTIAL_JSON`, run the following command to unset it:
+
[source,SQL,subs="+attributes,+quotes"]
----
{context}> set @@global.binlog_row_value_options="" ;
----

:leveloffset: 1


// Type: assembly
// ModuleID: deployment-of-debezium-mariadb-connectors
// Title: Deployment of {prodname} MariaDB connectors
[[mariadb-deploying-a-connector]]
== Deployment

:leveloffset: +1

To deploy a {prodname} {connector-name} connector, you install the {prodname} {connector-name} connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect.

.Prerequisites
* link:https://zookeeper.apache.org/[Apache Zookeeper], link:http://kafka.apache.org/[Apache Kafka], and link:{link-kafka-docs}.html#connect[Kafka Connect] are installed.
* {connector-name} Server is installed and is xref:setting-up-{context}[set up to work with the {prodname} connector].

.Procedure

. Download the {prodname} link:https://repo1.maven.org/maven2/io/debezium/debezium-connector-mariadb/{debezium-version}/debezium-connector-mariadb-{debezium-version}-plugin.tar.gz[MariaDB connector plug-in].
. Download the {prodname} link:https://repo1.maven.org/maven2/io/debezium/debezium-connector-mysql/{debezium-version}/debezium-connector-mysql-{debezium-version}-plugin.tar.gz[MySQL connector plug-in].
. Extract the files into your Kafka Connect environment.
. Add the directory with the JAR files to {link-kafka-docs}/#connectconfigs[Kafka Connect's `plugin.path`].
. xref:{context}-example-configuration[Configure the connector] and xref:{context}-adding-configuration[add the configuration to your Kafka Connect cluster.]
. Restart your Kafka Connect process to pick up the new JAR files.

If you are working with immutable containers, see link:https://quay.io/organization/debezium[{prodname}'s Container images] for Apache Zookeeper, Apache Kafka, {connector-name}, and Kafka Connect with the {connector-name} connector already installed and ready to run.

You can also xref:operations/openshift.adoc[run {prodname} on Kubernetes and OpenShift].


:leveloffset: 1


[[mariadb-example-configuration]]
=== MariaDB connector configuration example

:leveloffset: +1

Following is an example of the configuration for a connector instance that captures data from a {connector-name} server on port 3306 at 192.168.99.100, which we logically name `fullfillment`.
Typically, you configure the {prodname} {connector-name} connector in a JSON file by setting the configuration properties that are available for the connector.

You can choose to produce events for a subset of the schemas and tables in a database.
Optionally, you can ignore, mask, or truncate columns that contain sensitive data, that are larger than a specified size, or that you do not need.

[source,json]
----
{
    "name": "inventory-connector", // <1>
    "config": {
        "connector.class": "io.debezium.connector.{context}.{connector-name}Connector", // <2>
        "database.hostname": "192.168.99.100", // <3>
        "database.port": "3306", // <4>
        "database.user": "debezium-user", // <5>
        "database.password": "debezium-user-pw", // <6>
        "database.server.id": "184054", <7>
        "topic.prefix": "fullfillment", // <8>
        "database.include.list": "inventory", // <9>
        "schema.history.internal.kafka.bootstrap.servers": "kafka:9092", // <10>
        "schema.history.internal.kafka.topic": "schemahistory.fullfillment", // <11>
        "include.schema.changes": "true" // <12>
    }
}
----
<1> Connector's name when registered with the Kafka Connect service.
<2> Connector's class name.
<3> {connector-name} server address.
<4> {connector-name} server port number.
<5> {connector-name} user with the appropriate privileges.
<6> {connector-name} user's password.
<7> Unique ID of the connector.
<8> Topic prefix for the {connector-name} server or cluster.
<9> List of databases hosted by the specified server.
<10> List of Kafka brokers that the connector uses to write and recover DDL statements to the database schema history topic.
<11> Name of the database schema history topic. This topic is for internal use only and should not be used by consumers.
<12> Flag that specifies if the connector should generate events for DDL changes and emit them to the `fulfillment` schema change topic for use by consumers.


For the complete list of the configuration properties that you can set for the {prodname} {connector-name} connector,
see xref:{context}-connector-properties[{connector-name} connector configuration properties].

You can send this configuration with a `POST` command to a running Kafka Connect service.
The service records the configuration and starts one connector task that performs the following actions:

* Connects to the {connector-name} database.
* Reads change-data tables for tables in capture mode.
* Streams change event records to Kafka topics.

:leveloffset: 1

[[mariadb-adding-configuration]]
=== Adding connector configuration

:leveloffset: +1

To start running a {connector-name} connector, configure a connector configuration, and add the configuration to your Kafka Connect cluster.

.Prerequisites

* xref:setting-up-{context}[{connector-name} is set up to work with a {prodname} connector].
* The {prodname} {connector-name} connector is installed.

.Procedure

. Create a configuration for the {connector-name} connector.

. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster.

.Results
After the connector starts, it xref:{context}-snapshots[performs a consistent snapshot] of the {connector-name} databases that the connector is configured for.
The connector then starts generating data change events for row-level operations and streaming change event records to Kafka topics.


:leveloffset: 1


// Type: reference
// Title: Descriptions of {prodname} MariaDB connector configuration properties
[[mariadb-connector-properties]]
=== Connector properties

:leveloffset: +1

The {prodname} {connector-name} connector has numerous configuration properties that you can use to achieve the right connector behavior for your application.
Many properties have default values.
Information about the properties is organized as follows:

* xref:{context}-required-connector-configuration-properties[Required connector configuration properties]
* xref:{context}-advanced-connector-configuration-properties[Advanced connector configuration properties]
* xref:debezium-{context}-connector-database-history-configuration-properties[Database schema history connector configuration properties] that control how {prodname} processes events that it reads from the database schema history topic.
** xref:{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[Pass-through database schema history properties]
* xref:debezium-{context}-connector-pass-through-database-driver-configuration-properties[Pass-through database driver properties] that control the behavior of the database driver.


:leveloffset: 1

[id="mariadb-required-connector-configuration-properties"]
==== Required {prodname} MariaDB connector configuration properties

:leveloffset: +1

The following configuration properties are _required_ unless a default value is available.

[id="{context}-property-bigint-unsigned-handling-mode"]
xref:{context}-property-bigint-unsigned-handling-mode[`bigint.unsigned.handling.mode`]::
 +
Default value: `long` +
Specifies how the connector represents BIGINT UNSIGNED columns in change events.
Set one of the following options:

`long`::: Uses Java `long` data types to represent BIGINT UNSIGNED column values.
Although the `long` type does not offer the greatest precision, it is easy implement in most consumers.
In most environments, this is the preferred setting.

`precise`::: Uses `java.math.BigDecimal` data types to represent values.
The connector uses the Kafka Connect `org.apache.kafka.connect.data.Decimal` data type to represent values in encoded binary format.
Set this option if the connector typically works with values larger than 2^63.
The `long` data type cannot convey values of that size.



[id="{context}-property-binary-handling-mode"]
xref:{context}-property-binary-handling-mode[`binary.handling.mode`]::
Default value: `bytes` +
Specifies how the connector represents values for binary columns, such as, `blob`, `binary`, `varbinary`, in change events. +
Set one of the following options:
`bytes`::: Represents binary data as a byte array.

`base64`::: Represents binary data as a base64-encoded String.

`base64-url-safe`::: Represents binary data as a base64-url-safe-encoded String.

`hex`::: Represents binary data as a hex-encoded (base16) String.


[id="{context}-property-column-exclude-list"]
xref:{context}-property-column-exclude-list[`column.exclude.list`]::
Default value: _empty string_ +
An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to exclude from change event record values.
Other columns in the source record are captured as usual.
Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_. +
+
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; it does not match substrings that might be present in a column name.
If you include this property in the configuration, do not also set the `column.include.list` property.



[id="{context}-property-column-include-list"]
xref:{context}-property-column-include-list[`column.include.list`]::
Default value:  _empty string_ +
An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to include in change event record values.
Other columns are omitted from the event record.
Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_. +
+
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; it does not match substrings that might be present in a column name. +
If you include this property in the configuration, do not set the `column.exclude.list` property.

////
[id="{context}-property-column-mask-hash"]
[id="{context}-property-column-mask-hash-v2"]
xref:{context}-property-column-mask-hash[`column.mask.hash._hashAlgorithm_.with.salt._salt_`] +
xref:{context}-property-column-mask-hash-v2[`column.mask.hash.v2._hashAlgorithm_.with.salt._salt_`]::
////
[id="{context}-property-column-mask-hash"]
xref:{context}-property-column-mask-hash[`column.mask.hash._hashAlgorithm_.with.salt._salt_`]::
[id="{context}-property-column-mask-hash-v2"]
xref:{context}-property-column-mask-hash-v2[`column.mask.hash.v2._hashAlgorithm_.with.salt._salt_`]::
Default value: No default +
An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Fully-qualified names for columns are of the form `_<databaseName>_._<tableName>_._<columnName>_`. +
To match the name of a column {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.
In the resulting change event record, the values for the specified columns are replaced with pseudonyms.
 +
A pseudonym consists of the hashed value that results from applying the specified _hashAlgorithm_ and _salt_.
Based on the hash function that is used, referential integrity is maintained, while column values are replaced with pseudonyms.
Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation. +
+
In the following example, `CzQMA0cB5K` is a randomly selected salt.
+
----
column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName
----
+
If necessary, the pseudonym is automatically shortened to the length of the column.
The connector configuration can include multiple properties that specify different hash algorithms and salts. +
+
Depending on the _hashAlgorithm_ used, the _salt_ selected, and the actual data set, the resulting data set might not be completely masked. +
+
Hashing strategy version 2 ensures fidelity of values that are hashed in different places or systems.



[id="{context}-property-column-mask-with-length-chars"]
xref:{context}-property-column-mask-with-length-chars[`column.mask.with._length_.chars`]::
Default value: No default +
An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want the connector to mask the values for a set of columns, for example, if they contain sensitive data.
Set `_length_` to a positive integer to replace data in the specified columns with the number of asterisk (`*`) characters specified by the _length_ in the property name.
Set _length_ to `0` (zero) to replace data in the specified columns with an empty string.
+
The fully-qualified name of a column observes the following format: _databaseName_._tableName_._columnName_.
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.
+
You can specify multiple properties with different lengths in a single configuration.



[id="{context}-property-column-propagate-source-type"]
xref:{context}-property-column-propagate-source-type[`column.propagate.source.type`]::
Default value: No default +
An optional, comma-separated list of regular expressions that match the fully-qualified names of columns for which you want the connector to emit extra parameters that represent column metadata.
When this property is set, the connector adds the following fields to the schema of event records:

* `pass:[_]pass:[_]debezium.source.column.type`
* `pass:[_]pass:[_]debezium.source.column.length`
* `pass:[_]pass:[_]debezium.source.column.scale` +
 +
These parameters propagate a column's original type name and length (for variable-width types), respectively. +
Enabling the connector to emit this extra data can assist in properly sizing specific numeric or character-based columns in sink databases. +
 +
The fully-qualified name of a column observes one of the following formats: _databaseName_._tableName_._columnName_, or _databaseName_._schemaName_._tableName_._columnName_. +
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.



[id="{context}-property-column-truncate-to-length-chars"]
xref:{context}-property-column-truncate-to-length-chars[`column.truncate.to._length_.chars`]::
Default value: No default +
An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want to truncate the data in a set of columns when it exceeds the number of characters specified by the _length_ in the property name.
Set `length` to a positive integer value, for example, `column.truncate.to.20.chars`.
+
The fully-qualified name of a column observes the following format: _databaseName_._tableName_._columnName_.
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.
+
You can specify multiple properties with different lengths in a single configuration.



[id="{context}-property-connect-timeout-ms"]
xref:{context}-property-connect-timeout-ms[`connect.timeout.ms`]::
Default value: `30000` (30 seconds) +
A positive integer value that specifies the maximum time in milliseconds that the connector waits to establish a connection to the {connector-name} database server before the connection request times out.



[id="{context}-property-connector-class"]
xref:{context}-property-connector-class[`connector.class`]::
Default value: No default +
The name of the Java class for the connector.
Always specify
`io.debezium.connector.mariadb.MariaDbConnector`
`io.debezium.connector.mysql.MySqlConnector`
for the {connector-name} connector.


[id="{context}-property-database-exclude-list"]
xref:{context}-property-database-exclude-list[`database.exclude.list`]::
Default value: _empty string_ +
An optional, comma-separated list of regular expressions that match the names of databases from which you do not want the connector to capture changes.
The connector captures changes in any database that is not named in the `database.exclude.list`. +
+
To match the name of a database, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the database; it does not match substrings that might be present in a database name. +
If you include this property in the configuration, do not also set the `database.include.list` property.


[id="{context}-property-database-hostname"]
xref:{context}-property-database-hostname[`database.hostname`]::
Default value: No default +
The IP address or hostname of the {connector-name} database server.



[id="{context}-property-database-include-list"]
xref:{context}-property-database-include-list[`database.include.list`]::
Default value: _empty string_ +
An optional, comma-separated list of regular expressions that match the names of the databases from which the connector captures changes.
The connector does not capture changes in any database whose name is not in `database.include.list`.
By default, the connector captures changes in all databases. +
+
To match the name of a database, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the database; it does not match substrings that might be present in a database name. +
If you include this property in the configuration, do not also set the `database.exclude.list` property.


[id="{context}-property-database-jdbc-driver"]
xref:{context}-property-database-jdbc-driver[`database.jdbc.driver`]::
Default value: `com.mysql.cj.jdbc.Driver` +
Specifies the name of the driver class that the connector uses.
You can use this setting to specify a driver other than the one that is packaged with the connector.


[id="{context}-property-database-password"]
xref:{context}-property-database-password[`database.password`]::
Default value: No default +
The password of the {connector-name} user that the connector uses to connect to the {connector-name} database server.


[id="{context}-property-database-port"]
xref:{context}-property-database-port[`database.port`]::
Default value: `3306` +
Integer port number of the {connector-name} database server.


[id="{context}-property-database-protocol"]
xref:{context}-property-database-protocol[`database.protocol`]::
Default value: `jdbc:mysql` +
Specifies the JDBC protocol that the driver connection string uses to connect to the database.


[id="{context}-property-database-server-id"]
xref:{context}-property-database-server-id[`database.server.id`]::
Default value: No default +
The numeric ID of this database client.
The specified ID must be unique across all currently running database processes in the {connector-name} cluster.
To enable it to read the binlog, the connector uses this unique ID to join the {connector-name} database cluster as another server.



[id="{context}-property-database-user"]
xref:{context}-property-database-user[`database.user`]::
Default value: No default +
The name of the {connector-name} user that the connector uses to connect to the {connector-name} database server.



[id="{context}-property-decimal-handling-mode"]
xref:{context}-property-decimal-handling-mode[`decimal.handling.mode`]::
Default value: `precise` +
Specifies how the connector handles values for `DECIMAL` and `NUMERIC` columns in change events. +
Set one of the following options:

`precise` (default)::: Uses `java.math.BigDecimal` values in binary form to represent values precisely.

`double`::: Uses the `double` data type to represent values.
This option can result in a loss of precision, but it is easier for most consumers to use.

`string`::: Encodes values as formatted strings.
This option is easy to consume, but can result in the loss of semantic information about the real type.




[id="{context}-property-event-deserialization-failure-handling-mode"]
xref:{context}-property-event-deserialization-failure-handling-mode[`event.deserialization.failure.handling.mode`]::
Default value: `fail` +
Specifies how the connector reacts after an exception occurs during deserialization of binlog events.
This option is deprecated, please use xref:{context}-property-event-processing-failure-handling-mode[`event.processing.failure.handling.mode`] option instead.

`fail`::: Propagates the exception, which indicates the problematic event and its binlog offset, and causes the connector to stop.

`warn`::: Logs the problematic event and its binlog offset and then skips the event.

`ignore`::: Passes over the problematic event and does not log anything.



[id="{context}-property-field-name-adjustment-mode"]
xref:{context}-property-field-name-adjustment-mode[`field.name.adjustment.mode`]::
Default value: No default +
Specifies how field names should be adjusted for compatibility with the message converter used by the connector.
Set one of the following options:

`none`::: No adjustment.
`avro`::: Replaces characters that are not valid in Avro names with underscore characters.
`avro_unicode`::: Replaces underscore characters or characters that cannot be used in Avro names with corresponding unicode, such as `$$_$$uxxxx`. +
+
[NOTE]
====
 `_` is an escape sequence, similar to a backslash in Java
====
+
For more information, see: {link-prefix}:{link-avro-serialization}#avro-naming[Avro naming].



[id="{context}-property-gtid-source-excludes"]
xref:{context}-property-gtid-source-excludes[`gtid.source.excludes`]::
Default value: No default +
A comma-separated list of regular expressions that match source domain IDs in the GTID set that the connector uses to find the binlog position on the {connector-name} server.
When this property is set, the connector uses only the GTID ranges that have source UUIDs that do not match any of the specified `exclude` patterns. +
 +
To match the value of a GTID, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the GTID's domain identifier. +
If you include this property in the configuration, do not also set the `gtid.source.includes` property.



[id="{context}-property-gtid-source-includes"]
xref:{context}-property-gtid-source-includes[`gtid.source.includes`]::
Default value: No default +
A comma-separated list of regular expressions that match source domain IDs in the GTID set used that the connector uses to find the binlog position on the {connector-name} server.
When this property is set, the connector uses only the GTID ranges that have source UUIDs that match one of the specified `include` patterns. +
 +
To match the value of a GTID, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the GTID's domain identifier. +
If you include this property in the configuration, do not also set the `gtid.source.excludes` property.


[id="{context}-property-include-query"]
xref:{context}-property-include-query[`include.query`]::
Default value: `false` +
Boolean value that specifies whether the connector should include the original SQL query that generated the change event. +
 +
If you set this option to `true` then you must also configure {connector-name} with the `binlog_annotate_row_events` option set to `ON`.
When `include.query` is `true`, the query is not present for events that the snapshot process generates. +
 +
Setting `include.query` to `true` might expose tables or fields that are explicitly excluded or masked by including the original SQL statement in the change event.
For this reason, the default setting is `false`. +
 +
For more information about configuring the database to return the original `SQL` statement for each log event, see xref:enable-query-log-events[Enabling query log events].




[id="{context}-property-include-schema-changes"]
xref:{context}-property-include-schema-changes[`include.schema.changes`]::
Default value: `true` +
Boolean value that specifies whether the connector publishes changes that occur to the database schema to a Kafka topic with the name of the database server ID.
Each schema change event that the connector captures uses a key that contains the database name and a value that includes the DDL statements that describe the change.
This setting does not affect how the connector records schema changes in its internal database schema history.



[id="{context}-property-include-schema-comments"]
xref:{context}-property-include-schema-comments[`include.schema.comments`]::
Default value: `false` +
Boolean value that specifies whether the connector parses and publishes table and column comments on metadata objects. +
+
NOTE: When you set this option to `true`, the schema comments that the connector includes can add a significant amount of string data to each schema object.
Increasing the number and size of logical schema objects increases the amount of memory that the connector uses.



[id="{context}-property-inconsistent-schema-handling-mode"]
xref:{context}-property-inconsistent-schema-handling-mode[`inconsistent.schema.handling.mode`]::
Default value: `fail` +
Specifies how the connector responds to binlog events that refer to tables that are not present in the internal schema representation.
That is, the internal representation is not consistent with the database. +
Set one of the following options:

`fail`::: The connector throws an exception that reports the problematic event and its binlog offset.
The connector then stops.

`warn`::: The connector logs the problematic event and its binlog offset, and then skips the event.

`skip`::: The connector skips the problematic event and does not report it in the log.



[id="{context}-property-message-key-columns"]
xref:{context}-property-message-key-columns[`message.key.columns`]::
Default value: No default +
A list of expressions that specify the columns that the connector uses to form custom message keys for change event records that it publishes to the Kafka topics for specified tables. +
By default, {prodname} uses the primary key column of a table as the message key for records that it emits.
In place of the default, or to specify a key for tables that lack a primary key, you can configure custom message keys based on one or more columns.
 +
To establish a custom message key for a table, list the table, followed by the columns to use as the message key.
Each list entry takes the following format: +
 +
`_<fully-qualified_tableName>_:__<keyColumn>__,_<keyColumn>_` +
 +
To base a table key on multiple column names, insert commas between the column names.
 +
Each fully-qualified table name is a regular expression in the following format:
 +
`_<databaseName>_._<tableName>_` +
 +
The property can include entries for multiple tables.
Use a semicolon to separate table entries in the list. +
 +
The following example sets the message key for the tables `inventory.customers` and `purchase.orders`: +
 +
`inventory.customers:pk1,pk2;(.*).purchaseorders:pk3,pk4` +
 +
For the table `inventory.customer`, the columns `pk1` and `pk2` are specified as the message key.
For the `purchaseorders` tables in any database, the columns `pk3` and `pk4` server as the message key.
 +
There is no limit to the number of columns that you use to create custom message keys.
However, it's best to use the minimum number that are required to specify a unique key.



[id="{context}-property-name"]
xref:{context}-property-name[`name`]::
Default value: No default +
Unique name for the connector.
If you attempt to use the same name to register another connector, registration fails.
This property is required by all Kafka Connect connectors.


[id="{context}-property-schema-name-adjustment-mode"]
xref:{context}-property-schema-name-adjustment-mode[`schema.name.adjustment.mode`]::
Default value: No default +
Specifies how the connector adjusts schema names for compatibility with the message converter used by the connector.
Set one of the following options:

`none`::: No adjustment.
`avro`::: Replaces characters that are not valid in Avro names with underscore characters.
`avro_unicode`::: Replaces underscore characters or characters that cannot be used in Avro names with corresponding unicode, such as `$$_$$uxxxx.` +
 +
NOTE: `_` is an escape sequence, similar to a backslash in Java



[id="{context}-property-skip-messages-without-change"]
xref:{context}-property-skip-messages-without-change[`skip.messages.without.change`]::
Default value: `false` +
Specifies whether the connector emits messages for records when it does not detect a change in the included columns.
Columns are considered to be included if they are listed in the `column.include.list`, or are not listed in the `column.exclude.list`.
Set the value to `true` to prevent the connector from capturing records when no changes are present in the included columns.


[id="{context}-property-table-exclude-list"]
xref:{context}-property-table-exclude-list[`table-exclude-list`]::
Default value: _empty string_ +
An optional, comma-separated list of regular expressions that match fully-qualified table identifiers of tables from which you do not want the connector to capture changes.
The connector captures changes in any table that is not included in `table.exclude.list`.
Each identifier is of the form _databaseName_._tableName_. +
+
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name. +
If you include this property in the configuration, do not also set the `table.include.list` property.



[id="{context}-property-table-include-list"]
xref:{context}-property-table-include-list[`table.include.list`]::
Default value: _empty string_ +
An optional, comma-separated list of regular expressions that match fully-qualified table identifiers of tables whose changes you want to capture.
The connector does not capture changes in any table that is not included in `table.include.list`.
Each identifier is of the form _databaseName_._tableName_.
By default, the connector captures changes in all non-system tables in every database from which it is configured to captures changes. +
+
To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name. +
If you include this property in the configuration, do not also set the `table.exclude.list` property.



[id="{context}-property-tasks-max"]
xref:{context}-property-tasks-max[`tasks.max`]::
Default value: `1` +
The maximum number of tasks to create for this connector.
Because the {connector-name} connector always uses a single task, changing the default value has no effect.




[id="{context}-property-time-precision-mode"]
xref:{context}-property-time-precision-mode[`time.precision.mode`]::
Default value: `adaptive_time_microseconds` +
Specifies the type of precision that the connector uses to represent time, date, and timestamps values.
Set one of the following options: +
+
`adaptive_time_microseconds` (default)::: The connector captures the date, datetime and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type, with the exception of TIME type fields, which are always captured as microseconds. +
+
`adaptive` (deprecated)::: The connector captures time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the data type of the column. +
+
`connect`::: The connector always represents time and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which use millisecond precision regardless of the database columns' precision.



[id="{context}-property-tombstones-on-delete"]
xref:{context}-property-tombstones-on-delete[`tombstones.on.delete`]::
Default value: `true` +
Specifies whether a _delete_ event is followed by a tombstone event.
After a source record is deleted, the connector can emit a tombstone event (the default behavior) to enable Kafka to completely delete all events that pertain to the key of the deleted row in case {link-kafka-docs}/#compaction[log compaction] is enabled for the topic.
Set one of the following options: +
+
`true` (default)::: The connector represents delete operations by emitting a _delete_ event and a subsequent tombstone event. +

`false`::: The connector emits only _delete_ events. +



[id="{context}-property-topic-prefix"]
xref:{context}-property-topic-prefix[`topic.prefix`]::
Default value: No default +
Topic prefix that provides a namespace for the particular {connector-name} database server or cluster in which {prodname} is capturing changes.
Because the topic prefix is used to name all of the Kafka topics that receive events that this connector emits, it's important that the topic prefix is unique across all connectors.
Values must contain only alphanumeric characters, hyphens, dots, and underscores. +
+
[WARNING]
====
After you set this property, do not change its value.
If you change the value, after the connector restarts, instead of continuing to emit events to the original topics, the connector emits subsequent events to topics whose names are based on the new value.
The connector is also unable to recover its database schema history topic.
====

:leveloffset: 1

[id="mariadb-advanced-connector-configuration-properties"]
==== Advanced {prodname} MariaDB connector configuration properties

:leveloffset: +1

The following list describes advanced {connector-name} connector configuration properties.
The default values for these properties rarely require changes.
Therefore, you do not need to specify them in the connector configuration.

[id="{context}-property-binlog-buffer-size"]
xref:{context}-property-binlog-buffer-size[`binlog.buffer.size`]::
*Default value:* `0` +
The size of a look-ahead buffer used by the binlog reader.
The default setting of `0` disables buffering. +
+
Under specific conditions, it is possible that the {connector-name} binlog contains uncommitted data finished by a `ROLLBACK` statement.
Typical examples are using savepoints or mixing temporary and regular table changes in a single transaction. +
+
When a beginning of a transaction is detected then {prodname} tries to roll forward the binlog position and find either `COMMIT` or `ROLLBACK` so it can determine whether to stream the changes from the transaction.
The size of the binlog buffer defines the maximum number of changes in the transaction that {prodname} can buffer while searching for transaction boundaries.
If the size of the transaction is larger than the buffer then {prodname} must rewind and re-read the events that have not fit into the buffer while streaming. +
+
NOTE: This feature is incubating. Feedback is encouraged. It is expected that this feature is not completely polished.


[id="{context}-property-connect-keep-alive"]
xref:{context}-property-connect-keep-alive[`connect.keep.alive`]::
Default value: `true` +
A Boolean value that specifies whether a separate thread should be used to ensure that the connection to the {connector-name} server or cluster is kept alive.


[id="{context}-property-converters"]
xref:{context}-property-converters[`converters`]::
Default value: No default +
Enumerates a comma-separated list of the symbolic names of the {link-prefix}:{link-custom-converters}#custom-converters[custom converter] instances that the connector can use. +
For example, `boolean`. +
This property is required to enable the connector to use a custom converter.
 +
For each converter that you configure for a connector, you must also add a `.type` property, which specifies the fully-qualified name of the class that implements the converter interface.
The `.type` property uses the following format: +
+
`_<converterSymbolicName>_.type`
+
For example, +
+
 boolean.type: io.debezium.connector.binlog.converters.TinyIntOneToBooleanConverter
+
If you want to further control the behavior of a configured converter, you can add one or more configuration parameters to pass values to the converter.
To associate these additional configuration parameter with a converter, prefix the parameter name with the symbolic name of the converter. +
+
For example, to define a `selector` parameter that specifies the subset of columns that the `boolean` converter processes, add the following property: +

 boolean.selector=db1.table1.*, db1.table2.column1



[id="{context}-property-custom-metric-tags"]
xref:{context}-property-custom-metric-tags[`custom.metric.tags`]::
Default value: No default +
Defines tags that customize MBean object names by adding metadata that provides contextual information.
Specify a comma-separated list of key-value pairs.
Each key represents a tag for the MBean object name, and the corresponding value represents a value for the key, for example,  +
`k1=v1,k2=v2` +
 +
The connector appends the specified tags to the base MBean object name.
Tags can help you to organize and categorize metrics data.
You can define tags to identify particular application instances, environments, regions, versions, and so forth.
For more information, see xref:customized-mbean-names[Customized MBean names].

[id="{context}-property-database-initial-statements"]
xref:{context}-property-database-initial-statements[`database.initial.statements`]::
Default value: No default +
A semicolon separated list of SQL statements to be executed when a JDBC connection, not the connection that is reading the transaction log, to the database is established.
To specify a semicolon as a character in a SQL statement and not as a delimiter, use two semicolons, (`;;`). +
+
The connector might establish JDBC connections at its own discretion, so this property is ony for configuring session parameters. It is not for executing DML statements.


[id="{context}-property-database-query-timeout-ms"]
xref:{context}-property-database-query-timeout-ms[`database.query.timeout.ms`]::
Default value: `600000` (10 minutes) +
Specifies the time, in milliseconds, that the connector waits for a query to complete.
Set the value to `0` (zero) to remove the timeout limit.



[id="{context}-property-database-ssl-keystore"]
xref:{context}-property-database-ssl-keystore[`database.ssl.keystore`]::
Default value: No default +
An optional setting that specifies the location of the key store file.
A key store file can be used for two-way authentication between the client and the {connector-name} server.


[id="{context}-property-database-ssl-keystore-password"]
xref:{context}-property-database-ssl-keystore-password[`database.ssl.keystore.password`]::
Default value: No default +
The password for the key store file.
Specify a password only if the xref:{context}-property-database-ssl-keystore[`database.ssl.keystore`] is configured.


[id="{context}-property-database-ssl-mode"]
xref:{context}-property-database-ssl-mode[`database.ssl.mode`]::
Default value: `preferred` +
Specifies whether the connector uses an encrypted connection.
The following settings are available:

`disabled`::: Specifies the use of an unencrypted connection.

`preferred` (Default)::: The connector establishes an encrypted connection if the server supports secure connections.
If the server does not support secure connections, the connector falls back to using an unencrypted connection.

`required`::: The connector establishes an encrypted connection.
If it is unable to establish an encrypted connection, the connector fails.

`verify_ca`::: The connector behaves as when you set the `required` option, but it also verifies the server TLS certificate against the configured Certificate Authority (CA) certificates.
If the server TLS certificate does not match any valid CA certificates, the connector fails. +

`verify_identity`::: The connector behaves as when you set the `verify_ca` option, but it also verifies that the server certificate matches the host of the remote connection.

[id="{context}-property-database-ssl-truststore"]
xref:{context}-property-database-ssl-truststore[`database.ssl.truststore`]::
Default value: No default +
The location of the trust store file for the server certificate verification.



[id="{context}-property-database-ssl-truststore-password"]
xref:{context}-property-database-ssl-truststore-password[`database.ssl.truststore.password`]::
Default value: No default +
The password for the trust store file.
Used to check the integrity of the truststore, and unlock the truststore.


[id="{context}-property-enable-time-adjuster"]
xref:{context}-property-enable-time-adjuster[`enable.time.adjuster`]::
Default value: `true` +
Boolean value that indicates whether the connector converts a 2-digit year specification to 4 digits.
Set the value to `false` when conversion is fully delegated to the database. +
+
{connector-name} users can insert year values with either 2-digits or 4-digits.
2-digit values are mapped to a year in the range 1970 - 2069.
By default, the connector performs the conversion.



[id="{context}-property-errors-max-retries"]
xref:{context}-property-errors-max-retries[`errors.max.retries`]::
Default value: `-1` +
Specifies how the connector responds after an operation that results in a retriable error, such as a connection error. +
Set one of the following options:

`-1`::: No limit.
The connector always restarts automatically, and retries the operation, regardless of the number of previous failures.

`0`::: Disabled.
The connector fails immediately, and never retries the operation.
User intervention is required to restart the connector.

`> 0`::: The connector restarts automatically until it reaches the specified maximum number of retries.
After the next failure, the connector stops, and user intervention is required to restart it.



[id="{context}-property-event-converting-failure-handling-mode"]
xref:{context}-property-event-converting-failure-handling-mode[`event.converting.failure.handling.mode`]::
Default value: `warn` +
Specifies how the connector responds when it cannot convert a table record due to a mismatch between the data type of a column and the type specified by the {prodname} internal schema. +
Set one of the following options:

`fail`:::  An exception reports that conversion failed because the data type of the field did not match the schema type, and indicates that it might be necessary to restart the connector in `schema _only_recovery` mode to enable a successful conversion.
`warn`::: The connector writes a `null` value to the event field for the column that failed conversion, writes a message to the warning log . +
`skip`:::  The connector writes a `null` value to the event field for the column that failed conversion, and writes a message to the debug log.



[id="{context}-property-event-processing-failure-handling-mode"]
xref:{context}-property-event-processing-failure-handling-mode[`event.processing.failure.handling.mode`]::
Default value: `fail` +
Specifies how the connector handles failures that occur when processing events, for example, if it encounters a corrupted event.
The following settings are available:

`fail`::: The connector raises an exception that reports the problematic event and its position.
The connector then stops.

`warn`::: The connector does not raise an exception.
Instead, it logs the problematic event and its position, and then skips the event.

`ignore`::: The connector ignores the problematic event, and does not generate a log entry.



[id="{context}-property-heartbeat-action-query"]
xref:{context}-property-heartbeat-action-query[`heartbeat.action.query`]::
Default value: No default +
Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. +
+
For example, the following query periodically captures the state of the executed GTID set in the source database. +
+
`INSERT INTO gtid_history_table (select @gtid_executed)`



[id="{context}-property-heartbeat-interval-ms"]
xref:{context}-property-heartbeat-interval-ms[`heartbeat.interval.ms`]::
Default value: `0` +
Specifies how frequently the connector sends heartbeat messages to a Kafka topic.
By default, the connector does not send heartbeat messages. +
+
Heartbeat messages are useful for monitoring whether the connector is receiving change events from the database. Heartbeat messages might help decrease the number of change events that need to be re-sent when a connector restarts. To send heartbeat messages, set this property to a positive integer, which indicates the number of milliseconds between heartbeat messages.



[id="{context}-property-incremental-snapshot-allow-schema-changes"]
xref:{context}-property-incremental-snapshot-allow-schema-changes[`incremental.snapshot.allow.schema.changes`]::
Default value: `false` +
Specifies whether the connector allows schema changes during an incremental snapshot.
When the value is set to `true`, the connector detects schema change during an incremental snapshot, and re-select a current chunk to avoid locking DDLs. +
 +
Changes to a primary key are not supported.
Changing the primary during an incremental snapshot, can lead to incorrect results.
A further limitation is that if a schema change affects only the default values of columns, then the change is not detected until the DDL is processed from the binlog stream.
This does not affect the values of snapshot events, but the schema of these snapshot events may have outdated defaults.



[id="{context}-property-incremental-snapshot-chunk-size"]
xref:{context}-property-incremental-snapshot-chunk-size[`incremental.snapshot.chunk.size`]::
Default value: `1024` +
The maximum number of rows that the connector fetches and reads into memory when it retrieves an incremental snapshot chunk.
Increasing the chunk size provides greater efficiency, because the snapshot runs fewer snapshot queries of a greater size.
However, larger chunk sizes also require more memory to buffer the snapshot data.
Adjust the chunk size to a value that provides the best performance in your environment.



[id="{context}-property-incremental-snapshot-watermarking-strategy"]
xref:{context}-property-incremental-snapshot-watermarking-strategy[`incremental.snapshot.watermarking.strategy`]::
Default value: `insert_insert` +
Specifies the watermarking mechanism that the connector uses during an incremental snapshot to deduplicate events that might be captured by an incremental snapshot and then recaptured after streaming resumes. +
You can specify one of the following options:

`insert_insert` (default)::: When you send a signal to initiate an incremental snapshot, for every chunk that {prodname} reads during the snapshot, it writes an entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, {prodname} inserts a second entry that records the signal to close the window.

`insert_delete`::: When you send a signal to initiate an incremental snapshot, for every chunk that {prodname} reads, it writes a single entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, this entry is removed.
No entry is created for the signal to close the snapshot window.
Set this option to prevent rapid growth of the signaling data collection.



[id="{context}-property-max-batch-size"]
xref:{context}-property-max-batch-size[`max.batch.size`]::
Default value: `2048` +
Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector.



[id="{context}-property-max-queue-size"]
xref:{context}-property-max-queue-size[`max.queue.size`]::
Default value: `8192` +
A positive integer value that specifies the maximum number of records that the blocking queue can hold.
When {prodname} reads events streamed from the database, it places the events in the blocking queue before it writes them to Kafka.
The blocking queue can provide backpressure for reading change events from the database
in cases where the connector ingests messages faster than it can write them to Kafka, or when Kafka becomes unavailable.
Events that are held in the queue are disregarded when the connector periodically records offsets.
Always set `max.queue.size` to a value that is larger than the value of xref:{context}-property-max-batch-size[`max.batch.size`].



[id="{context}-property-max-queue-size-in-bytes"]
xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`]::
Default value: `0` +
A long integer value that specifies the maximum volume of the blocking queue in bytes.
By default, volume limits are not specified for the blocking queue.
To specify the number of bytes that the queue can consume, set this property to a positive long value. +
If xref:{context}-property-max-queue-size[`max.queue.size`] is also set, writing to the queue is blocked when the size of the queue reaches the limit specified by either property.
For example, if you set `max.queue.size=1000`, and `max.queue.size.in.bytes=5000`, writing to the queue is blocked after the queue contains 1000 records, or after the volume of the records in the queue reaches 5000 bytes.



[id="{context}-property-min-row-count-to-stream-results"]
xref:{context}-property-min-row-count-to-stream-results[`min.row.count.to.stream.results`]::
Default value: `1000` +
During a snapshot, the connector queries each table for which the connector is configured to capture changes. The connector uses each query result to produce a read event that contains data for all rows in that table.
This property determines whether the {connector-name} connector puts results for a table into memory, which is fast but requires large amounts of memory, or streams the results, which can be slower but work for very large tables. The setting of this property specifies the minimum number of rows a table must contain before the connector streams results. +
+
To skip all table size checks and always stream all results during a snapshot, set this property to `0`.



[id="{context}-property-notification-enabled-channels"]
xref:{context}-property-notification-enabled-channels[`notification.enabled.channels`]::
Default value: No default +
List of notification channel names that are enabled for the connector.
By default, the following channels are available:

* `sink`
* `log`
* `jmx`

+
Optionally, you can also implement a {link-prefix}:{link-notification}#debezium-notification-custom-channel[custom notification channel].



[id="{context}-property-poll-interval-ms"]
xref:{context}-property-poll-interval-ms[`poll.interval.ms`]::
Default value: `500` (0.5 seconds) +
Positive integer value that specifies the number of milliseconds the connector waits for new change events to appear before it starts processing a batch of events.



[id="{context}-property-provide-transaction-metadata"]
xref:{context}-property-provide-transaction-metadata[`provide.transaction.metadata`]::
Default value: `false` +
Determines whether the connector generates events with transaction boundaries and enriches change event envelopes with transaction metadata. Specify `true` if you want the connector to do this.
For more information, see xref:{context}-transaction-metadata[Transaction metadata].



[id="{context}-property-read-only"]
xref:{context}-property-read-only[`read.only`]::
Default value: `false` +
Specifies whether a connector writes watermarks to the signal data collection to track the progress of an incremental snapshot.
Set the value to `true` to enable a connector that has a read-only connection to the database to use an incremental snapshot watermarking strategy that does not require writing to the signal data collection.

[id="{context}-property-signal-data-collection"]
xref:{context}-property-signal-data-collection[`signal.data.collection`]::
Default value: No default +
Fully-qualified name of the data collection that is used to send {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[signals] to the connector. +
Use the following format to specify the collection name: +
`_<databaseName>_._<tableName>_`



[id="{context}-property-signal-enabled-channels"]
xref:{context}-property-signal-enabled-channels[`signal.enabled.channels`]::
Default value: No default +
List of the signaling channel names that are enabled for the connector.
By default, the following channels are available:

* `source`
* `kafka`
* `file`
* `jmx`

+
Optionally, you can also implement a {link-prefix}:{link-signalling}#debezium-signaling-enabling-custom-signaling-channel[custom signaling channel].



[id="{context}-property-skipped-operations"]
xref:{context}-property-skipped-operations[`skipped.operations`]::
Default value: `t` +
A comma-separated list of operation types that will be skipped during streaming.
The operations include: `c` for inserts/create, `u` for updates, `d` for deletes, `t` for truncates, and `none` to not skip any operations.
By default, truncate operations are skipped.



[id="{context}-property-snapshot-delay-ms"]
xref:{context}-property-snapshot-delay-ms[`snapshot.delay.ms`]::
Default value: No default +
An interval in milliseconds that the connector should wait before performing a snapshot when the connector starts. If you are starting multiple connectors in a cluster, this property is useful for avoiding snapshot interruptions, which might cause re-balancing of connectors.



[id="{context}-property-snapshot-fetch-size"]
xref:{context}-property-snapshot-fetch-size[`snapshot.fetch.size`]::
Default value: No default +
During a snapshot, the connector reads table content in batches of rows.
This property specifies the maximum number of rows in a batch.


[id="{context}-property-snapshot-include-collection-list"]
xref:{context}-property-snapshot-include-collection-list[`snapshot.include.collection.list`]::
Default value: All tables specified in the `table.include.list`. +
An optional, comma-separated list of regular expressions that match the fully-qualified names (`_<databaseName>.<tableName>_`) of the tables to include in a snapshot.
The specified items must be named in the connector's xref:{context}-property-table-include-list[`table.include.list`] property.
This property takes effect only if the connector's xref:{context}-property-snapshot-mode[`snapshot.mode`] property is set to a value other than `never`. +
This property does not affect the behavior of incremental snapshots. +
 +
To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name.



[id="{context}-property-snapshot-lock-timeout-ms"]
xref:{context}-property-snapshot-lock-timeout-ms[`snapshot.lock.timeout.ms`]::
Default value: `10000` +
Positive integer that specifies the maximum amount of time (in milliseconds) to wait to obtain table locks when performing a snapshot. If the connector cannot acquire table locks in this time interval, the snapshot fails.
For more information, see
xref:mysql-snapshots[how {connector-name} connectors perform database snapshots].
xref:mariadb-snapshots[how {connector-name} connectors perform database snapshots].



[id="{context}-property-snapshot-locking-mode"]
xref:{context}-property-snapshot-locking-mode[`snapshot.locking.mode`]::
Default value: `minimal` +
Specifies whether and for how long the connector holds the global {connector-name} read lock, which prevents any updates to the database while the connector is performing a snapshot.
The following settings are available:

`minimal`::: The connector holds the global read lock for only the initial phase of the snapshot during which it reads the database schemas and other metadata.
During the next phase of the snapshot, the connector releases the lock as it selects all rows from each table.
To perform the SELECT operation in a consistent fashion, the connector uses a REPEATABLE READ transaction.
Although the release of the global read lock permits other {connector-name} clients to update the database, use of REPEATABLE READ isolation ensures a consistent snapshot, because the connector continues to read the same data for the duration of  the transaction. +

`extended`::: Blocks all write operations for the duration of the snapshot.
Use this setting if clients submit concurrent operations that are incompatible with the REPEATABLE READ isolation level in {connector-name}. +

`none`::: Prevents the connector from acquiring any table locks during the snapshot.
Although this option is allowed with all snapshot modes, it is safe to use _only_ if no schema changes occur while the snapshot is running.
Tables that are defined with the MyISAM engine always acquire a table lock.
As a result, such tables are locked even if you set this option.
This behavior differs from tables that are defined by the InnoDB engine, which acquire row-level locks.

`custom`::: The connector performs a snapshot according to the implementation specified by the xref:{context}-property-snapshot-locking-mode-custom-name[`snapshot.locking.mode.custom.name`] property, which is a custom implementation of the `io.debezium.spi.snapshot.SnapshotLock` interface.



[id="{context}-property-snapshot-locking-mode-custom-name"]
xref:{context}-property-snapshot-locking-mode-custom-name[`snapshot.locking.mode.custom.name`]::
Default value: No default +
When xref:{context}-property-snapshot-locking-mode[`snapshot.locking.mode`] is set to `custom`, use this setting to specify the name of the custom implementation provided in the `name()` method that is defined by the 'io.debezium.spi.snapshot.SnapshotLock' interface.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].



[id="{context}-property-snapshot-max-threads"]
xref:{context}-property-snapshot-max-threads[`snapshot.max.threads`]::
Default value: `1` +
Specifies the number of threads that the connector uses when performing an initial snapshot.
To enable parallel initial snapshots, set the property to a value greater than 1.
In a parallel initial snapshot, the connector processes multiple tables concurrently. +
+
NOTE: Parallel initial snapshots is an incubating feature.



[id="{context}-property-snapshot-mode"]
xref:{context}-property-snapshot-mode[`snapshot.mode`]::
Default value: `initial` +
Specifies the criteria for running a snapshot when the connector starts.
The following settings are available:

`always`::: The connector performs a snapshot every time that it starts.
The snapshot includes the structure and data of the captured tables.
Specify this value to populate topics with a complete representation of the data from the captured tables every time that the connector starts.

`initial` (default)::: The connector runs a snapshot only when no offsets have been recorded for the logical server name, or if it detects that an earlier snapshot failed to complete.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

`initial_only`::: The connector runs a snapshot only when no offsets have been recorded for the logical server name.
After the snapshot completes, the connector stops.
It does not transition to streaming to read change events from the binlog.

`schema_only`::: Deprecated, see `no_data`.

`no_data`::: The connector runs a snapshot that captures only the schema, but not any table data.
Set this option if you do not need the topics to contain a consistent snapshot of the data, but you want to capture any schema changes that were applied after the last connector restart.

`schema_only_recovery`::: Deprecated, see `recovery`.

`recovery`:::  Set this option to restore a database schema history topic that is lost or corrupted.
After a restart, the connector runs a snapshot that rebuilds the topic from the source tables.
You can also set the property to periodically prune a database schema history topic that experiences unexpected growth. +
+
[WARNING]
====
Do not use this mode to perform a snapshot if schema changes were committed to the database after the last connector shutdown.
====
`never`::: When the connector starts, rather than performing a snapshot, it immediately begins to stream event records for subsequent database changes.
This option is under consideration for future deprecation, in favor of the `no_data` option.

`when_needed`::: After the connector starts, it performs a snapshot only if it detects one of the following circumstances:

* It cannot detect any topic offsets.
* A previously recorded offset specifies a binlog position or GTID that is not available on the server.

`configuration_based`::: With this option, you control snapshot behavior through a set of connector properties that have the prefix 'snapshot.mode.configuration.based'.

`custom`::: The connector performs a snapshot according to the implementation specified by the xref:{context}-property-snapshot-mode-custom-name[`snapshot.mode.custom.name`] property, which defines a custom implementation of the `io.debezium.spi.snapshot.Snapshotter` interface.



[id="{context}-property-snapshot-mode-configuration-based-snapshot-data"]
xref:{context}-property-snapshot-mode-configuration-based-snapshot-data[`snapshot.mode.configuration.based.snapshot.data`]::
Default value: `false` +
If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table data when it performs a snapshot.

[id="{context}-property-snapshot-mode-configuration-based-snapshot-on-data-error"]
xref:{context}-property-snapshot-mode-configuration-based-snapshot-on-data-error[`snapshot.mode.configuration.based.snapshot.on.data.error`]::
Default value: `false` +
If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table data in a snapshot in the event that data is no longer available in the transaction log.

[id="{context}-property-snapshot-mode-configuration-based-snapshot-on-schema-error"]
xref:{context}-property-snapshot-mode-configuration-based-snapshot-on-schema-error[`snapshot.mode.configuration.based.snapshot.on.schema.error`]::
Default value: `false` +
If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table schema in a snapshot if the schema history topic is not available.

[id="{context}-property-snapshot-mode-configuration-based-snapshot-schema"]
xref:{context}-property-snapshot-mode-configuration-based-snapshot-schema[`snapshot.mode.configuration.based.snapshot.schema`]::
Default value: `false` +
If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes the table schema when it performs a snapshot.

[id="{context}-property-snapshot-mode-configuration-based-start-stream"]
xref:{context}-property-snapshot-mode-configuration-based-start-stream[`snapshot.mode.configuration.based.start.stream`]::
Default value: `false` +
If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector begins to stream change events after a snapshot completes.

[id="{context}-property-snapshot-mode-custom-name"]
xref:{context}-property-snapshot-mode-custom-name[`snapshot.mode.custom.name`]::
Default value: No default +
If `snapshot.mode` is set to `custom`, use this setting to specify the name of the custom implementation that is provided in the `name()` method that is defined in the 'io.debezium.spi.snapshot.Snapshotter' interface.
After a connector restart, {prodname} calls the specified custom implementation to determine whether to perform a snapshot.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

[id="{context}-property-snapshot-query-mode"]
xref:{context}-property-snapshot-query-mode[`snapshot.query.mode`]::
Default value: `select_all` +
Specifies how the connector queries data while performing a snapshot. +
Set one of the following options:

`select_all` (default)::: The connector uses a `select all` query to retrieve rows from captured tables, optionally adjusting the columns selected based on the column `include` and `exclude` list configurations.

`custom`::: The connector performs a snapshot query according to the implementation specified by the xref:{context}-property-snapshot-snapshot-query-mode-custom-name[`snapshot.query.mode.custom.name`] property, which defines a custom implementation of the `io.debezium.spi.snapshot.SnapshotQuery` interface. +
+
This setting enables you to manage snapshot content in a more flexible manner compared to using the xref:{context}-property-snapshot-select-statement-overrides[`snapshot.select.statement.overrides`] property.



[id="{context}-property-snapshot-snapshot-query-mode-custom-name"]
xref:{context}-property-snapshot-snapshot-query-mode-custom-name[`snapshot.query.mode.custom.name`]::
Default value: No default +
When xref:{context}-property-snapshot-query-mode[`snapshot.query.mode`] is set as `custom`, use this setting to specify the name of the custom implementation provided in the `name()` method that is defined by the 'io.debezium.spi.snapshot.SnapshotQuery' interface.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

[id="{context}-property-snapshot-select-statement-overrides"]
xref:{context}-property-snapshot-select-statement-overrides[`snapshot.select.statement.overrides`]::
Default value: No default +
Specifies the table rows to include in a snapshot.
Use the property if you want a snapshot to include only a subset of the rows in a table.
This property affects snapshots only.
It does not apply to events that the connector reads from the log.
 +
The property contains a comma-separated list of fully-qualified table names in the form `_<databaseName>.<tableName>_`. For example, +
+
`+"snapshot.select.statement.overrides": "inventory.products,customers.orders"+` +
+
For each table in the list, add a further configuration property that specifies the `SELECT` statement for the connector to run on the table when it takes a snapshot.
The specified `SELECT` statement determines the subset of table rows to include in the snapshot.
Use the following format to specify the name of this `SELECT` statement property: +
+
`snapshot.select.statement.overrides._<databaseName>_._<tableName>_`
For example,
`snapshot.select.statement.overrides.customers.orders` +
 +
From a `customers.orders` table that includes the soft-delete column, `delete_flag`, add the following properties if you want a snapshot to include only those records that are not soft-deleted:
+
----
"snapshot.select.statement.overrides": "customer.orders",
"snapshot.select.statement.overrides.customer.orders": "SELECT * FROM [customers].[orders] WHERE delete_flag = 0 ORDER BY id DESC"
----
+
In the resulting snapshot, the connector includes only the records for which `delete_flag = 0`.


[id="{context}-property-snapshot-tables-order-by-row-count"]
xref:{context}-property-snapshot-tables-order-by-row-count[`snapshot.tables.order.by.row.count`]::
Default value: `disabled` +
Specifies the order in which the connector processes tables when it performs an initial snapshot.
Set one of the following options:

`descending`::: The connector snapshots tables in order, based on the number of rows from the highest to the lowest.
`ascending`::: The connector snapshots tables in order, based on the number of rows, from lowest to highest.
`disabled`::: The connector disregards row count when performing an initial snapshot.



[id="{context}-property-source-struct-version"]
xref:{context}-property-source-struct-version[`source.struct.version`]::
Default value: `v2` +
Schema version for the `source` block in {prodname} events.  {prodname} 0.10 introduced a few breaking changes to the structure of the `source` block in order to unify the exposed structure across all the connectors. +
+
By setting this option to `v1`, the structure used in earlier versions can be produced. However, this setting is not recommended and is planned for removal in a future {prodname} version.



[id="{context}-property-streaming-delay-ms"]
xref:{context}-property-streaming-delay-ms[`streaming.delay.ms`]::
Default value: `0` +
Specifies the time, in milliseconds, that the connector delays the start of the streaming process after it completes a snapshot.
Setting a delay interval helps to prevent the connector from restarting snapshots in the event that a failure occurs immediately after the snapshot completes, but before the streaming process begins.
Set a delay value that is higher than the value of the {link-kafka-docs}/#connectconfigs_offset.flush.interval.ms[`offset.flush.interval.ms`] property that is set for the Kafka Connect worker.



[id="{context}-property-table-ignore-builtin"]
xref:{context}-property-table-ignore-builtin[`table.ignore.builtin`]::
Default value: `true` +
A Boolean value that specifies whether built-in system tables should be ignored.
This applies regardless of the table include and exclude lists.
By default, changes that occur to the values in system tables are excluded from capture, and {prodname} does not generate events for system table changes.



[id="{context}-property-topic-cache-size"]
xref:{context}-property-topic-cache-size[`topic.cache.size`]::
Default value: `10000` +
Specifies the number of topic names that can be stored in memory in a bounded concurrent hash map.
The connector uses the cache to help determine the topic name that corresponds to a data collection.



[id="{context}-property-topic-delimiter"]
xref:{context}-property-topic-delimiter[`topic.delimiter`]::
Default value: `.` +
Specifies the delimiter that the connector inserts between components of the topic name.



[id="{context}-property-topic-heartbeat-prefix"]
xref:{context}-property-topic-heartbeat-prefix[`topic.heartbeat.prefix`]::
Default value: `__debezium-heartbeat` +
Specifies the name of the topic to which the connector sends heartbeat messages.
The topic name takes the following format: +
+
_topic.heartbeat.prefix_._topic.prefix_ +
+
For example, if the topic prefix is `fulfillment`, the default topic name is `__debezium-heartbeat.fulfillment`.



[id="{context}-property-topic-naming-strategy"]
xref:{context}-property-topic-naming-strategy[`topic.naming.strategy`]::
Default value: `io.debezium.schema.DefaultTopicNamingStrategy` +
The name of the `TopicNamingStrategy` class that the connector uses.
The specified strategy determines how the connector names the topics that store event records for data changes, schema changes, transactions, heartbeats, and so forth.



[id="{context}-property-topic-transaction"]
xref:{context}-property-topic-transaction[`topic.transaction`]::
Default value: `transaction` +
Specifies the name of the topic to which the connector sends transaction metadata messages.
The topic name takes the following pattern: +
+
_topic.prefix_._topic.transaction_ +
+
For example, if the topic prefix is `fulfillment`, the default topic name is `fulfillment.transaction`.



[id="{context}-property-use-nongraceful-disconnect"]
xref:{context}-property-use-nongraceful-disconnect[`use.nongraceful.disconnect`]::
Default value: false +
A Boolean value that specifies whether the binary log client's keepalive thread sets the `SO_LINGER` socket option to  `0` to immediately close stale TCP connections. +
Set the value to `true` if the connector experiences deadlocks in `SSLSocketImpl.close`. +
For more information, see https://github.com/osheroff/mysql-binlog-connector-java/issues/133[Issue 133] in the https://github.com/osheroff/mysql-binlog-connector-java[mysql-binlog-connector-java] GitHub repository.

:leveloffset: 1

[id="debezium-mariadb-connector-database-history-configuration-properties"]
==== {prodname} connector database schema history configuration properties

:leveloffset: +1

{prodname} provides a set of `schema.history.internal.*` properties that control how the connector interacts with the schema history topic.

The following table describes the `schema.history.internal` properties for configuring the {prodname} connector.

.Connector database schema history configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-database-history-kafka-topic]]<<{context}-property-database-history-kafka-topic, `+schema.history.internal.kafka.topic+`>>
|No default
|The full name of the Kafka topic where the connector stores the database schema history.

|[[{context}-property-database-history-kafka-bootstrap-servers]]<<{context}-property-database-history-kafka-bootstrap-servers, `+schema.history.internal.kafka.bootstrap.servers+`>>
|No default
|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster. This connection is used for retrieving the database schema history previously stored by the connector, and for writing each DDL statement read from the source database. Each pair should point to the same Kafka cluster used by the Kafka Connect process.

|[[{context}-property-database-history-kafka-recovery-poll-interval-ms]]<<{context}-property-database-history-kafka-recovery-poll-interval-ms, `+schema.history.internal.kafka.recovery.poll.interval.ms+`>>
|`100`
|An integer value that specifies the maximum number of milliseconds the connector should wait during startup/recovery while polling for persisted data. The default is 100ms.

|[[{context}-property-database-history-kafka-query-timeout-ms]]<<{context}-property-database-history-kafka-query-timeout-ms, `+schema.history.internal.kafka.query.timeout.ms+`>>
|`3000`
|An integer value that specifies the maximum number of milliseconds the connector should wait while fetching cluster information using Kafka admin client.

|[[{context}-property-database-history-kafka-create-timeout-ms]]<<{context}-property-database-history-kafka-create-timeout-ms, `+schema.history.internal.kafka.create.timeout.ms+`>>
|`30000`
|An integer value that specifies the maximum number of milliseconds the connector should wait while create kafka history topic using Kafka admin client.

|[[{context}-property-database-history-kafka-recovery-attempts]]<<{context}-property-database-history-kafka-recovery-attempts, `+schema.history.internal.kafka.recovery.attempts+`>>
|`100`
|The maximum number of times that the connector should try to read persisted history data before the connector recovery fails with an error. The maximum amount of time to wait after receiving no data is `recovery.attempts` × `recovery.poll.interval.ms`.

|[[{context}-property-database-history-skip-unparseable-ddl]]<<{context}-property-database-history-skip-unparseable-ddl, `+schema.history.internal.skip.unparseable.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector should ignore malformed or unknown database statements or stop processing so a human can fix the issue.
The safe default is `false`.
Skipping should be used only with care as it can lead to data loss or mangling when the binlog is being processed.

|[[{context}-property-database-history-store-only-captured-tables-ddl]]<<{context}-property-database-history-store-only-captured-tables-ddl, `+schema.history.internal.store.only.captured.tables.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector records schema structures from all tables in a schema or database, or only from tables that are designated for capture. +
Specify one of the following values:

`false` (default):: During a database snapshot, the connector records the schema data for all non-system tables in the database, including tables that are not designated for capture.
It's best to retain the default setting.
If you later decide to capture changes from tables that you did not originally designate for capture, the connector can easily begin to capture data from those tables, because their schema structure is already stored in the schema history topic.
{prodname} requires the schema history of a table so that it can identify the structure that was present at the time that a change event occurred.

`true`:: During a database snapshot, the connector records the table schemas only for the tables from which {prodname} captures change events.
If you change the default value, and you later configure the connector to capture data from other tables in the database, the connector lacks the schema information that it requires to capture change events from the tables. +

|[[{context}-property-database-history-store-only-captured-databases-ddl]]<<{context}-property-database-history-store-only-captured-databases-ddl, `+schema.history.internal.store.only.captured.databases.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector records schema structures from all logical databases in the database instance. +
Specify one of the following values:

`true`:: The connector records schema structures only for tables in the logical database and schema from which {prodname} captures change events.
`false`:: The connector records schema structures for all logical databases. +

NOTE: The default value is `true` for MySQL Connector +

|===

[id="{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients"]
.Pass-through database schema history properties for configuring producer and consumer clients
{empty} +
{prodname} relies on a Kafka producer to write schema changes to database schema history topics.
Similarly, it relies on a Kafka consumer to read from database schema history topics when a connector starts.
You define the configuration for the Kafka producer and consumer clients by assigning values to a set of pass-through configuration properties that begin with the `schema.history.internal.producer.\*` and `schema.history.internal.consumer.*` prefixes.
The pass-through producer and consumer database schema history properties control a range of behaviors, such as how these clients secure connections with the Kafka broker, as shown in the following example:

[source,indent=0]
----
schema.history.internal.producer.security.protocol=SSL
schema.history.internal.producer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
schema.history.internal.producer.ssl.keystore.password=test1234
schema.history.internal.producer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
schema.history.internal.producer.ssl.truststore.password=test1234
schema.history.internal.producer.ssl.key.password=test1234

schema.history.internal.consumer.security.protocol=SSL
schema.history.internal.consumer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
schema.history.internal.consumer.ssl.keystore.password=test1234
schema.history.internal.consumer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
schema.history.internal.consumer.ssl.truststore.password=test1234
schema.history.internal.consumer.ssl.key.password=test1234
----

{prodname} strips the prefix from the property name before it passes the property to the Kafka client.

See the Kafka documentation for more details about link:https://kafka.apache.org/documentation.html#producerconfigs[Kafka producer configuration properties] and link:https://kafka.apache.org/documentation.html#consumerconfigs[Kafka consumer configuration properties].

:leveloffset: 1

[id="debezium-mariadb-connector-kafka-signals-configuration-properties"]
==== {prodname} connector Kafka signals configuration properties

:leveloffset: +1

{prodname} provides a set of `signal.*` properties that control how the connector interacts with the Kafka signals topic.

The following table describes the Kafka `signal` properties.

.Kafka signals configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-signal-kafka-topic]]<<{context}-property-signal-kafka-topic, `+signal.kafka.topic+`>>
|<topic.prefix>-signal
|The name of the Kafka topic that the connector monitors for ad hoc signals.
[NOTE]
====
If {link-prefix}:{link-topic-auto-creation}#topic-auto-create-config[automatic topic creation] is disabled, you must manually create the required signaling topic.
A signaling topic is required to preserve signal ordering.
The signaling topic must have a single partition.
====

|[[{context}-property-signal-kafka-groupId]]<<{context}-property-signal-kafka-groupId, `+signal.kafka.groupId+`>>
|kafka-signal
|The name of the group ID  that is used by Kafka consumers.

|[[{context}-property-signal-kafka-bootstrap-servers]]<<{context}-property-signal-kafka-bootstrap-servers, `+signal.kafka.bootstrap.servers+`>>
|No default
|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster.
Each pair references the Kafka cluster that is used by the {prodname} Kafka Connect process.

|[[{context}-property-signal-kafka-poll-timeout-ms]]<<{context}-property-signal-kafka-poll-timeout-ms, `+signal.kafka.poll.timeout.ms+`>>
|`100`
|An integer value that specifies the maximum number of milliseconds that the connector waits when polling signals.

|[[{context}-kafka-consumer-offset-commit-enabled]]<<{context}-kafka-consumer-offset-commit-enabled, `+kafka.consumer.offset.commit.enabled+`>>
|`false`
|Enable the offset commit for the signal topic in order to guarantee At-Least-Once delivery. If disabled, only signals received when the consumer is up&running are processed. Any signals received when the consumer is down are lost.

|===

[id="debezium-{context}-connector-pass-through-signals-kafka-consumer-configuration-properties"]
=== {prodname} connector pass-through signals Kafka consumer client configuration properties

The {prodname} connector provides for pass-through configuration of the signals Kafka consumer.
Pass-through signals properties begin with the prefix `signals.consumer.*`.
For example, the connector passes properties such as `signal.consumer.security.protocol=SSL` to the Kafka consumer.

{prodname} strips the prefixes from the properties before it passes the properties to the Kafka signals consumer.

:leveloffset: 1

[id="debezium-mariadb-connector-kafka-notifications-configuration-properties"]
==== {prodname} connector sink notifications configuration properties

:leveloffset: +1

The following table describes the `notification` properties.

.Sink notification configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-notification-sink-topic-name]]<<{context}-property-notification-sink-topic-name, `+notification.sink.topic.name+`>>
|No default
|The name of the topic that receives notifications from {prodname}.
This property is required when you configure the xref:{context}-property-notification-enabled-channels[`notification.enabled.channels`] property to include `sink` as one of the enabled notification channels.
|===

:leveloffset: 1

[id="debezium-mariadb-connector-pass-through-database-driver-configuration-properties"]
==== {prodname} connector pass-through database driver configuration properties

:leveloffset: +1

The {prodname} connector provides for pass-through configuration of the database driver.
Pass-through database properties begin with the prefix `driver.*`.
For example, the connector passes properties such as `driver.foobar=false` to the JDBC URL.

As is the case with the xref:{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[pass-through properties for database schema history clients], {prodname} strips the prefixes from the properties before it passes them to the database driver.

:leveloffset: 1

// Type: assembly
// ModuleID: monitoring-debezium-mariadb-connector-performance
// Title: Monitoring {prodname} MariaDB connector performance
[[mariadb-monitoring]]
== Monitoring

:leveloffset: +1

The {prodname} {connector-name} connector provides three types of metrics that are in addition to the built-in support for JMX metrics that Zookeeper, Kafka, and Kafka Connect provide.

* xref:{context}-snapshot-metrics[Snapshot metrics] provide information about connector operation while performing a snapshot.
* xref:{context}-streaming-metrics[Streaming metrics] provide information about connector operation when the connector is reading the binlog.
* xref:{context}-schema-history-metrics[Schema history metrics] provide information about the status of the connector's schema history.

{link-prefix}:{link-debezium-monitoring}#monitoring-debezium[{prodname} monitoring documentation] provides details for how to expose these metrics by using JMX.


:leveloffset: 1

// Type: concept
// ModuleID: monitoring-debezium-mariadb-connectors-customized-mbean-names
// Title: Customized names for MariaDB connector snapshot and streaming MBean objects
=== Customized MBean names

:leveloffset: +1

{prodname} connectors expose metrics via the MBean name for the connector.
These metrics, which are specific to each connector instance, provide data about the behavior of the connector's snapshot, streaming, and schema history processes.

By default, when you deploy a correctly configured connector, {prodname} generates a unique MBean name for each of the different connector metrics.
To view the metrics for a connector process, you configure your observability stack to monitor its MBean.
But these default MBean names depend on the connector configuration; configuration changes can result in changes to the MBean names.
A change to the MBean name breaks the linkage between the connector instance and the MBean, disrupting monitoring activity.
In this scenario, you must reconfigure the observability stack to use the new MBean name if you want to resume monitoring.

To prevent monitoring disruptions that result from MBean name changes, you can configure custom metrics tags.
You configure custom metrics by adding the `custom.metric.tags` property to the connector configuration.
The property accepts key-value pairs in which each key represents a tag for the MBean object name, and the corresponding value represents the value of that tag.
For example: `k1=v1,k2=v2`.
{prodname} appends the specified tags to the MBean name of the connector.

After you configure the `custom.metric.tags` property for a connector, you can configure the observability stack to retrieve metrics associated with the specified tags.
The observability stack then uses the specified tags, rather than the mutable MBean names to uniquely identify connectors.
Later, if {prodname} redefines how it constructs MBean names, or if the `topic.prefix` in the connector configuration changes, metrics collection is uninterrupted,
because the metrics scrape task uses the specified tag patterns to identify the connector.

A further benefit of using custom tags, is that you can use tags that reflect the architecture of your data pipeline, so that metrics are organized in a way that suits you operational needs.
For example, you might specify tags with values that declare the type of connector activity, the application context, or the data source, for example, `db1-streaming-for-application-abc`.
If you specify multiple key-value pairs, all of the specified pairs are appended to the connector's MBean name.

The following example illustrates how tags modify the default MBean name.

.How custom tags modify the connector MBean name
=======
By default, the {connector-name} connector uses the following MBean name for streaming metrics:
 +
[source,subs="attributes+,quotes"]
----
debezium.{context}:type=connector-metrics,context=streaming,server=_<topic.prefix>_
----

If you set the value of `custom.metric.tags` to `database=salesdb-streaming,table=inventory`, {prodname} generates the following custom MBean name:

[source,subs="attributes+,quotes"]
----
debezium.{context}:type=connector-metrics,context=streaming,server=_<topic.prefix>_,database=salesdb-streaming,table=inventory
----
=======


:leveloffset: 1

// Type: reference
// Title: Monitoring {prodname} during snapshots of MariaDB databases
[[mariadb-snapshot-metrics]]
=== Snapshot metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=snapshot,server=_<topic.prefix>_`.

:leveloffset: 1

:leveloffset: +1

Snapshot metrics are not exposed unless a snapshot operation is active, or if a snapshot has occurred since the last connector start.

The following table lists the snapshot metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-snaps-metric-lastevent_{context}]]<<connectors-snaps-metric-lastevent_{context}, `LastEvent`>>
|`string`
|The last snapshot event that the connector has read.

|[[connectors-snaps-metric-millisecondssincelastevent_{context}]]<<connectors-snaps-metric-millisecondssincelastevent_{context}, `MilliSecondsSinceLastEvent`>>
|`long`
|The number of milliseconds since the connector has read and processed the most recent event.

|[[connectors-snaps-metric-totalnumberofeventsseen_{context}]]<<connectors-snaps-metric-totalnumberofeventsseen_{context}, `TotalNumberOfEventsSeen`>>
|`long`
|The total number of events that this connector has seen since last started or reset.

|[[connectors-snaps-metric-numberofeventsfiltered_{context}]]<<connectors-snaps-metric-numberofeventsfiltered_{context}, `NumberOfEventsFiltered`>>
|`long`
| The number of events that have been filtered by include/exclude list filtering rules configured on the connector.

|[[connectors-snaps-metric-capturedtables_{context}]]<<connectors-snaps-metric-capturedtables_{context}, `CapturedTables`>>
|`string[]`
|The list of tables that are captured by the connector.

|[[connectors-snaps-metric-queuetotalcapacity_{context}]]<<connectors-snaps-metric-queuetotalcapacity_{context}, `QueueTotalCapacity`>>
|`int`
|The length the queue used to pass events between the snapshotter and the main Kafka Connect loop.

|[[connectors-snaps-metric-queueremainingcapacity_{context}]]<<connectors-snaps-metric-queueremainingcapacity_{context}, `QueueRemainingCapacity`>>
|`int`
|The free capacity of the queue used to pass events between the snapshotter and the main Kafka Connect loop.

|[[connectors-snaps-metric-totaltablecount_{context}]]<<connectors-snaps-metric-totaltablecount_{context}, `TotalTableCount`>>
|`int`
|The total number of tables that are being included in the snapshot.

|[[connectors-snaps-metric-remainingtablecount_{context}]]<<connectors-snaps-metric-remainingtablecount_{context}, `RemainingTableCount`>>
|`int`
|The number of tables that the snapshot has yet to copy.

|[[connectors-snaps-metric-snapshotrunning_{context}]]<<connectors-snaps-metric-snapshotrunning_{context}, `SnapshotRunning`>>
|`boolean`
|Whether the snapshot was started.

|[[connectors-snaps-metric-snapshotpaused_{context}]]<<connectors-snaps-metric-snapshotpaused_{context}, `SnapshotPaused`>>
|`boolean`
|Whether the snapshot was paused.

|[[connectors-snaps-metric-snapshotaborted_{context}]]<<connectors-snaps-metric-snapshotaborted_{context}, `SnapshotAborted`>>
|`boolean`
|Whether the snapshot was aborted.

|[[connectors-snaps-metric-snapshotcompleted_{context}]]<<connectors-snaps-metric-snapshotcompleted_{context}, `SnapshotCompleted`>>
|`boolean`
|Whether the snapshot completed.

|[[connectors-snaps-metric-snapshotdurationinseconds_{context}]]<<connectors-snaps-metric-snapshotdurationinseconds_{context}, `SnapshotDurationInSeconds`>>
|`long`
|The total number of seconds that the snapshot has taken so far, even if not complete. Includes also time when snapshot was paused.

|[[connectors-snaps-metric-snapshotpauseddurationinseconds_{context}]]<<connectors-snaps-metric-snapshotpauseddurationinseconds_{context}, `SnapshotPausedDurationInSeconds`>>
|`long`
|The total number of seconds that the snapshot was paused. If the snapshot was paused several times, the paused time adds up.

|[[connectors-snaps-metric-rowsscanned_{context}]]<<connectors-snaps-metric-rowsscanned_{context}, `RowsScanned`>>
|`Map<String, Long>`
|Map containing the number of rows scanned for each table in the snapshot.
Tables are incrementally added to the Map during processing.
Updates every 10,000 rows scanned and upon completing a table.

|[[connectors-snaps-metric-maxqueuesizeinbytes_{context}]]<<connectors-snaps-metric-maxqueuesizeinbytes_{context}, `MaxQueueSizeInBytes`>>
|`long`
|The maximum buffer of the queue in bytes. This metric is available if xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`] is set to a positive long value.

|[[connectors-snaps-metric-currentqueuesizeinbytes_{context}]]<<connectors-snaps-metric-currentqueuesizeinbytes_{context}, `CurrentQueueSizeInBytes`>>
|`long`
|The current volume, in bytes, of records in the queue.

|===

:leveloffset: 1

:leveloffset: +1

The connector also provides the following additional snapshot metrics when an incremental snapshot is executed:

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-insnap-metric-chunkid_{context}]]<<connectors-insnap-metric-chunkid_{context}, `ChunkId`>>
|`string`
|The identifier of the current snapshot chunk.

|[[connectors-insnap-metric-chunkfrom_{context}]]<<connectors-insnap-metric-chunkfrom_{context}, `ChunkFrom`>>
|`string`
|The lower bound of the primary key set defining the current chunk.

|[[connectors-insnap-metric-chunkto_{context}]]<<connectors-insnap-metric-chunkto_{context}, `ChunkTo`>>
|`string`
|The upper bound of the primary key set defining the current chunk.

|[[connectors-insnap-metric-tablefrom_{context}]]<<connectors-insnap-metric-tablefrom_{context}, `TableFrom`>>
|`string`
|The lower bound of the primary key set of the currently snapshotted table.

|[[connectors-insnap-metric-tableto_{context}]]<<connectors-insnap-metric-tableto_{context}, `TableTo`>>
|`string`
|The upper bound of the primary key set of the currently snapshotted table.

|===

The {prodname} {connector-name} connector also provides the `HoldingGlobalLock` custom snapshot metric.
This metric is set to a Boolean value that indicates whether the connector currently holds a global or table write lock.

:leveloffset: 1

// Type: reference
// Title: Monitoring {prodname} MariaDB connector record streaming
[[mariadb-streaming-metrics]]
=== Streaming metrics

:leveloffset: +1

The {prodname} {connector-name} connector provides three types of metrics that are in addition to the built-in support for JMX metrics that Zookeeper, Kafka, and Kafka Connect provide.

* xref:{context}-snapshot-metrics[Snapshot metrics] provide information about connector operation while performing a snapshot.
* xref:{context}-streaming-metrics[Streaming metrics] provide information about connector operation when the connector is reading the binlog.
* xref:{context}-schema-history-metrics[Schema history metrics] provide information about the status of the connector's schema history.

{link-prefix}:{link-debezium-monitoring}#monitoring-debezium[{prodname} monitoring documentation] provides details for how to expose these metrics by using JMX.


:leveloffset: 1

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=streaming,server=_<topic.prefix>_`.

:leveloffset: 1

:leveloffset: +1

The following table lists the streaming metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-strm-metric-lastevent_{context}]]<<connectors-strm-metric-lastevent_{context}, `LastEvent`>>
|`string`
|The last streaming event that the connector has read.

|[[connectors-strm-metric-millisecondssincelastevent_{context}]]<<connectors-strm-metric-millisecondssincelastevent_{context}, `MilliSecondsSinceLastEvent`>>
|`long`
|The number of milliseconds since the connector has read and processed the most recent event.

|[[connectors-strm-metric-totalnumberofeventsseen_{context}]]<<connectors-strm-metric-totalnumberofeventsseen_{context}, `TotalNumberOfEventsSeen`>>
|`long`
|The total number of data change events reported by the source database since the last connector start, or since a metrics reset.
Represents the data change workload for {prodname} to process.

|[[connectors-strm-metric-totalnumberofcreateeventsseen_{context}]]<<connectors-strm-metric-totalnumberofcreateeventsseen_{context}, `TotalNumberOfCreateEventsSeen`>>
|`long`
|The total number of create events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-totalnumberofupdateeventsseen_{context}]]<<connectors-strm-metric-totalnumberofupdateeventsseen_{context}, `TotalNumberOfUpdateEventsSeen`>>
|`long`
|The total number of update events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-totalnumberofdeleteeventsseen_{context}]]<<connectors-strm-metric-totalnumberofdeleteeventsseen_{context}, `TotalNumberOfDeleteEventsSeen`>>
|`long`
|The total number of delete events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-numberofeventsfiltered_{context}]]<<connectors-strm-metric-numberofeventsfiltered_{context}, `NumberOfEventsFiltered`>>
|`long`
|The number of events that have been filtered by include/exclude list filtering rules configured on the connector.

|[[connectors-strm-metric-capturedtables_{context}]]<<connectors-strm-metric-capturedtables_{context}, `CapturedTables`>>
|`string[]`
|The list of tables that are captured by the connector.

|[[connectors-strm-metric-queuetotalcapacity_{context}]]<<connectors-strm-metric-queuetotalcapacity_{context}, `QueueTotalCapacity`>>
|`int`
|The length the queue used to pass events between the streamer and the main Kafka Connect loop.

|[[connectors-strm-metric-queueremainingcapacity_{context}]]<<connectors-strm-metric-queueremainingcapacity_{context}, `QueueRemainingCapacity`>>
|`int`
|The free capacity of the queue used to pass events between the streamer and the main Kafka Connect loop.

|[[connectors-strm-metric-connected_{context}]]<<connectors-strm-metric-connected_{context}, `Connected`>>
|`boolean`
|Flag that denotes whether the connector is currently connected to the database server.

|[[connectors-strm-metric-millisecondsbehindsource_{context}]]<<connectors-strm-metric-millisecondsbehindsource_{context}, `MilliSecondsBehindSource`>>
|`long`
|The number of milliseconds between the last change event's timestamp and the connector processing it.
The values will incorporate any differences between the clocks on the machines where the database server and the connector are running.

|[[connectors-strm-metric-numberofcommittedtransactions_{context}]]<<connectors-strm-metric-numberofcommittedtransactions_{context}, `NumberOfCommittedTransactions`>>
|`long`
|The number of processed transactions that were committed.

|[[connectors-strm-metric-sourceeventposition_{context}]]<<connectors-strm-metric-sourceeventposition_{context}, `SourceEventPosition`>>
|`Map<String, String>`
|The coordinates of the last received event.

|[[connectors-strm-metric-lasttransactionid_{context}]]<<connectors-strm-metric-lasttransactionid_{context}, `LastTransactionId`>>
|`string`
|Transaction identifier of the last processed transaction.

|[[connectors-strm-metric-maxqueuesizeinbytes_{context}]]<<connectors-strm-metric-maxqueuesizeinbytes_{context}, `MaxQueueSizeInBytes`>>
|`long`
|The maximum buffer of the queue in bytes. This metric is available if xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`] is set to a positive long value.

|[[connectors-strm-metric-currentqueuesizeinbytes_{context}]]<<connectors-strm-metric-currentqueuesizeinbytes_{context}, `CurrentQueueSizeInBytes`>>
|`long`
|The current volume, in bytes, of records in the queue.

|===

The {prodname} {connector-name} connector also provides the following additional streaming metrics:

.Descriptions of additional {connector-name} streaming metrics
[cols="3,2,5",options="header"]
|===
|Attribute |Type |Description

|[[binlog-filename]]<<binlog-filename,`+BinlogFilename+`>>
|`string`
|The name of the binlog file that the connector has most recently read.

|[[binlog-position]]<<binlog-position,`+BinlogPosition+`>>
|`long`
|The most recent position (in bytes) within the binlog that the connector has read.

|[[is-gtid-mode-enabled]]<<is-gtid-mode-enabled,`+IsGtidModeEnabled+`>>
|`boolean`
|Flag that denotes whether the connector is currently tracking GTIDs from {connector-name} server.

|[[gtid-set]]<<gtid-set,`+GtidSet+`>>
|`string`
|The string representation of the most recent GTID set processed by the connector when reading the binlog.

|[[number-of-skipped-events]]<<number-of-skipped-events,`+NumberOfSkippedEvents+`>>
|`long`
|The number of events that have been skipped by the {connector-name} connector. Typically events are skipped due to a malformed or unparseable event from {connector-name}'s binlog.

|[[number-of-disconnects]]<<number-of-disconnects,`+NumberOfDisconnects+`>>
|`long`
|The number of disconnects by the {connector-name} connector.

|[[number-of-rolled-back-transactions]]<<number-of-rolled-back-transactions,`+NumberOfRolledBackTransactions+`>>
|`long`
|The number of processed transactions that were rolled back and not streamed.

|[[number-of-not-well-formed-transactions]]<<number-of-not-well-formed-transactions,`+NumberOfNotWellFormedTransactions+`>>
|`long`
|The number of transactions that have not conformed to the expected protocol of `BEGIN` + `COMMIT`/`ROLLBACK`. This value should be `0` under normal conditions.

|[[number-of-large-transactions]]<<number-of-large-transactions,`+NumberOfLargeTransactions+`>>
|`long`
|The number of transactions that have not fit into the look-ahead buffer. For optimal performance, this value should be significantly smaller than `NumberOfCommittedTransactions` and `NumberOfRolledBackTransactions`.

|===

:leveloffset: 1

//   Moved table of connector-specific metrics to conditonalized section of the preceding shared file.

// Type: reference
// Title: Monitoring {prodname} MariaDB connector schema history
[[mariadb-schema-history-metrics]]
=== Schema history metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=schema-history,server=_<topic.prefix>_`.

The following table lists the schema history metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-shist-metric-status_{context}]]<<connectors-shist-metric-status_{context}, `Status`>>
|`string`
|One of `STOPPED`, `RECOVERING` (recovering history from the storage), `RUNNING` describing the state of the database schema history.

|[[connectors-shist-metric-recoverystarttime_{context}]]<<connectors-shist-metric-recoverystarttime_{context}, `RecoveryStartTime`>>
|`long`
|The time in epoch seconds at what recovery has started.

|[[connectors-shist-metric-changesrecovered_{context}]]<<connectors-shist-metric-changesrecovered_{context}, `ChangesRecovered`>>
|`long`
|The number of changes that were read during recovery phase.

|[[connectors-shist-metric-changesapplied_{context}]]<<connectors-shist-metric-changesapplied_{context}, `ChangesApplied`>>
|`long`
|the total number of schema changes applied during recovery and runtime.

|[[connectors-shist-metric-millisecondssincelastrecoveredchange_{context}]]<<connectors-shist-metric-millisecondssincelastrecoveredchange_{context}, `MilliSecondsSinceLast{zwsp}RecoveredChange`>>
|`long`
|The number of milliseconds that elapsed since the last change was recovered from the history store.

|[[connectors-shist-metric-millisecondssincelastappliedchange_{context}]]<<connectors-shist-metric-millisecondssincelastappliedchange_{context}, `MilliSecondsSinceLast{zwsp}AppliedChange`>>
|`long`
|The number of milliseconds that elapsed since the last change was applied.

|[[connectors-shist-metric-lastrecoveredchange_{context}]]<<connectors-shist-metric-lastrecoveredchange_{context}, `LastRecoveredChange`>>
|`string`
|The string representation of the last change recovered from the history store.

|[[connectors-shist-metric-lastappliedchange_{context}]]<<connectors-shist-metric-lastappliedchange_{context}, `LastAppliedChange`>>
|`string`
|The string representation of the last applied change.

|===

:leveloffset: 1

// Type: concept
// Title: How {prodname} MariaDB connectors handle faults and problems
[[mariadb-when-things-go-wrong]]
== Behavior when things go wrong

:leveloffset: +1


{prodname} is a distributed system that captures all changes in multiple upstream databases; it never misses or loses an event.
When the system is operating normally or being managed carefully then {prodname} provides _exactly once_ delivery of every change event record.

If a fault does occur, the system does not lose any events.
However, while {prodname} is recovering from a fault, it might repeat some change events.
In these abnormal situations, {prodname}, like Kafka, provides _at least once_ delivery of change events.

The rest of this section describes how {prodname} handles various kinds of faults and problems.


[id="debezium-{context}-connector-configuration-and-startup-errors"]
Configuration and startup errors::

In the following situations, the connector fails when trying to start, reports an error or exception in the log, and stops running:

* The connector's configuration is invalid.
* The connector cannot successfully connect to the {connector-name} server by using the specified connection parameters.
* The connector is attempting to restart at a position in the binlog for which {connector-name} no longer has the history available.

In these cases, the error message has details about the problem and possibly a suggested workaround.
After you correct the configuration or address the {connector-name} problem, restart the connector.

[id="{context}-becomes-unavailable-while-debezium-is-running"]
{connector-name} becomes unavailable::

If your {connector-name} server becomes unavailable, the {prodname} {connector-name} connector fails with an error and the connector stops.
When the server is available again, restart the connector.

However, if you are connecting to a highly available {connector-name} cluster, you can restart the connector immediately.
It will connect to a different {connector-name} server in the cluster, find the location in the server's binlog that represents the last transaction, and begin reading the new server's binlog from that specific location.

[id="debezium-{context}-kafka-connect-process-stops-gracefully"]
Kafka Connect stops gracefully::

When Kafka Connect stops gracefully, there is a short delay while the {prodname} {connector-name} connector tasks are stopped and restarted on new Kafka Connect processes.

[id="debezium-{context}-kafka-connect-process-crashes"]
Kafka Connect process crashes::

If Kafka Connect crashes, the process stops and any {prodname} {connector-name} connector tasks terminate without their most recently-processed offsets being recorded.
In distributed mode, Kafka Connect restarts the connector tasks on other processes.
However, the {connector-name} connector resumes from the last offset recorded by the earlier processes.
As a result, the replacement tasks might regenerate some events that were processed before the crash, creating duplicate events.

Each change event message includes source-specific information that you can use to identify duplicate events, for example:

* Event origin
* {connector-name} server's event time
* The binlog file name and position
* GTIDs
(if used)

[id="debezium-{context}-kafka-process-becomes-unavailable"]
Kafka becomes unavailable::

The Kafka Connect framework records {prodname} change events in Kafka by using the Kafka producer API.
If the Kafka brokers become unavailable, the {prodname} {connector-name} connector pauses until the connection is reestablished, and the connector then resumes where it left off.

[id="{context}-purges-binlog-files-used-by-debezium"]
{connector-name} purges binlog files::

If the {prodname} {connector-name} connector stops for too long, the {connector-name} server purges older binlog files and the connector's last position may be lost.
When the connector is restarted, the {connector-name} server no longer has the starting point and the connector performs another initial snapshot.
If the snapshot is disabled, the connector fails with an error.

See xref:{context}-snapshots[snapshots] for details about how {connector-name} connectors perform initial snapshots.

:leveloffset: 1

:leveloffset!:
:leveloffset: +1

// Category: debezium-using
// Type: assembly
[id="debezium-connector-for-postgresql"]
= {prodname} connector for PostgreSQL

:context: postgresql
:data-collection: table
:database-port: 5432
:mbean-name: postgres
:connector-file: postgres
:connector-class: Postgres
:connector-name: PostgreSQL
:include-list-example: public.inventory

:toc:
:toc-placement: macro
:linkattrs:
:icons: font
:source-highlighter: highlight.js

toc::[]

The {prodname} PostgreSQL connector captures row-level changes in the schemas of a PostgreSQL database.
For information about the PostgreSQL versions that are compatible with the connector, see the link:https://debezium.io/releases/[{prodname} release overview].

The first time it connects to a PostgreSQL server or cluster, the connector takes a consistent snapshot of all schemas. After that snapshot is complete, the connector continuously captures row-level changes that insert, update, and delete database content and that were committed to a PostgreSQL database. The connector generates data change event records and streams them to Kafka topics. For each table, the default behavior is that the connector streams all generated events to a separate Kafka topic for that table. Applications and services consume data change event records from that topic.


// Type: concept
// Title: Overview of {prodname} PostgreSQL connector
// ModuleID: overview-of-debezium-postgresql-connector
[[postgresql-overview]]
== Overview

PostgreSQL's link:https://www.postgresql.org/docs/current/static/logicaldecoding-explanation.html[_logical decoding_] feature was introduced in version 9.4. It is a mechanism that allows the extraction of the changes that were committed to the transaction log and the processing of these changes in a user-friendly manner with the help of an link:https://www.postgresql.org/docs/current/static/logicaldecoding-output-plugin.html[_output plug-in_]. The output plug-in enables clients to consume the changes.

The PostgreSQL connector contains two main parts that work together to read and process database changes:

[[postgresql-output-plugin]]
* A logical decoding output plug-in. You might need to install the output plug-in that you choose to use. You must configure a replication slot that uses your chosen output plug-in before running the PostgreSQL server. The plug-in can be one of the following:
** link:https://github.com/debezium/postgres-decoderbufs[`decoderbufs`] is based on Protobuf and maintained by the {prodname} community.
** `pgoutput` is the standard logical decoding output plug-in in PostgreSQL 10+. It is maintained by the PostgreSQL community, and used by PostgreSQL itself for link:https://www.postgresql.org/docs/current/logical-replication-architecture.html[logical replication]. This plug-in is always present so no additional libraries need to be installed. The {prodname} connector interprets the raw replication event stream directly into change events.

* Java code (the actual Kafka Connect connector) that reads the changes produced by the chosen logical decoding output plug-in. It uses PostgreSQL's link:https://www.postgresql.org/docs/current/static/logicaldecoding-walsender.html[_streaming replication protocol_], by means of the PostgreSQL link:https://github.com/pgjdbc/pgjdbc[_JDBC driver_]


The connector produces a _change event_ for every row-level insert, update, and delete operation that was captured and sends change event records for each table in a separate Kafka topic. Client applications read the Kafka topics that correspond to the database tables of interest, and can react to every row-level event they receive from those topics.

PostgreSQL normally purges write-ahead log (WAL) segments after some period of time. This means that the connector does not have the complete history of all changes that have been made to the database. Therefore, when the PostgreSQL connector first connects to a particular PostgreSQL database, it starts by performing a _consistent snapshot_ of each of the database schemas. After the connector completes the snapshot, it continues streaming changes from the exact point at which the snapshot was made. This way, the connector starts with a consistent view of all of the data, and does not omit any changes that were made while the snapshot was being taken.

The connector is tolerant of failures. As the connector reads changes and produces events, it records the WAL position for each event. If the connector stops for any reason (including communication failures, network problems, or crashes), upon restart the connector continues reading the WAL where it last left off. This includes snapshots. If the connector stops during a snapshot, the connector begins a new snapshot when it restarts.

[[postgresql-limitations]]
[IMPORTANT]
====
The connector relies on and reflects the PostgreSQL logical decoding feature, which has the following limitations:

* Logical decoding does not support DDL changes. This means that the connector is unable to report DDL change events back to consumers.
* Logical decoding replication slots are supported on only `primary` servers. When there is a cluster of PostgreSQL servers, the connector can run on only the active `primary` server. It cannot run on `hot` or `warm` standby replicas. If the `primary` server fails or is demoted, the connector stops. After the `primary` server has recovered, you can restart the connector. If a different PostgreSQL server has been promoted to `primary`, adjust the connector configuration before restarting the connector.
* Because logical decoding replication slots publish changes during commit -- and not post commit -- undesirable side-effects can occur. There are two main scenarios when clients can observe inconsistent states. First, publishing uncommitted changes when the master dies before replication completes. Second, publishing changes that cannot be read (i.e., read-after-write consistency) temporarily because they are being replicated. For example, an EmbeddedEngine consumer receives a notification of a row that was created but it cannot be read by a transaction.


Additionally, the `pgoutput` logical decoding output plug-in does not capture values for generated columns, resulting in missing data for these columns in the connector's output.

xref:postgresql-when-things-go-wrong[Behavior when things go wrong] describes how the connector responds if there is a problem.
====

[IMPORTANT]
====
{prodname} currently supports databases with UTF-8 character encoding only.
With a single byte character encoding, it is not possible to correctly process strings that contain extended ASCII code characters.
====

// Type: assembly
// ModuleID: how-debezium-postgresql-connectors-work
// Title: How {prodname} PostgreSQL connectors work
[[how-the-postgresql-connector-works]]
== How the connector works

To optimally configure and run a {prodname} PostgreSQL connector, it is helpful to understand how the connector performs snapshots, streams change events, determines Kafka topic names, and uses metadata.


// Type: concept
// ModuleID: creating-debezium-postgresql-user
// Title: Security for PostgreSQL connector
[[postgresql-security]]
=== Security

To use the {prodname} connector to stream changes from a PostgreSQL database, the connector must operate with specific privileges in the database.
Although one way to grant the necessary privileges is to provide the user with `superuser` privileges, doing so potentially exposes your PostgreSQL data to unauthorized access.
Rather than granting excessive privileges to the {prodname} user, it is best to create a dedicated {prodname} replication user to which you grant specific privileges.

For more information about configuring privileges for the {prodname} PostgreSQL user, see xref:postgresql-permissions[Setting up permissions].
For more information about PostgreSQL logical replication security, see the link:https://www.postgresql.org/docs/current/logical-replication-security.html[PostgreSQL documentation].

// Type: concept
// ModuleID: how-debezium-postgresql-connectors-perform-database-snapshots
// Title: How {prodname} PostgreSQL connectors perform database snapshots
[[postgresql-snapshots]]
=== Snapshots

Most PostgreSQL servers are configured to not retain the complete history of the database in the WAL segments.
This means that the PostgreSQL connector would be unable to see the entire history of the database by reading only the WAL.
Consequently, the first time that the connector starts, it performs an initial _consistent snapshot_ of the database.


.Default workflow behavior of initial snapshots
The default behavior for performing a snapshot consists of the following steps.
You can change this behavior by setting the xref:postgresql-property-snapshot-mode[`snapshot.mode` connector configuration property] to a value other than `initial`.

. Start a transaction with a link:https://www.postgresql.org/docs/current/static/sql-set-transaction.html[SERIALIZABLE, READ ONLY, DEFERRABLE] isolation level to ensure that subsequent reads in this transaction are against a single consistent version of the data. Any changes to the data due to subsequent `INSERT`, `UPDATE`, and `DELETE` operations by other clients are not visible to this transaction.
. Read the current position in the server's transaction log.
. Scan the database tables and schemas, generate a `READ` event for each row and write that event to the appropriate table-specific Kafka topic.
. Commit the transaction.
. Record the successful completion of the snapshot in the connector offsets.

If the connector fails, is rebalanced, or stops after Step 1 begins but before Step 5 completes, upon restart the connector begins a new snapshot. After the connector completes its initial snapshot, the PostgreSQL connector continues streaming from the position that it read in Step 2. This ensures that the connector does not miss any updates. If the connector stops again for any reason, upon restart, the connector continues streaming changes from where it previously left off.

[id="postgresql-connector-snapshot-mode-options"]
.Options for the `snapshot.mode` connector configuration property
[cols="20%a,80%a",options="header"]
|===
|Option
|Description

|`always`
|The connector always performs a snapshot when it starts. After the snapshot completes, the connector continues streaming changes from step 3 in the above sequence. This mode is useful in these situations: +

* It is known that some WAL segments have been deleted and are no longer available. +
* After a cluster failure, a new primary has been promoted. The `always` snapshot mode ensures that the connector does not miss any changes that were made after the new primary had been promoted but before the connector was restarted on the new primary.

|`initial` (default)
|The connector performs a database snapshot when no Kafka offsets topic exists. After the database snapshot completes the Kafka offsets topic is written. If there is a previously stored LSN in the Kafka offsets topic, the connector continues streaming changes from that position.

|`initial_only`
|The connector performs a database snapshot and stops before streaming any change event records. If the connector had started but did not complete a snapshot before stopping, the connector restarts the snapshot process and stops when the snapshot completes.

|`no_data`
|The connector never performs snapshots.
When a connector is configured this way, after it starts, it behaves as follows:

If there is a previously stored LSN in the Kafka offsets topic, the connector continues streaming changes from that position.
If no LSN is stored, the connector starts streaming changes from the point at which the PostgreSQL logical replication slot was created on the server.
Use this snapshot mode only when you know that all data of interest is still reflected in the WAL.

|[.line-through]`never`
|Deprecated, see `no_data`

|`when_needed`
|After the connector starts, it performs a snapshot only if it detects one of the following circumstances:

* It cannot detect any topic offsets.
* A previously recorded offset specifies a log position that is not available on the server.

|`configuration_based`
|Set the snapshot mode to `configuration_based` to control snapshot behavior through the set of connector properties that have the prefix 'snapshot.mode.configuration.based'.

|`custom`
|The `custom` snapshot mode lets you inject your own implementation of the `io.debezium.spi.snapshot.Snapshotter` interface.
Set the `snapshot.mode.custom.name` configuration property to the name provided by the `name()` method of your implementation.
The name is specified on the classpath of your Kafka Connect cluster.
If you use the `EmbeddedEngine`, the name is included in the connector JAR file.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|===

// Type: concept
// ModuleID: debezium-postgresql-ad-hoc-snapshots
[id="postgresql-ad-hoc-snapshots"]
=== Ad hoc snapshots

:leveloffset: +3

By default, a connector runs an initial snapshot operation only after it starts for the first time.
Following this initial snapshot, under normal circumstances, the connector does not repeat the snapshot process.
Any future change event data that the connector captures comes in through the streaming process only.

However, in some situations the data that the connector obtained during the initial snapshot might become stale, lost, or incomplete.
To provide a mechanism for recapturing {data-collection} data, {prodname} includes an option to perform ad hoc snapshots.
You might want to perform an ad hoc snapshot after any of the following changes occur in your {prodname} environment:

* The connector configuration is modified to capture a different set of {data-collection}s.
* Kafka topics are deleted and must be rebuilt.
* Data corruption occurs due to a configuration error or some other problem.

You can re-run a snapshot for a {data-collection} for which you previously captured a snapshot by initiating a so-called _ad-hoc snapshot_.
Ad hoc snapshots require the use of {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[signaling {data-collection}s].
You initiate an ad hoc snapshot by sending a signal request to the {prodname} signaling {data-collection}.

When you initiate an ad hoc snapshot of an existing {data-collection}, the connector appends content to the topic that already exists for the {data-collection}.
If a previously existing topic was removed, {prodname} can create a topic automatically if {link-prefix}:{link-topic-auto-creation}#customizing-debezium-automatically-created-topics[automatic topic creation] is enabled.

Ad hoc snapshot signals specify the {data-collection}s to include in the snapshot.
The snapshot can capture the entire contents of the database, or capture only a subset of the {data-collection}s in the database.
Also, the snapshot can capture a subset of the contents of the {data-collection}(s) in the database.

You specify the {data-collection}s to capture by sending an `execute-snapshot` message to the signaling {data-collection}.
Set the type of the `execute-snapshot` signal to `incremental` or `blocking`, and provide the names of the {data-collection}s to include in the snapshot, as described in the following table:


.Example of an ad hoc `execute-snapshot` signal record
[cols="2,2,6a",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| Specifies the type of snapshot that you want to run. +
Currently, you can request `incremental` or `blocking` snapshots.


|`data-collections`
|_N/A_
| An array that contains regular expressions matching the fully-qualified names of the {data-collection} to be snapshotted. +
The format of the names is the same as for the `signal.data.collection` configuration option.

|`[.line-through]#additional-condition#`
|_N/A_
| An optional string, which specifies a condition based on the column(s) of the {data-collection}(s), to capture a
subset of the contents of the {data-collection}(s). +

[NOTE]
====
This property is deprecated.
To specify criteria for defining the subset of data that you want the snapshot to capture, use the `additional-conditions` parameter.
====

|`additional-conditions`
|_N/A_
|An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot. +
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:

`data-collection`:: The fully-qualified name of the {data-collection} that the filter applies to.
You can apply different filters to each {data-collection}.
`filter`:: Specifies column values that must be present in a database record for the snapshot to include it, for example,  `"color='blue'"`. +
 +
The values that you assign to the `filter` parameter are the same types of values that you might specify in the `WHERE` clause of `SELECT` statements when you set the `snapshot.select.statement.overrides` property for a blocking snapshot.
In earlier {prodname} releases, an explicit `filter` parameter was not defined for snapshot signals; instead, filter criteria were implied by the values that were specified for the now deprecated  `additional-condition` parameter.

|`surrogate-key`
|_N/A_
| An optional string that specifies the column name that the connector uses as the primary key of a {data-collection} during the snapshot process.

|===

.Triggering an ad hoc incremental snapshot

You initiate an ad hoc incremental snapshot by adding an entry with the `execute-snapshot` signal type to the signaling {data-collection}.
After the connector processes the message, it begins the snapshot operation.
The snapshot process reads the first and last primary key values and uses those values as the start and end point for each {data-collection}.
Based on the number of entries in the {data-collection}, and the configured chunk size, {prodname} divides the {data-collection} into chunks, and proceeds to snapshot each chunk, in succession, one at a time.

For more information, see xref:debezium-{context}-incremental-snapshots[Incremental snapshots].

.Triggering an ad hoc blocking snapshot

You initiate an ad hoc blocking snapshot by adding an entry with the `execute-snapshot` signal type to the signaling {data-collection}.
After the connector processes the message, it begins the snapshot operation.
The connector temporarily stops streaming, and then initiates a snapshot of the specified {data-collection}, following the same process that it uses during an initial snapshot.
After the snapshot completes, the connector resumes streaming.

For more information, see xref:{context}-blocking-snapshots[Blocking snapshots].

:leveloffset: 1

// Type: assembly
// ModuleID: debezium-postgresql-incremental-snapshots
[id="postgresql-incremental-snapshots"]
=== Incremental snapshots

:leveloffset: +1

To provide flexibility in managing snapshots, {prodname} includes a supplementary snapshot mechanism, known as _incremental snapshotting_.
Incremental snapshots rely on the {prodname} mechanism for {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[sending signals to a {prodname} connector].
Incremental snapshots are based on the link:https://github.com/debezium/debezium-design-documents/blob/main/DDD-3.md[DDD-3] design document.

In an incremental snapshot, instead of capturing the full state of a database all at once, as in an initial snapshot, {prodname} captures each {data-collection} in phases, in a series of configurable chunks.
You can specify the {data-collection}s that you want the snapshot to capture and the xref:{context}-property-incremental-snapshot-chunk-size[size of each chunk].
The chunk size determines the number of rows that the snapshot collects during each fetch operation on the database.
The default chunk size for incremental snapshots is 1024 rows.

As an incremental snapshot proceeds, {prodname} uses watermarks to track its progress, maintaining a record of each {data-collection} row that it captures.
This phased approach to capturing data provides the following advantages over the standard initial snapshot process:

* You can run incremental snapshots in parallel with streamed data capture, instead of postponing streaming until the snapshot completes.
  The connector continues to capture near real-time events from the change log throughout the snapshot process, and neither operation blocks the other.
* If the progress of an incremental snapshot is interrupted, you can resume it without losing any data.
  After the process resumes, the snapshot begins at the point where it stopped, rather than recapturing the {data-collection} from the beginning.
* You can run an incremental snapshot on demand at any time, and repeat the process as needed to adapt to database updates.
  For example, you might re-run a snapshot after you modify the connector configuration to add a {data-collection} to its xref:{context}-property-{data-collection}-include-list[`{data-collection}.include.list`] property.

.Incremental snapshot process
When you run an incremental snapshot, {prodname} sorts each {data-collection} by primary key and then splits the {data-collection} into chunks based on the xref:{context}-property-incremental-snapshot-chunk-size[configured chunk size].
Working chunk by chunk, it then captures each {data-collection} row in a chunk.
For each row that it captures, the snapshot emits a `READ` event.
That event represents the value of the row when the snapshot for the chunk began.

As a snapshot proceeds, it’s likely that other processes continue to access the database, potentially modifying {data-collection} records.
To reflect such changes, `INSERT`, `UPDATE`, or `DELETE` operations are committed to the transaction log as per usual.
Similarly, the ongoing {prodname} streaming process continues to detect these change events and emits corresponding change event records to Kafka.

.How {prodname} resolves collisions among records with the same primary key
In some cases, the `UPDATE` or `DELETE` events that the streaming process emits are received out of sequence.
That is, the streaming process might emit an event that modifies a {data-collection} row before the snapshot captures the chunk that contains the `READ` event for that row.
When the snapshot eventually emits the corresponding `READ` event for the row, its value is already superseded.
To ensure that incremental snapshot events that arrive out of sequence are processed in the correct logical order, {prodname} employs a buffering scheme for resolving collisions.
Only after collisions between the snapshot events and the streamed events are resolved does {prodname} emit an event record to Kafka.

.Snapshot window
To assist in resolving collisions between late-arriving `READ` events and streamed events that modify the same {data-collection} row, {prodname} employs a so-called _snapshot window_.
The snapshot windows demarcates the interval during which an incremental snapshot captures data for a specified {data-collection} chunk.
Before the snapshot window for a chunk opens, {prodname} follows its usual behavior and emits events from the transaction log directly downstream to the target Kafka topic.
But from the moment that the snapshot for a particular chunk opens, until it closes, {prodname} performs a de-duplication step to resolve collisions between events that have the same primary key..

For each data collection, the {prodname} emits two types of events, and stores the records for them both in a single destination Kafka topic.
The snapshot records that it  captures directly from a table are emitted as `READ` operations.
Meanwhile, as users continue to update records in the data collection, and the transaction log is updated to reflect each commit, {prodname} emits `UPDATE` or `DELETE` operations for each change.

As the snapshot window opens, and {prodname} begins processing a snapshot chunk, it delivers snapshot records to a memory buffer.
During the snapshot windows, the primary keys of the `READ` events in the buffer are compared to the primary keys of the incoming streamed events.
If no match is found, the streamed event record is sent directly to Kafka.
If {prodname} detects a match, it discards the buffered `READ` event, and writes the streamed record to the destination topic, because the streamed event logically supersede the static snapshot event.
After the snapshot window for the chunk closes, the buffer contains only `READ` events for which no related transaction log events exist.
{prodname} emits these remaining `READ` events to the {data-collection}'s Kafka topic.

The connector repeats the process for each snapshot chunk.

:leveloffset: 1

[WARNING]
====
The {prodname} connector for PostgreSQL does not support schema changes while an incremental snapshot is running.
If a schema change is performed _before_ the incremental snapshot start but _after_ sending the signal then passthrough config option `database.autosave` is set to `conservative` to correctly process the schema change.
====

// Type: procedure
// ModuleID: debezium-postgresql-triggering-an-incremental-snapshot
[id="postgresql-triggering-an-incremental-snapshot"]
==== Triggering an incremental snapshot

:leveloffset: +1

Currently, the only way to initiate an incremental snapshot is to send an {link-prefix}:{link-signalling}#debezium-signaling-ad-hoc-snapshots[ad hoc snapshot signal] to the signaling {data-collection} on the source database.

You submit a signal to the signaling {data-collection} as SQL `INSERT` queries.

After {prodname} detects the change in the signaling {data-collection}, it reads the signal, and runs the requested snapshot operation.

The query that you submit specifies the {data-collection}s to include in the snapshot, and, optionally, specifies the type of snapshot operation.
Currently supports the `incremental` and `blocking` types.

To specify the {data-collection}s to include in the snapshot, provide a `data-collections` array that lists the {data-collection}s or an array of regular expressions used to match {data-collection}s, for example, +

`{"data-collections": ["public.MyFirstTable", "public.MySecondTable"]}` +

The `data-collections` array for an incremental snapshot signal has no default value.
If the `data-collections` array is empty, {prodname} detects that no action is required and does not perform a snapshot.

[NOTE]
====
If the name of a {data-collection} that you want to include in a snapshot contains a dot (`.`) in the name of the database, schema, or table, to add the {data-collection} to the `data-collections` array, you must escape each part of the name in double quotes. +
 +
For example, to include a table that exists in the `*public*` schema and that has the name `*My.Table*`, use the following format: `*"public"."My.Table"*`.
====

.Prerequisites

* {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[Signaling is enabled]. +
** A signaling data collection exists on the source database.
** The signaling data collection is specified in the xref:{context}-property-signal-data-collection[`signal.data.collection`] property.

.Using a source signaling channel to trigger an incremental snapshot

. Send a SQL query to add the ad hoc incremental snapshot request to the signaling {data-collection}:
+
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) VALUES (_'<id>'_, _'<snapshotType>'_, '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"_<snapshotType>_","additional-conditions":[{"data-collection": "_<tableName>_", "filter": "_<additional-condition>_"}]}');
----
+
For example,
+
[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) // <1>
values ('ad-hoc-1',   // <2>
    'execute-snapshot',  // <3>
    '{"data-collections": ["schema1.table1", "schema2.table2"], // <4>
    "type":"incremental", // <5>
    "additional-conditions":[{"data-collection": "schema1.table1" ,"filter":"color=\'blue\'"}]}'); // <6>
----
+
The values of the `id`,`type`, and `data` parameters in the command correspond to the {link-prefix}:{link-signalling}#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection[fields of the signaling {data-collection}].
+
The following table describes the parameters in the example:
+
.Descriptions of fields in a SQL command for sending an incremental snapshot signal to the signaling {data-collection}
[cols="1,2,6",options="header"]
|===
|Item |Value |Description

|1
|`myschema.debezium_signal`
|Specifies the fully-qualified name of the signaling {data-collection} on the source database.

|2
|`ad-hoc-1`
|The `id` parameter specifies an arbitrary string that is assigned as the `id` identifier for the signal request. +
Use this string to identify logging messages to entries in the signaling {data-collection}.
{prodname} does not use this string.
Rather, during the snapshot, {prodname} generates its own `id` string as a watermarking signal.

|3
|`execute-snapshot`
|The `type` parameter specifies the operation that the signal is intended to trigger. +

|4
|`data-collections`
|A required component of the `data` field of a signal that specifies an array of {data-collection} names or regular expressions to match {data-collection} names to include in the snapshot. +
The array lists regular expressions which match {data-collection}s by their fully-qualified names, using the same format as you use to specify the name of the connector's signaling {data-collection} in the xref:{context}-property-signal-data-collection[`signal.data.collection`] configuration property.

|5
|`incremental`
|An optional `type` component of the `data` field of a signal that specifies the type of snapshot operation to run. +
Currently supports the `incremental` and `blocking` types. +
If you do not specify a value, the connector runs an incremental snapshot.

|6
|`additional-conditions`
| An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot. +
Each additional condition is an object with `data-collection` and `filter` properties.
You can specify different filters for each data collection. +
* The `data-collection` property is the fully-qualified name of the data collection for which the filter will be applied.
For more information about the `additional-conditions` parameter, see xref:{context}-incremental-snapshots-additional-conditions[].
|===

[id="{context}-incremental-snapshots-additional-conditions"]
.Ad hoc incremental snapshots with `additional-conditions`

If you want a snapshot to include only a subset of the content in a {data-collection}, you can modify the signal request by appending an `additional-conditions` parameter to the snapshot signal.

The SQL query for a typical snapshot takes the following form:

[source,sql,subs="+attributes,+quotes"]
----
SELECT * FROM _<tableName>_ ....
----

By adding an `additional-conditions` parameter, you append a `WHERE` condition to the SQL query, as in the following example:

[source,sql,subs="+attributes,+quotes"]
----
SELECT * FROM _<data-collection>_ WHERE _<filter>_ ....
----

The following example shows a SQL query to send an ad hoc incremental snapshot request with an additional condition to the signaling {data-collection}:
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) VALUES (_'<id>'_, _'<snapshotType>'_, '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"_<snapshotType>_","additional-conditions":[{"data-collection": "_<tableName>_", "filter": "_<additional-condition>_"}]}');
----

For example, suppose you have a `products` {data-collection} that contains the following columns:

* `id` (primary key)
* `color`
* `quantity`

If you want an incremental snapshot of the `products` {data-collection} to include only the data items where `color=blue`, you can use the following SQL statement to trigger the snapshot:

[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) VALUES('ad-hoc-1', 'execute-snapshot', '{"data-collections": ["schema1.products"],"type":"incremental", "additional-conditions":[{"data-collection": "schema1.products", "filter": "color=blue"}]}');
----

The `additional-conditions` parameter also enables you to pass conditions that are based on more than one column.
For example, using the `products` {data-collection} from the previous example, you can submit a query that triggers an incremental snapshot that includes the data of only those items for which `color=blue` and `quantity>10`:

[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) VALUES('ad-hoc-1', 'execute-snapshot', '{"data-collections": ["schema1.products"],"type":"incremental", "additional-conditions":[{"data-collection": "schema1.products", "filter": "color=blue AND quantity>10"}]}');
----

The following example, shows the JSON for an incremental snapshot event that is captured by a connector.

.Example: Incremental snapshot event message
[source,json,index=0]
----
{
    "before":null,
    "after": {
        "pk":"1",
        "value":"New data"
    },
    "source": {
        ...
        "snapshot":"incremental" <1>
    },
    "op":"r", <2>
    "ts_ms":"1620393591654",
    "ts_us":"1620393591654547",
    "ts_ns":"1620393591654547920",
    "transaction":null
}
----
[cols="1,1,4",options="header"]
|===
|Item |Field name |Description
|1
|`snapshot`
|Specifies the type of snapshot operation to run. +
Currently, the only valid options are `blocking` and `incremental`. +
Specifying a `type` value in the SQL query that you submit to the signaling {data-collection} is optional. +
If you do not specify a value, the connector runs an incremental snapshot.

|2
|`op`
|Specifies the event type. +
The value for snapshot events is `r`, signifying a `READ` operation.

|===

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-postgresql-using-the-kafka-signaling-channel-to-trigger-an-incremental-snapshot
[id="postgresql-triggering-an-incremental-snapshot-kafka"]
==== Using the Kafka signaling channel to trigger an incremental snapshot

:leveloffset: +1

You can send a message to the {link-prefix}:{link-signalling}#debezium-signaling-enabling-kafka-signaling-channel[configured Kafka topic] to request the connector to run an ad hoc incremental snapshot.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value of the message is a JSON object with `type` and `data` fields.

The signal type is `execute-snapshot`, and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6a",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed.
Currently {prodname} supports the `incremental` and `blocking` types. +
See the next section for more details.

|`data-collections`
|_N/A_
| An array of comma-separated regular expressions that match the fully-qualified names of tables to include in the snapshot. +
Specify the names by using the same format as is required for the xref:{context}-property-signal-data-collection[signal.data.collection] configuration option.

|`[.line-through]#additional-condition#`
|_N/A_
| An optional string that specifies a condition that the connector evaluates to designate a subset of records to include in a snapshot. +

[NOTE]
====
This property is deprecated and should be replaced by the `additional-conditions` property.
====

|`additional-conditions`
|_N/A_
| An optional array of additional conditions that specifies criteria that the connector evaluates to designate a subset of records to include in a snapshot. +
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:
`data-collection`:: The fully-qualified name of the {data-collection} that the filter applies to.
You can apply different filters to each {data-collection}.
`filter`:: Specifies column values that must be present in a database record for the snapshot to include it, for example,  `"color='blue'"`. +
 +
The values that you assign to the `filter` parameter are the same types of values that you might specify in the `WHERE` clause of `SELECT` statements when you set the `snapshot.select.statement.overrides` property for a blocking snapshot.
In earlier {prodname} releases, an explicit `filter` parameter was not defined for snapshot signals; instead, filter criteria were implied by the values that were specified for the now deprecated `additional-condition` parameter.
|===

An example of the execute-snapshot Kafka message:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

.Ad hoc incremental snapshots with additional-conditions

{prodname} uses the `additional-conditions` field to select a subset of a {data-collection}'s content.

Typically, when {prodname} runs a snapshot, it runs a SQL query such as:

`SELECT * FROM _<tableName>_ ....`

When the snapshot request includes an `additional-conditions` property, the `data-collection` and `filter` parameters of the  property are appended to the SQL query, for example:

`SELECT * FROM _<data-collection>_ WHERE _<filter>_ ....`

For example, given a `products` {data-collection} with the columns `id` (primary key), `color`, and `brand`, if you want a snapshot to include only content for which `color='blue'`, when you request the snapshot, you could add the `additional-conditions` property to filter the content:
----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "schema1.products" ,"filter":"color='blue'"}]}}`
----

You can use the `additional-conditions` property to pass conditions based on multiple columns.
For example, using the same `products` {data-collection} as in the previous example, if you want a snapshot to include only the content from the `products` {data-collection} for which `color='blue'`, and `brand='MyBrand'`, you could send the following request:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "schema1.products" ,"filter":"color='blue' AND brand='MyBrand'"}]}}`
----

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-postgresql-stopping-an-incremental-snapshot
[id="postgresql-stopping-an-incremental-snapshot"]
==== Stopping an incremental snapshot

:leveloffset: +1

You can also stop an incremental snapshot by sending a signal to the {data-collection} on the source database.
You submit a stop snapshot signal to the {data-collection} by sending a SQL `INSERT` query.

After {prodname} detects the change in the signaling {data-collection}, it reads the signal, and stops the incremental snapshot operation if it's in progress.

The query that you submit specifies the snapshot operation of `incremental`, and, optionally, the {data-collection}s of the current running snapshot to be removed.

.Prerequisites

* {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[Signaling is enabled]. +
** A signaling data collection exists on the source database.
** The signaling data collection is specified in the xref:{context}-property-signal-data-collection[`signal.data.collection`] property.

.Using a source signaling channel to stop an incremental snapshot

. Send a SQL query to stop the ad hoc incremental snapshot to the signaling {data-collection}:
+
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) values (_'<id>'_, 'stop-snapshot', '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"incremental"}');
----
+
For example,
+
[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) // <1>
values ('ad-hoc-1',   // <2>
    'stop-snapshot',  // <3>
    '{"data-collections": ["schema1.table1", "schema2.table2"], // <4>
    "type":"incremental"}'); // <5>
----
+
The values of the `id`, `type`, and `data` parameters in the signal command correspond to the {link-prefix}:{link-signalling}#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection[fields of the signaling {data-collection}].
+
The following table describes the parameters in the example:
+
.Descriptions of fields in a SQL command for sending a stop incremental snapshot signal to the signaling {data-collection}
[cols="1,2,6",options="header"]
|===
|Item|Value |Description

|1
|`myschema.debezium_signal`
|Specifies the fully-qualified name of the signaling {data-collection} on the source database.

|2
|`ad-hoc-1`
| The `id` parameter specifies an arbitrary string that is assigned as the `id` identifier for the signal request. +
Use this string to identify logging messages to entries in the signaling {data-collection}.
{prodname} does not use this string.

|3
|`stop-snapshot`
| Specifies `type` parameter specifies the operation that the signal is intended to trigger. +

|4
|`data-collections`
|An optional component of the `data` field of a signal that specifies an array of {data-collection} names or regular expressions to match {data-collection} names to remove from the snapshot. +
The array lists regular expressions which match {data-collection}s by their fully-qualified names, using the same format as you use to specify the name of the connector's signaling {data-collection} in the xref:{context}-property-signal-data-collection[`signal.data.collection`] configuration property.
If this component of the `data` field is omitted, the signal stops the entire incremental snapshot that is in progress.

|5
|`incremental`
|A required component of the `data` field of a signal that specifies the type of snapshot operation that is to be stopped. +
Currently, the only valid option is `incremental`. +
If you do not specify a `type` value, the signal fails to stop the incremental snapshot.
|===

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-postgresql-using-the-kafka-signaling-channel-to-stop-an-incremental-snapshot
[id="postgresql-stopping-an-incremental-snapshot-kafka"]
==== Using the Kafka signaling channel to stop an incremental snapshot

:leveloffset: +1

You can send a signal message to the {link-prefix}:{link-signalling}#debezium-signaling-enabling-kafka-signaling-channel[configured Kafka signaling topic] to stop an ad hoc incremental snapshot.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value of the message is a JSON object with `type` and `data` fields.

The signal type is `stop-snapshot`, and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed.
Currently {prodname} supports only the `incremental` type.  +
See the next section for more details.

|`data-collections`
|_N/A_
| An optional array of comma-separated regular expressions that match the fully-qualified names of the tables to include in the snapshot. +
Specify the names by using the same format as is required for the xref:{context}-property-signal-data-collection[signal.data.collection] configuration option.

|===

The following example shows a typical `stop-snapshot` Kafka message:

----
Key = `test_connector`

Value = `{"type":"stop-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

:leveloffset: 1

[id="postgresql-read-only-incremental-snapshots"]
==== Read-only incremental snapshots

You can configure a PostgreSQL connector that has a read-only connection to the database to run incremental snapshots without requiring a signal data collection table.
To run an incremental snapshot with read-only access, the connector uses the current in-progress transaction as high and low watermarks.
The state of a chunk's window is updated by comparing the transaction ID of write-ahead-log events or heartbeat events against low and high watermarks.

To switch to a read-only implementation, set the value of the xref:postgres-property-read-only[`read.only`] property to `true`.

.Prerequisites

* PostgreSQL version 13 or later.

==== Ad hoc read-only incremental snapshots

When the PostgreSQL connection is read-only, you can use any of the {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[available signaling channels] without the requirement to use the `source` channel.

[[connector-custom-snapshot]]
=== Custom snapshotter SPI
:leveloffset: +3

For more advanced uses, you can fine-tune control of the snapshot by implementing one of the following interfaces:

`io.debezium.snapshot.spi.Snapshotter`:: Controls whether the connector takes a snapshot.
`io.debezium.snapshot.spi.SnapshotQuery`:: Controls how data is queried during a snapshot.
`io.debezium.snapshot.spi.SnapshotLock`:: Controls whether the connector locks tables when taking a snapshot.


[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.Snapshotter interface. All built-in snapshot modes implement this interface.
----
/**
 * {@link Snapshotter} is used to determine the following details about the snapshot process:
 * <p>
 * - Whether a snapshot occurs. <br>
 * - Whether streaming continues during the snapshot. <br>
 * - Whether the snapshot includes schema (if supported). <br>
 * - Whether to snapshot data or schema following an error.
 * <p>
 * Although Debezium provides many default snapshot modes,
 * to provide more advanced functionality, such as partial snapshots,
 * you can customize implementation of the interface.
 * For more information, see the documentation.
 *
 *
 *
 */
@Incubating
public interface Snapshotter extends Configurable {

    /**
     * @return the name of the snapshotter.
     *
     *
     */
    String name();

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a data snapshot
     */
    boolean shouldSnapshotData(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a schema snapshot
     */
    boolean shouldSnapshotSchema(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @return {@code true} if the snapshotter should stream after taking a snapshot
     */
    boolean shouldStream();

    /**
     * @return {@code true} whether the schema can be recovered if database schema history is corrupted.
     */
    boolean shouldSnapshotOnSchemaError();

    /**
     * @return {@code true} whether the snapshot should be re-executed when there is a gap in data stream.
     */
    boolean shouldSnapshotOnDataError();

    /**
     *
     * @return {@code true} if streaming should resume from the start of the snapshot
     * transaction, or {@code false} for when a connector resumes and takes a snapshot,
     * streaming should resume from where streaming previously left off.
     */
    default boolean shouldStreamEventsStartingFromSnapshot() {
        return true;
    }

    /**
     * Lifecycle hook called after the snapshot phase is successful.
     */
    default void snapshotCompleted() {
        // no operation
    }

    /**
     * Lifecycle hook called after the snapshot phase is aborted.
     */
    default void snapshotAborted() {
        // no operation
    }
}
----

[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.SnapshotQuery interface. All built-in snapshot query modes implement this interface.
----
/**
 * {@link SnapshotQuery} is used to determine the query used during a data snapshot
 *
 *
 */
public interface SnapshotQuery extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Generate a valid query string for the specified table, or an empty {@link Optional}
     * to skip snapshotting this table (but that table will still be streamed from)
     *
     * @param tableId the table to generate a query for
     * @param snapshotSelectColumns the columns to be used in the snapshot select based on the column
     *                              include/exclude filters
     * @return a valid query string, or none to skip snapshotting this table
     */
    Optional<String> snapshotQuery(String tableId, List<String> snapshotSelectColumns);

}
----

[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.SnapshotLock interface. All built-in snapshot lock modes implement this interface.
----
/**
 * {@link SnapshotLock} is used to determine the table lock mode used during schema snapshot
 *
 *
 */
public interface SnapshotLock extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Returns a SQL statement for locking the given table during snapshotting, if required by the specific snapshotter
     * implementation.
     */
    Optional<String> tableLockingStatement(Duration lockTimeout, String tableId);

}
----

:leveloffset: 1

// Type: concept
[id="postgresql-blocking-snapshots"]
=== Blocking snapshots

:leveloffset: +3

To provide more flexibility in managing snapshots, {prodname} includes a supplementary ad hoc snapshot mechanism, known as a _blocking snapshot_.
Blocking snapshots rely on the {prodname} mechanism for {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[sending signals to a {prodname} connector].

A blocking snapshot behaves just like an _initial snapshot_, except that you can trigger it at run time.

You might want to run a blocking snapshot rather than use the standard initial snapshot process in the following situations:

* You add a new {data-collection} and you want to complete the snapshot while the connector is running.
* You add a large {data-collection}, and you want the snapshot to complete in less time than is possible with an incremental snapshot.

.Blocking snapshot process
When you run a blocking snapshot, {prodname} stops streaming, and then initiates a snapshot of the specified {data-collection}, following the same process that it uses during an initial snapshot.
After the snapshot completes, the streaming is resumed.

.Configure snapshot

You can set the following properties in the `data` component of a signal:

 * data-collections: to specify which {data-collection}s must be snapshot
 * additional-conditions: You can specify different filters for different {data-collection}. +
 ** The `data-collection` property is the fully-qualified name of the {data-collection} for which the filter will be applied.
 ** The `filter` property will have the same value used in the  `snapshot.select.statement.overrides`

For example:
[source,json]
----
  {"type": "blocking", "data-collections": ["schema1.table1", "schema1.table2"], "additional-conditions": [{"data-collection": "schema1.table1", "filter": "SELECT * FROM [schema1].[table1] WHERE column1 = 0 ORDER BY column2 DESC"}, {"data-collection": "schema1.table2", "filter": "SELECT * FROM [schema1].[table2] WHERE column2 > 0"}]}
----

.Possible duplicates
A delay might exist between the time that you send the signal to trigger the snapshot, and the time when streaming stops and the snapshot starts.
As a result of this delay, after the snapshot completes, the connector might emit some event records that duplicate records captured by the snapshot.

:leveloffset: 1

// Type: concept
// ModuleID: how-debezium-postgresql-connectors-stream-change-event-records
// Title: How {prodname} PostgreSQL connectors stream change event records
[[postgresql-streaming-changes]]
=== Streaming changes

The PostgreSQL connector typically spends the vast majority of its time streaming changes from the PostgreSQL server to which it is connected. This mechanism relies on link:https://www.postgresql.org/docs/current/static/protocol-replication.html[_PostgreSQL's replication protocol_]. This protocol enables clients to receive changes from the server as they are committed in the server's transaction log at certain positions, which are referred to as Log Sequence Numbers (LSNs).

Whenever the server commits a transaction, a separate server process invokes a callback function from the xref:postgresql-output-plugin[logical decoding plug-in]. This function processes the changes from the transaction, converts them to a specific format (Protobuf or JSON in the case of {prodname} plug-in) and writes them on an output stream, which can then be consumed by clients.

The {prodname} PostgreSQL connector acts as a PostgreSQL client. When the connector receives changes it transforms the events into {prodname} _create_, _update_, or _delete_ events that include the LSN of the event. The PostgreSQL connector forwards these change events in records to the Kafka Connect framework, which is running in the same process. The Kafka Connect process asynchronously writes the change event records in the same order in which they were generated to the appropriate Kafka topic.

Periodically, Kafka Connect records the most recent _offset_ in another Kafka topic. The offset indicates source-specific position information that {prodname} includes with each event. For the PostgreSQL connector, the LSN recorded in each change event is the offset.

When Kafka Connect gracefully shuts down, it stops the connectors, flushes all event records to Kafka, and records the last offset received from each connector. When Kafka Connect restarts, it reads the last recorded offset for each connector, and starts each connector at its last recorded offset. When the connector restarts, it sends a request to the PostgreSQL server to send the events starting just after that position.

[NOTE]
====
The PostgreSQL connector retrieves schema information as part of the events sent by the logical decoding plug-in. However, the connector does not retrieve information about which columns compose the primary key. The connector obtains this information from the JDBC metadata (side channel). If the primary key definition of a table changes (by adding, removing or renaming primary key columns), there is a tiny period of time when the primary key information from JDBC is not synchronized with the change event that the logical decoding plug-in generates. During this tiny period, a message could be created with an inconsistent key structure. To prevent this inconsistency, update primary key structures as follows:

. Put the database or an application into a read-only mode.
. Let {prodname} process all remaining events.
. Stop {prodname}.
. Update the primary key definition in the relevant table.
. Put the database or the application into read/write mode.
. Restart {prodname}.
====

[[postgresql-pgoutput]]
=== PostgreSQL 10+ logical decoding support (`pgoutput`)

As of PostgreSQL 10+, there is a logical replication stream mode, called `pgoutput` that is natively supported by PostgreSQL. This means that a {prodname} PostgreSQL connector can consume that replication stream
without the need for additional plug-ins.
This is particularly valuable for environments where installation of plug-ins is not supported or not allowed.

For more information, see xref:setting-up-postgresql[Setting up PostgreSQL].

// Type: concept
// ModuleID: default-names-of-kafka-topics-that-receive-debezium-postgresql-change-event-records
// Title: Default names of Kafka topics that receive {prodname} PostgreSQL change event records
[[postgresql-topic-names]]
=== Topic names

By default, the PostgreSQL connector writes change events for all `INSERT`, `UPDATE`, and `DELETE` operations that occur in a table to a single Apache Kafka topic that is specific to that table.
The connector uses the following convention to name change event topics:

_topicPrefix.schemaName.tableName_

The following list provides definitions for the components of the default name:

_topicPrefix_:: The topic prefix as specified by the xref:postgresql-property-topic-prefix[`topic.prefix`] configuration property.
_schemaName_:: The name of the database schema in which the change event occurred.
_tableName_:: The name of the database table in which the change event occurred.

For example, suppose that `fulfillment` is the logical server name in the configuration for a connector that is capturing changes in a PostgreSQL installation that has a `postgres` database and an `inventory` schema that contains four tables: `products`, `products_on_hand`, `customers`, and `orders`. The connector would stream records to these four Kafka topics:

* `fulfillment.inventory.products`
* `fulfillment.inventory.products_on_hand`
* `fulfillment.inventory.customers`
* `fulfillment.inventory.orders`

Now suppose that the tables are not part of a specific schema but were created in the default `public` PostgreSQL schema. The names of the Kafka topics would be:

* `fulfillment.public.products`
* `fulfillment.public.products_on_hand`
* `fulfillment.public.customers`
* `fulfillment.public.orders`

The connector applies similar naming conventions to label its xref:postgresql-transaction-metadata[transaction metadata topics].

If the default topic name do not meet your requirements, you can configure custom topic names.
To configure custom topic names, you specify regular expressions in the logical topic routing SMT.
For more information about using the logical topic routing SMT to customize topic naming, see {link-prefix}:{link-topic-routing}#topic-routing[Topic routing].

// Type: concept
// ModuleID: debezium-postgresql-connector-generated-events-that-represent-transaction-boundaries
// Title: {prodname} PostgreSQL connector-generated events that represent transaction boundaries
[[postgresql-transaction-metadata]]
=== Transaction metadata

{prodname} can generate events that represent transaction boundaries and that enrich data change event messages.

[NOTE]
.Limits on when {prodname} receives transaction metadata
====
{prodname} registers and receives metadata only for transactions that occur after you deploy the connector.
Metadata for transactions that occur before you deploy the connector is not available.
====

For every transaction `BEGIN` and `END`, {prodname} generates an event that contains the following fields:

`status`:: `BEGIN` or `END`.
`id`:: String representation of the unique transaction identifier composed of Postgres transaction ID itself and LSN of given operation separated by colon, i.e. the format is `txID:LSN`.
`ts_ms`:: The time of a transaction boundary event (`BEGIN` or `END` event) at the data source.
If the data source does not provide {prodname} with the event time, then the field instead represents the time at which {prodname} processes the event.
`event_count` (for `END` events):: Total number of events emmitted by the transaction.
`data_collections` (for `END` events):: An array of pairs of `data_collection` and `event_count` elements that indicates the number of events that the connector emits for changes that originate from a data collection.

.Example

[source,json,indent=0,subs="+attributes"]
----
{
  "status": "BEGIN",
  "id": "571:53195829",
  "ts_ms": 1486500577125,
  "event_count": null,
  "data_collections": null
}

{
  "status": "END",
  "id": "571:53195832",
  "ts_ms": 1486500577691,
  "event_count": 2,
  "data_collections": [
    {
      "data_collection": "s1.a",
      "event_count": 1
    },
    {
      "data_collection": "s2.a",
      "event_count": 1
    }
  ]
}
----

Unless overridden via the xref:postgresql-property-topic-transaction[`topic.transaction`] option,
transaction events are written to the topic named xref:postgresql-property-topic-prefix[`_<topic.prefix>_`]`.transaction`.

.Change data event enrichment

When transaction metadata is enabled the data message `Envelope` is enriched with a new `transaction` field.
This field provides information about every event in the form of a composite of fields:

`id`:: String representation of unique transaction identifier.
`total_order`:: The absolute position of the event among all events generated by the transaction.
`data_collection_order`:: The per-data collection position of the event among all events that were emitted by the transaction.

Following is an example of a message:

[source,json,indent=0,subs="+attributes"]
----
{
  "before": null,
  "after": {
    "pk": "2",
    "aa": "1"
  },
  "source": {
   ...
  },
  "op": "c",
  "ts_ms": "1580390884335",
  "ts_us": "1580390884335451",
  "ts_ns": "1580390884335451325",
  "transaction": {
    "id": "571:53195832",
    "total_order": "1",
    "data_collection_order": "1"
  }
}
----

// Type: assembly
// ModuleID: descriptions-of-debezium-postgresql-connector-data-change-events
// Title: Descriptions of {prodname} PostgreSQL connector data change events
[[postgresql-events]]
== Data change events

The {prodname} PostgreSQL connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed.

{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained.

The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converter and you configure it to produce all four basic change event parts, change events have this structure:

[source,json,index=0]
----
{
 "schema": { // <1>
   ...
  },
 "payload": { // <2>
   ...
 },
 "schema": { // <3>
   ...
 },
 "payload": { // <4>
   ...
 },
}
----

.Overview of change event basic content
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +
 +
It is possible to override the table's primary key by setting the xref:postgresql-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.

|2
|`payload`
|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed.

|3
|`schema`
|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas.

|4
|`payload`
|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.

|===


By default behavior is that the connector streams change event records to xref:postgresql-topic-names[topics with names that are the same as the event's originating table].

[NOTE]
====
Starting with Kafka 0.10, Kafka can optionally record the event key and value with the {link-kafka-docs}.html#upgrade_10_performance_impact[_timestamp_] at which the message was created (recorded by the producer) or written to the log by Kafka.
====

[WARNING]
====
The PostgreSQL connector ensures that all Kafka Connect schema names adhere to the http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or \_. Each remaining character in the logical server name and each character in the schema and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or \_. If there is an invalid character it is replaced with an underscore character.

This can lead to unexpected conflicts if the logical server name, a schema name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.
====


// Type: concept
// ModuleID: about-keys-in-debezium-postgresql-change-events
// Title: About keys in {prodname} PostgreSQL change events
[[postgresql-change-events-key]]
=== Change event keys

For a given table, the change event's key has a structure that contains a field for each column in the primary key of the table at the time the event was created. Alternatively, if the table has `REPLICA IDENTITY` set to `FULL` or `USING INDEX` there is a field for each unique key constraint.

Consider a `customers` table defined in the `public` database schema and the example of a change event key for that table.

.Example table
[source,sql,indent=0]
----
CREATE TABLE customers (
  id SERIAL,
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL,
  PRIMARY KEY(id)
);
----

.Example change event key
If the `topic.prefix` connector configuration property has the value `PostgreSQL_server`, every change event for the `customers` table while it has this definition has the same key structure, which in JSON looks like this:

[source,json,indent=0]
----
  {
    "schema": { // <1>
      "type": "struct",
      "name": "PostgreSQL_server.public.customers.Key", // <2>
      "optional": false, // <3>
      "fields": [ // <4>
            {
                "name": "id",
                "index": "0",
                "schema": {
                    "type": "INT32",
                    "optional": "false"
                }
            }
        ]
    },
    "payload": { // <5>
        "id": "1"
    },
  }
----

.Description of change event key
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion.

|2
|`PostgreSQL_server.inventory.customers.Key`
a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: +

* `PostgreSQL_server` is the name of the connector that generated this event. +
* `inventory` is the database that contains the table that was changed. +
* `customers` is the table that was updated.

|3
|`optional`
|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.

|4
|`fields`
|Specifies each field that is expected in the `payload`, including each field's name, index, and schema.

|5
|`payload`
|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1`.

|===

[NOTE]
====
Although the `column.exclude.list` and `column.include.list` connector configuration properties allow you to capture only a subset of table columns, all columns in a primary or unique key are always included in the event's key.
====

[WARNING]
====
If the table does not have a primary or unique key, then the change event's key is null. The rows in a table without a primary or unique key constraint cannot be uniquely identified.
====

// Type: concept
// ModuleID: about-values-in-debezium-postgresql-change-events
// Title: About values in {prodname} PostgreSQL change events
[[postgresql-change-events-value]]
=== Change event values

The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure.

Consider the same sample table that was used to show an example of a change event key:

[source,sql,indent=0]
----
CREATE TABLE customers (
  id SERIAL,
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL,
  PRIMARY KEY(id)
);
----

The value portion of a change event for a change to this table varies according to the `REPLICA IDENTITY` setting and the operation that the event is for.


// Type: continue
[[postgresql-replica-identity]]
=== Replica identity

link:https://www.postgresql.org/docs/current/static/sql-altertable.html#SQL-CREATETABLE-REPLICA-IDENTITY[REPLICA IDENTITY] is a PostgreSQL-specific table-level setting that determines the amount of information that is available to the logical decoding plug-in for `UPDATE` and `DELETE` events. More specifically, the setting of `REPLICA IDENTITY` controls what (if any) information is available for the previous values of the table columns involved, whenever an `UPDATE` or `DELETE` event occurs.

There are 4 possible values for `REPLICA IDENTITY`:

* `DEFAULT` - The default behavior is that `UPDATE` and `DELETE` events contain the previous values for the primary key columns of a table if that table has a primary key. For an `UPDATE` event, only the primary key columns with changed values are present.
+
If a table does not have a primary key, the connector does not emit `UPDATE` or `DELETE` events for that table. For a table without a primary key, the connector emits only _create_ events. Typically, a table without a primary key is used for appending messages to the end of the table, which means that `UPDATE` and `DELETE` events are not useful.
* `NOTHING` - Emitted events for `UPDATE` and `DELETE` operations do not contain any information about the previous value of any table column.
* `FULL` - Emitted events for `UPDATE` and `DELETE` operations contain the previous values of all columns in the table.
* `INDEX` _index-name_ - Emitted events for `UPDATE` and `DELETE` operations contain the previous values of the columns contained in the specified index. `UPDATE` events also contain the indexed columns with the updated values.

// Type: continue
[[postgresql-create-events]]
=== _create_ events

The following example shows the value portion of a change event that the connector generates for an operation that creates data in the `customers` table:

[source,json,options="nowrap",indent=0,subs="+attributes"]
----
{
    "schema": { // <1>
        "type": "struct",
        "fields": [
            {
                "type": "struct",
                "fields": [
                    {
                        "type": "int32",
                        "optional": false,
                        "field": "id"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "first_name"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "last_name"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "email"
                    }
                ],
                "optional": true,
                "name": "PostgreSQL_server.inventory.customers.Value", // <2>
                "field": "before"
            },
            {
                "type": "struct",
                "fields": [
                    {
                        "type": "int32",
                        "optional": false,
                        "field": "id"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "first_name"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "last_name"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "email"
                    }
                ],
                "optional": true,
                "name": "PostgreSQL_server.inventory.customers.Value",
                "field": "after"
            },
            {
                "type": "struct",
                "fields": [
                    {
                        "type": "string",
                        "optional": false,
                        "field": "version"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "connector"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "name"
                    },
                    {
                        "type": "int64",
                        "optional": false,
                        "field": "ts_ms"
                    },
                    {
                        "type": "int64",
                        "optional": false,
                        "field": "ts_us"
                    },
                    {
                        "type": "int64",
                        "optional": false,
                        "field": "ts_ns"
                    },
                    {
                        "type": "boolean",
                        "optional": true,
                        "default": false,
                        "field": "snapshot"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "db"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "schema"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "table"
                    },
                    {
                        "type": "int64",
                        "optional": true,
                        "field": "txId"
                    },
                    {
                        "type": "int64",
                        "optional": true,
                        "field": "lsn"
                    },
                    {
                        "type": "int64",
                        "optional": true,
                        "field": "xmin"
                    }
                ],
                "optional": false,
                "name": "io.debezium.connector.postgresql.Source", // <3>
                "field": "source"
            },
            {
                "type": "string",
                "optional": false,
                "field": "op"
            },
            {
                "type": "int64",
                "optional": true,
                "field": "ts_ms"
            },
            {
                "type": "int64",
                "optional": true,
                "field": "ts_us"
            },
            {
                "type": "int64",
                "optional": true,
                "field": "ts_ns"
            }
        ],
        "optional": false,
        "name": "PostgreSQL_server.inventory.customers.Envelope" // <4>
    },
    "payload": { // <5>
        "before": null, // <6>
        "after": { // <7>
            "id": 1,
            "first_name": "Anne",
            "last_name": "Kretchmar",
            "email": "annek@noanswer.org"
        },
        "source": { // <8>
            "version": "{debezium-version}",
            "connector": "postgresql",
            "name": "PostgreSQL_server",
            "ts_ms": 1559033904863,
            "ts_us": 1559033904863123,
            "ts_ns": 1559033904863123000,
            "snapshot": true,
            "db": "postgres",
            "sequence": "[\"24023119\",\"24023128\"]",
            "schema": "public",
            "table": "customers",
            "txId": 555,
            "lsn": 24023128,
            "xmin": null
        },
        "op": "c", // <9>
        "ts_ms": 1559033904863, // <10>
        "ts_us": 1559033904863841, // <10>
        "ts_ns": 1559033904863841257 // <10>
    }
}
----


.Descriptions of _create_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The value's schema, which describes the structure of the value's payload. A change event's value schema is the same in every change event that the connector generates for a particular table.

|2
|`name`
a|In the `schema` section, each `name` field specifies the schema for a field in the value's payload. +
 +
`PostgreSQL_server.inventory.customers.Value` is the schema for the payload's `before` and `after` fields. This schema is specific to the `customers` table. +
 +
Names of schemas for `before` and `after` fields are of the form `_logicalName_._tableName_.Value`, which ensures that the schema name is unique in the database.
This means that when using the {link-prefix}:{link-avro-serialization}#avro-serialization[Avro converter], the resulting Avro schema for each table in each logical source has its own evolution and history.

|3
|`name`
a|`io.debezium.connector.postgresql.Source` is the schema for the payload's `source` field. This schema is specific to the PostgreSQL connector. The connector uses it for all events that it generates.

|4
|`name`
a|`PostgreSQL_server.inventory.customers.Envelope` is the schema for the overall structure of the payload, where `PostgreSQL_server` is the connector name, `inventory` is the database, and `customers` is the table.

|5
|`payload`
|The value's actual data. This is the information that the change event is providing. +
 +
It may appear that the JSON representations of the events are much larger than the rows they describe. This is because the JSON representation must include the schema and the payload portions of the message.
However, by using the {link-prefix}:{link-avro-serialization}#avro-serialization[Avro converter], you can significantly decrease the size of the messages that the connector streams to Kafka topics.

|6
|`before`
a|An optional field that specifies the state of the row before the event occurred. When the `op` field is `c` for create, as it is in this example, the `before` field is `null` since this change event is for new content.  +
 +
[NOTE]
====
Whether or not this field is available is dependent on the xref:postgresql-replica-identity[`REPLICA IDENTITY`] setting for each table.
====

|7
|`after`
|An optional field that specifies the state of the row after the event occurred. In this example, the `after` field contains the values of the new row's `id`, `first_name`, `last_name`, and `email` columns.

|8
|`source`
a|Mandatory field that describes the source metadata for the event. This field contains information that you can use to compare this event with other events, with regard to the origin of the events, the order in which the events occurred, and whether events were part of the same transaction. The source metadata includes:

* {prodname} version
* Connector type and name
* Database and table that contains the new row
* Stringified JSON array of additional offset information. The first value is always the last committed LSN, the second value is always the current LSN. Either value may be `null`.
* Schema name
* If the event was part of a snapshot
* ID of the transaction in which the operation was performed
* Offset of the operation in the database log
* Timestamp for when the change was made in the database

|9
|`op`
a|Mandatory string that describes the type of operation that caused the connector to generate the event. In this example, `c` indicates that the operation created a row. Valid values are:

* `c` = create
* `u` = update
* `d` = delete
* `r` = read (applies to only snapshots)
* `t` = truncate
* `m` = message

|10
|`ts_ms`, `ts_us`, `ts_ns`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

// Type: continue
[[postgresql-update-events]]
=== _update_ events

The value of a change event for an update in the sample `customers` table has the same schema as a _create_ event for that table. Likewise, the event value's payload has the same structure. However, the event value payload contains different values in an _update_ event. Here is an example of a change event value in an event that the connector generates for an update in the `customers` table:

[source,json,indent=0,options="nowrap",subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "before": { // <1>
            "id": 1
        },
        "after": { // <2>
            "id": 1,
            "first_name": "Anne Marie",
            "last_name": "Kretchmar",
            "email": "annek@noanswer.org"
        },
        "source": { // <3>
            "version": "{debezium-version}",
            "connector": "postgresql",
            "name": "PostgreSQL_server",
            "ts_ms": 1559033904863,
            "ts_us": 1559033904863769,
            "ts_ns": 1559033904863769000,
            "snapshot": false,
            "db": "postgres",
            "schema": "public",
            "table": "customers",
            "txId": 556,
            "lsn": 24023128,
            "xmin": null
        },
        "op": "u", // <4>
        "ts_ms": 1465584025523,  // <5>
        "ts_us": 1465584025523514,  // <5>
        "ts_ns": 1465584025523514964,  // <5>
    }
}
----

.Descriptions of _update_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|An optional field that contains values that were in the row before the database commit. In this example, only the primary key column, `id`, is present because the table's xref:postgresql-replica-identity[`REPLICA IDENTITY`] setting is, by default, `DEFAULT`.
+
For an _update_ event to contain the previous values of all columns in the row, you would have to change the `customers` table by running `ALTER TABLE customers REPLICA IDENTITY FULL`.

|2
|`after`
|An optional field that specifies the state of the row after the event occurred. In this example, the `first_name` value is now `Anne Marie`.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. The `source` field structure has the same fields as in a _create_ event, but some values are different. The source metadata includes:

* {prodname} version
* Connector type and name
* Database and table that contains the new row
* Schema name
* If the event was part of a snapshot (always `false` for _update_ events)
* ID of the transaction in which the operation was performed
* Offset of the operation in the database log
* Timestamp for when the change was made in the database

|4
|`op`
a|Mandatory string that describes the type of operation. In an _update_ event value, the `op` field value is `u`, signifying that this row changed because of an update.

|5
|`ts_ms`, `ts_us`, `ts_ns`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

[NOTE]
====
Updating the columns for a row's primary/unique key changes the value of the row's key. When a key changes, {prodname} outputs _three_ events: a `DELETE` event and a xref:postgresql-tombstone-events[tombstone event] with the old key for the row, followed by an event with the new key for the row. Details are in the next section.
====

// Type: continue
[[postgresql-primary-key-updates]]
=== Primary key updates

An `UPDATE` operation that changes a row's primary key field(s) is known
as a primary key change. For a primary key change, in place of sending an `UPDATE` event record, the connector sends a `DELETE` event record for the old key and a `CREATE` event record for the new (updated) key. These events have the usual structure and content, and in addition, each one has a message header related to the primary key change:

* The `DELETE` event record has `__debezium.newkey` as a message header. The value of this header is the new primary key for the updated row.

* The `CREATE` event record has `__debezium.oldkey` as a message header. The value of this header is the previous (old) primary key that the updated row had.

// Type: continue
[[postgresql-delete-events]]
=== _delete_ events

The value in a _delete_ change event has the same `schema` portion as _create_ and _update_ events for the same table. The `payload` portion in a _delete_ event for the sample `customers` table looks like this:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "before": { // <1>
            "id": 1
        },
        "after": null, // <2>
        "source": { // <3>
            "version": "{debezium-version}",
            "connector": "postgresql",
            "name": "PostgreSQL_server",
            "ts_ms": 1559033904863,
            "ts_us": 1559033904863852,
            "ts_ns": 1559033904863852000,
            "snapshot": false,
            "db": "postgres",
            "schema": "public",
            "table": "customers",
            "txId": 556,
            "lsn": 46523128,
            "xmin": null
        },
        "op": "d", // <4>
        "ts_ms": 1465581902461, // <5>
        "ts_us": 1465581902461496, // <5>
        "ts_ns": 1465581902461496187, // <5>
    }
}
----

.Descriptions of _delete_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|Optional field that specifies the state of the row before the event occurred. In a _delete_ event value, the `before` field contains the values that were in the row before it was deleted with the database commit. +
 +
In this example, the `before` field contains only the primary key column because the table's xref:postgresql-replica-identity[`REPLICA IDENTITY`] setting is `DEFAULT`.

|2
|`after`
|Optional field that specifies the state of the row after the event occurred. In a _delete_ event value, the `after` field is `null`, signifying that the row no longer exists.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. In a _delete_ event value, the `source` field structure is the same as for _create_ and _update_ events for the same table. Many `source` field values are also the same. In a _delete_ event value, the `ts_ms` and `lsn` field values, as well as other values, might have changed. But the `source` field in a _delete_ event value provides the same metadata:

* {prodname} version
* Connector type and name
* Database and table that contained the deleted row
* Schema name
* If the event was part of a snapshot (always `false` for _delete_ events)
* ID of the transaction in which the operation was performed
* Offset of the operation in the database log
* Timestamp for when the change was made in the database

|4
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `d`, signifying that this row was deleted.

|5
|`ts_ms`, `ts_us`, `ts_ns`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

A _delete_ change event record provides a consumer with the information it needs to process the removal of this row.

[WARNING]
====
For a consumer to be able to process a _delete_ event generated for a table that does not have a primary key, set the table's `REPLICA IDENTITY` to `FULL`. When a table does not have a primary key and the table's `REPLICA IDENTITY` is set to `DEFAULT` or `NOTHING`, a _delete_ event has no `before` field.
====

PostgreSQL connector events are designed to work with link:{link-kafka-docs}#compaction[Kafka log compaction]. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.

// Type: continue
[[postgresql-tombstone-events]]
.Tombstone events
When a row is deleted, the _delete_ event value still works with log compaction, because Kafka can remove all earlier messages that have that same key. However, for Kafka to remove all messages that have that same key, the message value must be `null`. To make this possible, the PostgreSQL connector follows a _delete_ event with a special _tombstone_ event that has the same key but a `null` value.

// Type: continue
[[postgresql-truncate-events]]
=== _truncate_ events

A  _truncate_ change event signals that a table has been truncated.
The message key is `null` in this case, the message value looks like this:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "source": { // <1>
            "version": "{debezium-version}",
            "connector": "postgresql",
            "name": "PostgreSQL_server",
            "ts_ms": 1559033904863,
            "ts_us": 1559033904863112,
            "ts_ns": 1559033904863112000,
            "snapshot": false,
            "db": "postgres",
            "schema": "public",
            "table": "customers",
            "txId": 556,
            "lsn": 46523128,
            "xmin": null
        },
        "op": "t", // <2>
        "ts_ms": 1559033904961, // <3>
        "ts_us": 1559033904961654, // <3>
        "ts_ns": 1559033904961654789 // <3>
    }
}
----

.Descriptions of _truncate_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`source`
a|Mandatory field that describes the source metadata for the event. In a _truncate_ event value, the `source` field structure is the same as for _create_, _update_, and _delete_ events for the same table, provides this metadata:

* {prodname} version
* Connector type and name
* Database and table that contains the new row
* Schema name
* If the event was part of a snapshot (always `false` for _delete_ events)
* ID of the transaction in which the operation was performed
* Offset of the operation in the database log
* Timestamp for when the change was made in the database

|2
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `t`, signifying that this table was truncated.

|3
|`ts_ms`, `ts_us`, `ts_ns`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

In case a single `TRUNCATE` statement applies to multiple tables,
one _truncate_ change event record for each truncated table will be emitted.

Note that since _truncate_ events represent a change made to an entire table and don't have a message key,
unless you're working with topics with a single partition,
there are no ordering guarantees for the change events pertaining to a table (_create_, _update_, etc.) and _truncate_ events for that table.
For instance a consumer may receive an _update_ event only after a _truncate_ event for that table,
when those events are read from different partitions.

// Type: continue
[[postgresql-message-events]]
=== _message_ events

[NOTE]
====
This event type is only supported through the `pgoutput` plugin on Postgres 14+ (link:https://www.postgresql.org/docs/14/protocol-logicalrep-message-formats.html[Postgres Documentation])
====

A  _message_ event signals that a generic logical decoding message has been inserted directly into the WAL typically with the `pg_logical_emit_message` function.
The message key is a `Struct` with a single field named `prefix` in this case, carrying the prefix specified when inserting the message.
The message value looks like this for transactional messages:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "source": { // <1>
            "version": "{debezium-version}",
            "connector": "postgresql",
            "name": "PostgreSQL_server",
            "ts_ms": 1559033904863,
            "ts_us": 1559033904863879,
            "ts_ns": 1559033904863879000,
            "snapshot": false,
            "db": "postgres",
            "schema": "",
            "table": "",
            "txId": 556,
            "lsn": 46523128,
            "xmin": null
        },
        "op": "m", // <2>
        "ts_ms": 1559033904961, // <3>
        "ts_us": 1559033904961621, // <3>
        "ts_ns": 1559033904961621379, // <3>
        "message": { // <4>
            "prefix": "foo",
            "content": "Ymfy"
        }
    }
}
----

Unlike other event types, non-transactional messages will not have any associated `BEGIN` or `END` transaction events.
The message value looks like this for non-transactional messages:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "source": { // <1>
            "version": "{debezium-version}",
            "connector": "postgresql",
            "name": "PostgreSQL_server",
            "ts_ms": 1559033904863,
            "ts_us": 1559033904863762,
            "ts_ns": 1559033904863762000,
            "snapshot": false,
            "db": "postgres",
            "schema": "",
            "table": "",
            "lsn": 46523128,
            "xmin": null
        },
        "op": "m", // <2>
        "ts_ms": 1559033904961, // <3>
        "ts_us": 1559033904961741, // <3>
        "ts_ns": 1559033904961741698, // <3>
        "message": { // <4>
            "prefix": "foo",
            "content": "Ymfy"
    }
}
----

.Descriptions of _message_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`source`
a|Mandatory field that describes the source metadata for the event. In a _message_ event value, the `source` field structure will not have `table` or `schema` information for any _message_ events and will only have `txId` if the _message_ event is transactional.

* {prodname} version
* Connector type and name
* Database name
* Schema name (always `""` for _message_ events)
* Table name (always `""` for _message_ events)
* If the event was part of a snapshot (always `false` for _message_ events)
* ID of the transaction in which the operation was performed (`null` for non-transactional _message_ events)
* Offset of the operation in the database log
* Transactional messages: Timestamp for when the message was inserted into the WAL
* Non-Transactional messages; Timestamp for when the connector encounters the message

|2
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `m`, signifying that this is a _message_ event.

|3
|`ts_ms`, `ts_us`, `ts_ns`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
For transactional _message_ events, the `ts_ms` attribute of the `source` object indicates the time that the change was made in the database for transactional _message_ events. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

For non-transactional _message_ events, the `source` object's `ts_ms` indicates time at which the connector encounters the _message_ event, while the `payload.ts_ms` indicates the time at which the connector processed the event. This difference is due to the fact that the commit timestamp is not present in Postgres's generic logical message format and non-transactional logical messages are not preceded by a `BEGIN` event (which has timestamp information).

|4
|`message`
a|Field that contains the message metadata

* Prefix (text)
* Content (byte array that is encoded based on the xref:postgresql-property-binary-handling-mode[binary handling mode] setting)

|===

// Type: reference
// ModuleID: how-debezium-postgresql-connectors-map-data-types
// Title: How {prodname} PostgreSQL connectors map data types
[[postgresql-data-types]]
== Data type mappings

The PostgreSQL connector represents changes to rows with events that are structured like the table in which the row exists. The event contains a field for each column value. How that value is represented in the event depends on the PostgreSQL data type of the column. The following sections describe how the connector maps PostgreSQL data types to a _literal type_ and a _semantic type_ in event fields.

* _literal type_ describes how the value is literally represented using Kafka Connect schema types: `INT8`, `INT16`, `INT32`, `INT64`, `FLOAT32`, `FLOAT64`, `BOOLEAN`, `STRING`, `BYTES`, `ARRAY`, `MAP`, and `STRUCT`.

* _semantic type_ describes how the Kafka Connect schema captures the _meaning_ of the field using the name of the Kafka Connect schema for the field.

If the default data type conversions do not meet your needs, you can xref:custom-postgres-connector-converters[create a custom converter] for the connector.


[id="postgresql-basic-types"]
=== Basic types

The following table describes how the connector maps basic types.

.Mappings for PostgreSQL basic data types
[cols="25%a,20%a,55%a",options="header"]
|===
|PostgreSQL data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`BOOLEAN`
|`BOOLEAN`
|n/a

|`BIT(1)`
|`BOOLEAN`
|n/a

|`BIT( > 1)`
|`BYTES`
|`io.debezium.data.Bits` +
 +
The `length` schema parameter contains an integer that represents the number of bits. The resulting `byte[]` contains the bits in little-endian form and is sized to contain the specified number of bits. For example, `numBytes = n/8 + (n % 8 == 0 ? 0 : 1)` where `n` is the number of bits.

|`BIT VARYING[(M)]`
|`BYTES`
|`io.debezium.data.Bits` +
 +
The `length` schema parameter contains an integer that represents the number of bits (2^31 - 1 in case no length is given for the column). The resulting `byte[]` contains the bits in little-endian form and is sized based on the content. The specified size `(M)` is stored in the length parameter of the `io.debezium.data.Bits` type.

|`SMALLINT`, `SMALLSERIAL`
|`INT16`
|n/a

|`INTEGER`, `SERIAL`
|`INT32`
|n/a

|`BIGINT`, `BIGSERIAL`, `OID`
|`INT64`
|n/a

|`REAL`
|`FLOAT32`
|n/a

|`DOUBLE PRECISION`
|`FLOAT64`
|n/a

|`CHAR[(M)]`
|`STRING`
|n/a

|`VARCHAR[(M)]`
|`STRING`
|n/a

|`CHARACTER[(M)]`
|`STRING`
|n/a

|`CHARACTER VARYING[(M)]`
|`STRING`
|n/a

|`TIMESTAMPTZ`, `TIMESTAMP WITH TIME ZONE`
|`STRING`
|`io.debezium.time.ZonedTimestamp` +
 +
A string representation of a timestamp with timezone information, where the timezone is GMT.

|`TIMETZ`, `TIME WITH TIME ZONE`
|`STRING`
|`io.debezium.time.ZonedTime` +
 +
A string representation of a time value with timezone information, where the timezone is GMT.

|`INTERVAL [P]`
|`INT64`
|`io.debezium.time.MicroDuration` +
(default) +
 +
The approximate number of microseconds for a time interval using the `365.25 / 12.0` formula for days per month average.

|`INTERVAL [P]`
|`STRING`
|`io.debezium.time.Interval` +
(when `interval.handling.mode` is set to `string`) +
 +
The string representation of the interval value that follows the pattern `P<years>Y<months>M<days>DT<hours>H<minutes>M<seconds>S`, for example,  `P1Y2M3DT4H5M6.78S`.

|`BYTEA`
|`BYTES` or `STRING`
|n/a +
 +
Either the raw bytes (the default), a base64-encoded string, or a base64-url-safe-encoded String, or a hex-encoded string, based on the connector's xref:postgresql-property-binary-handling-mode[binary handling mode] setting. +
 +
Debezium only supports Postgres `bytea_output` configuration of value `hex`.
For more information about PostgreSQL binary data types, see the link:https://www.postgresql.org/docs/current/datatype-binary.html[PostgreSQL documentation].

|`JSON`, `JSONB`
|`STRING`
|`io.debezium.data.Json` +
 +
Contains the string representation of a JSON document, array, or scalar.

|`XML`
|`STRING`
|`io.debezium.data.Xml` +
 +
Contains the string representation of an XML document.

|`UUID`
|`STRING`
|`io.debezium.data.Uuid` +
 +
Contains the string representation of a PostgreSQL UUID value.

|`POINT`
|`STRUCT`
|`io.debezium.data.geometry.Point` +
 +
Contains a structure with two `FLOAT64` fields, `(x,y)`. Each field represents the coordinates of a geometric point.

|`LTREE`
|`STRING`
|`io.debezium.data.Ltree` +
 +
Contains the string representation of a PostgreSQL LTREE value.

|`CITEXT`
|`STRING`
|n/a

|`INET`
|`STRING`
|n/a

|`INT4RANGE`
|`STRING`
|n/a +
 +
Range of integer.

|`INT8RANGE`
|`STRING`
|n/a +
 +
Range of `bigint`.

|`NUMRANGE`
|`STRING`
|n/a +
 +
Range of `numeric`.

|`TSRANGE`
|`STRING`
|n/a +
 +
Contains the string representation of a timestamp range without a time zone.

|`TSTZRANGE`
|`STRING`
|n/a +
 +
Contains the string representation of a timestamp range with the local system time zone.

|`DATERANGE`
|`STRING`
|n/a +
 +
Contains the string representation of a date range. It always has an exclusive upper-bound.

|`ENUM`
|`STRING`
|`io.debezium.data.Enum` +
 +
Contains the string representation of the PostgreSQL `ENUM` value. The set of allowed values is maintained in the `allowed` schema parameter.

|===

[id="postgresql-temporal-types"]
=== Temporal types

Other than PostgreSQL's `TIMESTAMPTZ` and `TIMETZ` data types, which contain time zone information, how temporal types are mapped depends on the value of the xref:postgresql-property-time-precision-mode[`time.precision.mode`] connector configuration property. The following sections describe these mappings:

* xref:postgresql-time-precision-mode-adaptive[`time.precision.mode=adaptive`]
* xref:postgresql-time-precision-mode-adaptive-time-microseconds[`time.precision.mode=adaptive_time_microseconds`]
* xref:postgresql-time-precision-mode-connect[`time.precision.mode=connect`]

[[postgresql-time-precision-mode-adaptive]]
.`time.precision.mode=adaptive`
When the `time.precision.mode` property is set to `adaptive`, the default, the connector determines the literal type and semantic type based on the column's data type definition. This ensures that events _exactly_ represent the values in the database.

.Mappings when `time.precision.mode` is `adaptive`
[cols="25%a,20%a,55%a",options="header"]
|===
|PostgreSQL data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`DATE`
|`INT32`
|`io.debezium.time.Date` +
 +
Represents the number of days since the epoch.

|`TIME(1)`, `TIME(2)`, `TIME(3)`
|`INT32`
|`io.debezium.time.Time` +
 +
Represents the number of milliseconds past midnight, and does not include timezone information.

|`TIME(4)`, `TIME(5)`, `TIME(6)`
|`INT64`
|`io.debezium.time.MicroTime` +
 +
Represents the number of microseconds past midnight, and does not include timezone information.

|`TIMESTAMP(1)`, `TIMESTAMP(2)`, `TIMESTAMP(3)`
|`INT64`
|`io.debezium.time.Timestamp` +
 +
Represents the number of milliseconds since the epoch, and does not include timezone information.

|`TIMESTAMP(4)`, `TIMESTAMP(5)`, `TIMESTAMP(6)`, `TIMESTAMP`
|`INT64`
|`io.debezium.time.MicroTimestamp` +
 +
Represents the number of microseconds since the epoch, and does not include timezone information.

|===

[[postgresql-time-precision-mode-adaptive-time-microseconds]]
.`time.precision.mode=adaptive_time_microseconds`
When the `time.precision.mode` configuration property is set to `adaptive_time_microseconds`, the connector determines the literal type and semantic type for temporal types based on the column's data type definition. This ensures that events _exactly_ represent the values in the database, except all `TIME` fields are captured as microseconds.

.Mappings when `time.precision.mode` is `adaptive_time_microseconds`
[cols="25%a,20%a,55%a",options="header"]
|===
|PostgreSQL data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`DATE`
|`INT32`
|`io.debezium.time.Date` +
 +
Represents the number of days since the epoch.

|`TIME([P])`
|`INT64`
|`io.debezium.time.MicroTime` +
 +
Represents the time value in microseconds and does not include timezone information. PostgreSQL allows precision `P` to be in the range 0-6 to store up to microsecond precision.

|`TIMESTAMP(1)` , `TIMESTAMP(2)`, `TIMESTAMP(3)`
|`INT64`
|`io.debezium.time.Timestamp` +
 +
Represents the number of milliseconds past the epoch, and does not include timezone information.

|`TIMESTAMP(4)` , `TIMESTAMP(5)`, `TIMESTAMP(6)`, `TIMESTAMP`
|`INT64`
|`io.debezium.time.MicroTimestamp` +
 +
Represents the number of microseconds past the epoch, and does not include timezone information.

|===

[[postgresql-time-precision-mode-connect]]
.`time.precision.mode=connect`
When the `time.precision.mode` configuration property is set to `connect`, the connector uses Kafka Connect logical types. This may be useful when consumers can handle only the built-in Kafka Connect logical types and are unable to handle variable-precision time values. However, since PostgreSQL supports microsecond precision, the events generated by a connector with the `connect` time precision mode *results in a loss of precision* when the database column has a _fractional second precision_ value that is greater than 3.

.Mappings when `time.precision.mode` is `connect`
[cols="25%a,20%a,55%a",options="header"]
|===
|PostgreSQL data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`DATE`
|`INT32`
|`org.apache.kafka.connect.data.Date` +
 +
Represents the number of days since the epoch.

|`TIME([P])`
|`INT64`
|`org.apache.kafka.connect.data.Time` +
 +
Represents the number of milliseconds since midnight, and does not include timezone information. PostgreSQL allows `P` to be in the range 0-6 to store up to microsecond precision, though this mode results in a loss of precision when `P` is greater than 3.

|`TIMESTAMP([P])`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp` +
 +
Represents the number of milliseconds since the epoch, and does not include timezone information. PostgreSQL allows `P` to be in the range 0-6 to store up to microsecond precision, though this mode results in a loss of precision when `P` is greater than 3.

|===

[id="postgresql-timestamp-type"]
=== TIMESTAMP type

The `TIMESTAMP` type represents a timestamp without time zone information.
Such columns are converted into an equivalent Kafka Connect value based on UTC. For example, the `TIMESTAMP` value "2018-06-20 15:13:16.945104" is represented by an `io.debezium.time.MicroTimestamp` with the value "1529507596945104" when `time.precision.mode` is not set to `connect`.

The timezone of the JVM running Kafka Connect and {prodname} does not affect this conversion.

PostgreSQL supports using `+/-infinite` values in `TIMESTAMP` columns.
These special values are converted to timestamps with value `9223372036825200000` in case of positive infinity or `-9223372036832400000` in case of negative infinity.
This behavior mimics the standard behavior of the PostgreSQL JDBC driver.
For reference, see the https://jdbc.postgresql.org/documentation/publicapi/org/postgresql/PGStatement.html[`org.postgresql.PGStatement`] interface.

[id="postgresql-decimal-types"]
=== Decimal types

The setting of the PostgreSQL connector configuration property xref:postgresql-property-decimal-handling-mode[`decimal.handling.mode`] determines how the connector maps decimal types.

When the `decimal.handling.mode` property is set to `precise`, the connector uses the Kafka Connect `org.apache.kafka.connect.data.Decimal` logical type for all `DECIMAL`, `NUMERIC` and `MONEY` columns. This is the default mode.

.Mappings when `decimal.handling.mode` is `precise`
[cols="28%a,17%a,55%a",options="header"]
|===
|PostgreSQL data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`NUMERIC[(M[,D])]`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal` +
 +
The `scale` schema parameter contains an integer representing how many digits the decimal point was shifted.

|`DECIMAL[(M[,D])]`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal` +
 +
The `scale` schema parameter contains an integer representing how many digits the decimal point was shifted.

|`MONEY[(M[,D])]`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal` +
 +
The `scale` schema parameter contains an integer representing how many digits the decimal point was shifted.
The `scale` schema parameter is determined by the xref:postgresql-property-money-fraction-digits[`money.fraction.digits`] connector configuration property.

|===

There is an exception to this rule.
When the `NUMERIC` or `DECIMAL` types are used without scale constraints, the values coming from the database have a different (variable) scale for each value. In this case, the connector uses `io.debezium.data.VariableScaleDecimal`, which contains both the value and the scale of the transferred value.

.Mappings of `DECIMAL` and `NUMERIC` types when there are no scale constraints
[cols="25%a,20%a,55%a",options="header"]
|===
|PostgreSQL data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`NUMERIC`
|`STRUCT`
|`io.debezium.data.VariableScaleDecimal` +
 +
Contains a structure with two fields: `scale` of type `INT32` that contains the scale of the transferred value and `value` of type `BYTES` containing the original value in an unscaled form.

|`DECIMAL`
|`STRUCT`
|`io.debezium.data.VariableScaleDecimal` +
 +
Contains a structure with two fields: `scale` of type `INT32` that contains the scale of the transferred value and `value` of type `BYTES` containing the original value in an unscaled form.

|===

When the `decimal.handling.mode` property is set to `double`, the connector represents all `DECIMAL`, `NUMERIC` and `MONEY` values as Java double values and encodes them as shown in the following table.

.Mappings when `decimal.handling.mode` is `double`
[cols="30%a,30%a,40%a",options="header"]
|===
|PostgreSQL data type
|Literal type (schema type)
|Semantic type (schema name)

|`NUMERIC[(M[,D])]`
|`FLOAT64`
|

|`DECIMAL[(M[,D])]`
|`FLOAT64`
|

|`MONEY[(M[,D])]`
|`FLOAT64`
|

|===

The last possible setting for the `decimal.handling.mode` configuration property is `string`. In this case, the connector represents `DECIMAL`, `NUMERIC` and `MONEY` values as their formatted string representation, and encodes them as shown in the following table.

.Mappings when `decimal.handling.mode` is `string`
[cols="30%a,30%a,40%a",options="header"]
|===
|PostgreSQL data type
|Literal type (schema type)
|Semantic type (schema name)

|`NUMERIC[(M[,D])]`
|`STRING`
|

|`DECIMAL[(M[,D])]`
|`STRING`
|

|`MONEY[(M[,D])]`
|`STRING`
|

|===

PostgreSQL supports `NaN` (not a number) as a special value to be stored in `DECIMAL`/`NUMERIC` values when the setting of `decimal.handling.mode` is `string` or `double`. In this case, the connector encodes `NaN` as either `Double.NaN` or the string constant `NAN`.

[id="postgresql-hstore-type"]
=== HSTORE type

The setting of the PostgreSQL connector configuration property xref:postgresql-property-hstore-handling-mode[`hstore.handling.mode`] determines how the connector maps `HSTORE` values.

When the `hstore.handling.mode` property is set to `json` (the default), the connector represents `HSTORE` values as string representations of JSON values and encodes them as shown in the following table.
When the `hstore.handling.mode` property is set to `map`, the connector uses the `MAP` schema type for `HSTORE` values.

.Mappings for `HSTORE` data type
[cols="25%a,20%a,55%a",options="header"]
|===
|PostgreSQL data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`HSTORE`
|`STRING`
|`io.debezium.data.Json` +
 +
Example: output representation using the JSON converter is ``{"key" : "val"}``

|`HSTORE`
|`MAP`
|n/a +
 +
Example: output representation  using the JSON converter is `{"key" : "val"}`

|===

[id="postgresql-domain-types"]
=== Domain types

PostgreSQL supports user-defined types that are based on other underlying types. When such column types are used, {prodname} exposes the column's representation based on the full type hierarchy.

[IMPORTANT]
====
Capturing changes in columns that use PostgreSQL domain types requires special consideration. When a column is defined to contain a domain type that extends one of the default database types and the domain type defines a custom length or scale, the generated schema inherits that defined length or scale.

When a column is defined to contain a domain type that extends another domain type that defines a custom length or scale, the generated schema does *not* inherit the defined length or scale because that information is not available in the PostgreSQL driver's column metadata.
====

[id="postgresql-network-address-types"]
=== Network address types

PostgreSQL has data types that can store IPv4, IPv6, and MAC addresses. It is better to use these types instead of plain text types to store network addresses. Network address types offer input error checking and specialized operators and functions.

.Mappings for network address types
[cols="25%a,20%a,55%a",options="header"]
|===
|PostgreSQL data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`INET`
|`STRING`
|n/a +
 +
IPv4 and IPv6 networks

|`CIDR`
|`STRING`
|n/a +
 +
IPv4 and IPv6 hosts and networks

|`MACADDR`
|`STRING`
|n/a +
 +
MAC addresses

|`MACADDR8`
|`STRING`
|n/a +
 +
MAC addresses in EUI-64 format

|===

[id="postgresql-postgis-types"]
=== PostGIS types

The PostgreSQL connector supports all link:http://postgis.net[PostGIS data types].

.Mappings of PostGIS data types
[cols="25%a,20%a,55%a",options="header"]
|===
|PostGIS data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`GEOMETRY` +
(planar)
|`STRUCT`
a|`io.debezium.data.geometry.Geometry` +
 +
Contains a structure with two fields: +

* `srid (INT32)` - Spatial Reference System Identifier that defines what type of geometry object is stored in the structure.
* `wkb (BYTES)` - A binary representation of the geometry object encoded in the Well-Known-Binary format. +

For format details, see link:http://www.opengeospatial.org/standards/sfa[Open Geospatial Consortium Simple Features Access specification].

|`GEOGRAPHY` +
(spherical)
|`STRUCT`
|`io.debezium.data.geometry.Geography` +
 +
Contains a structure with two fields: +

* `srid (INT32)` - Spatial Reference System Identifier that defines what type of geography object is stored in the structure.
* `wkb (BYTES)` - A binary representation of the geometry object encoded in the Well-Known-Binary format. +

For format details, see http://www.opengeospatial.org/standards/sfa[Open Geospatial Consortium Simple Features Access specification].

|===

[id="postgresql-toasted-values"]
=== Toasted values
PostgreSQL has a hard limit on the page size.
This means that values that are larger than around 8 KBs need to be stored by using link:https://www.postgresql.org/docs/current/storage-toast.html[TOAST storage].
This impacts replication messages that are coming from the database. Values that were stored by using the TOAST mechanism and that have not been changed are not included in the message, unless they are part of the table's replica identity.
There is no safe way for {prodname} to read the missing value out-of-bands directly from the database, as this would potentially lead to race conditions. Consequently, {prodname} follows these rules to handle toasted values:

* Tables with `REPLICA IDENTITY FULL` - TOAST column values are part of the `before` and `after` fields in change events just like any other column.
* Tables with `REPLICA IDENTITY DEFAULT` - When receiving an `UPDATE` event from the database, any unchanged TOAST column value that is not part of the replica identity is not contained in the event.
Similarly, when receiving a `DELETE` event, no TOAST columns, if any, are  in the `before` field.
As {prodname} cannot safely provide the column value in this case, the connector returns a placeholder value as defined by the connector configuration property, `unavailable.value.placeholder`.

[id="postgresql-default-values"]
=== Default values
If a default value is specified for a column in the database schema, the PostgreSQL connector will attempt to propagate this value to the Kafka schema whenever possible. Most common data types are supported, including:

* `BOOLEAN`
* Numeric types (`INT`, `FLOAT`, `NUMERIC`, etc.)
* Text types (`CHAR`, `VARCHAR`, `TEXT`, etc.)
* Temporal types (`DATE`, `TIME`, `INTERVAL`, `TIMESTAMP`, `TIMESTAMPTZ`)
* `JSON`, `JSONB`, `XML`
* `UUID`

Note that for temporal types, parsing of the default value is provided by PostgreSQL libraries; therefore, any string representation which is normally supported by PostgreSQL should also be supported by the connector.

In the case that the default value is generated by a function rather than being directly specified in-line, the connector will instead export the equivalent of `0` for the given data type. These values include:

* `FALSE` for `BOOLEAN`
* `0` with appropriate precision, for numeric types
* Empty string for text/XML types
* `{}` for JSON types
* `1970-01-01` for `DATE`, `TIMESTAMP`, `TIMESTAMPTZ` types
* `00:00` for `TIME`
* `EPOCH` for `INTERVAL`
* `00000000-0000-0000-0000-000000000000` for `UUID`

This support currently extends only to explicit usage of functions. For example, `CURRENT_TIMESTAMP(6)` is supported with parentheses, but `CURRENT_TIMESTAMP` is not.

[IMPORTANT]
====
Support for the propagation of default values exists primarily to allow for safe schema evolution when using the PostgreSQL connector with a schema registry which enforces compatibility between schema versions. Due to this primary concern, as well as the refresh behaviours of the different plug-ins, the default value present in the Kafka schema is not guaranteed to always be in-sync with the default value in the database schema.

* Default values may appear 'late' in the Kafka schema, depending on when/how a given plugin triggers refresh of the in-memory schema. Values may never appear/be skipped in the Kafka schema if the default changes multiple times in-between refreshes
* Default values may appear 'early' in the Kafka schema, if a schema refresh is triggered while the connector has records waiting to be processed. This is due to the column metadata being read from the database at refresh time, rather than being present in the replication message. This may occur if the connector is behind and a refresh occurs, or on connector start if the connector was stopped for a time while updates continued to be written to the source database.

This behaviour may be unexpected, but it is still safe. Only the schema definition is affected, while the real values present in the message will remain consistent with what was written to the source database.
====

[[custom-postgres-connector-converters]]
== Custom converters

By default, {prodname} does not replicate data from columns with custom data types, such as composite types that are created by using SQL `CREATE TYPE` statements.
To replicate columns with custom data types, follow the instructions for {link-prefix}:{link-custom-converters}#custom-converters[creating a custom converter], with a few important caveats:

* Set the xref:postgresql-property-include-unknown-datatypes[`include.unknown.datatypes`] property in the connector configuration to `true`.
The default `false` setting causes the custom converter to always return `null` values.
* The type of value that is passed to the converter depends on the logical decoding output plug-in that is configured for the replication slot.
** `decoderbufs` passes a byte array (`byte[]`) representation of the column data.
** `pgoutput` passes a string representation of the column data.

// Type: assembly
// ModuleID: setting-up-postgresql-to-run-a-debezium-connector
// Title: Setting up PostgreSQL to run a {prodname} connector
[[setting-up-postgresql]]
== Setting up Postgres

Before using the PostgreSQL connector to monitor the changes committed on a PostgreSQL server, decide which logical decoding plug-in you intend to use.
If you plan *not* to use the native `pgoutput` logical replication stream support, then you must install the logical decoding plug-in into the PostgreSQL server. Afterward, enable a replication slot, and configure a user with sufficient privileges to perform the replication.

If your database is hosted by a service such as link:https://www.heroku.com/postgres[Heroku Postgres] you might be unable to install the plug-in. If so, and if you are using PostgreSQL 10+, you can use the `pgoutput` decoder support to capture changes in your database. If that is not an option, you are unable to use {prodname} with your database.



[[postgresql-in-the-cloud]]
=== PostgreSQL in the Cloud

[[postgresql-on-amazon-rds]]
==== PostgreSQL on Amazon RDS

It is possible to capture changes in a PostgreSQL database that is running in link:https://aws.amazon.com/rds/[Amazon RDS]. To do this:

* Set the instance parameter `rds.logical_replication` to `1`.
* Verify that the `wal_level` parameter is set to `logical` by running the query `SHOW wal_level` as the database RDS master user.
  This might not be the case in multi-zone replication setups.
  You cannot set this option manually.
  It is link:https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithParamGroups.html[automatically changed] when the `rds.logical_replication` parameter is set to `1`.
  If the `wal_level` is not set to `logical` after you make the preceding change, it is probably because the instance has to be restarted after the parameter group change.
  Restarts occur during your maintenance window, or you can initiate a restart manually.
* Set the {prodname} `plugin.name` parameter to `pgoutput`.
* Initiate logical replication from an AWS account that has the `rds_replication` role.
  The role grants permissions to manage logical slots and to stream data using logical slots.
  By default, only the master user account on AWS has the `rds_replication` role on Amazon RDS.
  To enable a user account other than the master account to initiate logical replication, you must grant the account the `rds_replication` role.
  For example, `grant rds_replication to _<my_user>_`. You must have `superuser` access to grant the `rds_replication` role to a user.
  To enable accounts other than the master account to create an initial snapshot, you must grant `SELECT` permission to the accounts on the tables to be captured.
  For more information about security for PostgreSQL logical replication, see the link:https://www.postgresql.org/docs/current/logical-replication-security.html[PostgreSQL documentation].

[[postgresql-on-azure]]
==== PostgreSQL on Azure

It is possible to use {prodname} with link:https://docs.microsoft.com/azure/postgresql/[Azure Database for PostgreSQL], which has support for the `pgoutput` logical decoding plug-in, which is supported by {prodname}.

Set the Azure replication support to `logical`. You can use the link:https://docs.microsoft.com/en-us/azure/postgresql/concepts-logical#using-azure-cli[Azure CLI] or the link:https://docs.microsoft.com/en-us/azure/postgresql/concepts-logical#using-azure-portal[Azure Portal] to configure this. For example, to use the Azure CLI, here are the link:https://docs.microsoft.com/cli/azure/postgres/server?view=azure-cli-latest[`az postgres server`] commands that you need to execute:

```
az postgres server configuration set --resource-group mygroup --server-name myserver --name azure.replication_support --value logical

az postgres server restart --resource-group mygroup --name myserver
```

[[postgresql-on-crunchybridge]]
==== PostgreSQL on CrunchyBridge

It is possible to use {prodname} with link:https://crunchybridge.com/[CrunchyBridge]; logical replication is already turned on. The `pgoutput` plugin is available. You will have to create a replication user and provide correct privileges.

[IMPORTANT]
====
While using the `pgoutput` plug-in, it is recommended that you configure `filtered` as the xref:postgresql-publication-autocreate-mode[`publication.autocreate.mode`]. If you use `all_tables`, which is the default value for `publication.autocreate.mode`, and the publication is not found, the connector tries to create one by using `CREATE PUBLICATION <publication_name> FOR ALL TABLES;`, but this fails due to lack of permissions.
====

[[installing-postgresql-output-plugin]]
=== Installing the logical decoding output plug-in

[TIP]
====
For more detailed instructions about setting up and testing logical decoding plug-ins, see xref:{link-postgresql-plugins}[Logical Decoding Output Plug-in Installation for PostgreSQL] .
====

As of PostgreSQL 9.4, the only way to read changes to the write-ahead-log is to install a logical decoding output plug-in. Plug-ins are written in C, compiled, and installed on the machine that runs the PostgreSQL server. Plug-ins use  a number of PostgreSQL specific APIs, as described by the link:https://www.postgresql.org/docs/current/static/logicaldecoding-output-plugin.html[PostgreSQL documentation].

The PostgreSQL connector works with one of {prodname}'s supported logical decoding plug-ins to receive change events from the database in either the link:https://github.com/google/protobuf[Protobuf format] or the link:https://github.com/postgres/postgres/blob/master/src/backend/replication/pgoutput/pgoutput.c[pgoutput] format.
The `pgoutput` plugin comes out-of-the-box with the PostgreSQL database.
For more details on using Protobuf via the `decoderbufs` plug-in, see the plug-in link:https://github.com/debezium/postgres-decoderbufs/blob/main/README.md[`documentation`] which discusses its requirements, limitations, and how to compile it.

For simplicity, {prodname} also provides a container image based on the upstream PostgreSQL server image, on top of which it compiles and installs the plug-ins. You can link:https://github.com/debezium/container-images/tree/main/postgres/13[use this image] as an example of the detailed steps required for the installation.

[WARNING]
====
The {prodname} logical decoding plug-ins have been installed and tested on only Linux machines. For Windows and other operating systems, different installation steps might be required.
====

[[postgresql-differences-between-plugins]]
=== Plug-in differences

Plug-in behavior is not completely the same for all cases.
These differences have been identified:

* While all plug-ins will refresh schema metadata from the database upon detection of a schema change during streaming, the `pgoutput` plug-in is somewhat more 'eager' about triggering such refreshes. For example, a change to the default value for a column will trigger a refresh with `pgoutput`, while other plug-ins will not be aware of this change until another change triggers a refresh (eg. addition of a new column.) This is due to the behaviour of `pgoutput`, rather than {prodname} itself.

All up-to-date differences are tracked in a test suite link:https://github.com/debezium/debezium/blob/main/debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/DecoderDifferences.java[Java class].

[[postgresql-server-configuration]]
=== Configuring the PostgreSQL server

If you are using a xref:postgresql-output-plugin[logical decoding plug-in] other than pgoutput, after installing it, configure the PostgreSQL server as follows:

. To load the plug-in at startup, add the following to the `postgresql.conf` file::
+
[source,properties]
----
# MODULES
shared_preload_libraries = 'decoderbufs' // <1>
----
<1> Instructs the server to load the `decoderbufs` logical decoding plug-ins at startup (the name of the plug-in is set in the link:https://github.com/debezium/postgres-decoderbufs/blob/v{debezium-version}/Makefile[`Protobuf`] make file).

. To configure the replication slot regardless of the decoder being used, specify the following in the `postgresql.conf` file:
+
[source,properties]
----
# REPLICATION
wal_level = logical             // <1>
----
<1> Instructs the server to use logical decoding with the write-ahead log.

Depending on your requirements, you may have to set other PostgreSQL streaming replication parameters when using {prodname}.
Examples include `max_wal_senders` and `max_replication_slots` for increasing the number of connectors that can access the sending server concurrently, and `wal_keep_size` for limiting the maximum WAL size which a replication slot will retain.
For more information about configuring streaming replication, see the link:https://www.postgresql.org/docs/current/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-SENDER[PostgreSQL documentation].

{prodname} uses PostgreSQL's logical decoding, which uses replication slots.
Replication slots are guaranteed to retain all WAL segments required for {prodname} even during {prodname} outages. For this reason, it is important to closely monitor replication slots to avoid too much disk consumption and other conditions that can happen such as catalog bloat if a replication slot stays unused for too long.
For more information, see the link:https://www.postgresql.org/docs/current/warm-standby.html#STREAMING-REPLICATION-SLOTS[PostgreSQL streaming replication documentation].

If you are working with a `synchronous_commit` setting other than `on`,
the recommendation is to set `wal_writer_delay` to a value such as 10 milliseconds to achieve a low latency of change events.
Otherwise, its default value is applied, which adds a latency of about 200 milliseconds.

[TIP]
====
Reading and understanding link:https://www.postgresql.org/docs/current/static/wal-configuration.html[PostgreSQL documentation about the mechanics and configuration of the PostgreSQL write-ahead log] is strongly recommended.
====

// Type: procedure
// ModuleID: setting-up-postgresql-permissions-required-by-debezium-connectors
// Title: Setting up PostgreSQL permissions for the {prodname} connector
[[postgresql-permissions]]
=== Setting up permissions

Setting up a PostgreSQL server to run a {prodname} connector requires a database user that can perform replications.
Replication can be performed only by a database user that has appropriate permissions and only for a configured number of hosts.

Although, by default, superusers have the necessary `REPLICATION` and `LOGIN` roles, as mentioned in xref:postgresql-security[Security], it is best not to provide the {prodname} replication user with elevated privileges.
Instead, create a {prodname} user that has the minimum required privileges.

.Prerequisites

* PostgreSQL administrative permissions.

.Procedure

. To provide a user with replication permissions, define a PostgreSQL role that has _at least_ the `REPLICATION` and `LOGIN` permissions, and then grant that role to the user.
  For example:
+
[source,sql,subs="+quotes"]
----
CREATE ROLE __<name>__ REPLICATION LOGIN;
----

// Type: procedure
// ModuleID: setting-privileges-to-permit-debezium-user-to-create-postgresql-publications
// Title: Setting privileges to enable {prodname} to create PostgreSQL publications
[[postgresql-replication-user-privileges]]
=== Setting privileges to enable {prodname} to create PostgreSQL publications when you use `pgoutput`

If you use `pgoutput` as the logical decoding plugin, {prodname} must operate in the database as a user with specific privileges.

{prodname} streams change events for PostgreSQL source tables from _publications_ that are created for the tables.
Publications contain a filtered set of change events that are generated from one or more tables.
The data in each publication is filtered based on the publication specification.
The specification can be created by the PostgreSQL database administrator or by the {prodname} connector.
To permit the {prodname} PostgreSQL connector to create publications and specify the data to replicate to them, the connector must operate with specific privileges in the database.

There are several options for determining how publications are created.
In general, it is best to manually create publications for the tables that you want to capture, before you set up the connector.
However, you can configure your environment in a way that permits {prodname} to create publications automatically, and to specify the data that is added to them.

{prodname} uses include list and exclude list properties to specify how data is inserted in the publication.
For more information about the options for enabling {prodname} to create publications, see xref:postgresql-publication-autocreate-mode[`publication.autocreate.mode`].

For {prodname} to create a PostgreSQL publication, it must run as a user that has the following privileges:

* Replication privileges in the database to add the table to a publication.
* `CREATE` privileges on the database to add publications.
* `SELECT` privileges on the tables to copy the initial table data. Table owners automatically have `SELECT` permission for the table.

To add tables to a publication, the user must be an owner of the table.
But because the source table already exists, you need a mechanism to share ownership with the original owner.
To enable shared ownership, you create a PostgreSQL replication group, and then add the existing table owner and the replication user to the group.

.Procedure

. Create a replication group.
+
[source,sql,subs="+quotes"]
----
CREATE ROLE _<replication_group>_;
----
. Add the original owner of the table to the group.
+
[source,sql,subs="+quotes"]
----
GRANT REPLICATION_GROUP TO __<original_owner>__;
----
. Add the {prodname} replication user to the group.
+
[source,sql,subs="+quotes"]
----
GRANT REPLICATION_GROUP TO __<replication_user>__;
----
. Transfer ownership of the table to `<replication_group>`.
+
[source,sql,subs="+quotes"]
----
ALTER TABLE __<table_name>__ OWNER TO REPLICATION_GROUP;
----

For {prodname} to specify the capture configuration, the value of xref:postgresql-publication-autocreate-mode[`publication.autocreate.mode`] must be set to `filtered`.

// Type: procedure
// ModuleID: configuring-postgresql-to-allow-replication-with-the-connector-host
[[postgresql-host-replication-permissions]]
=== Configuring PostgreSQL to allow replication with the {prodname} connector host

To enable {prodname} to replicate PostgreSQL data, you must configure the database to permit replication with the host that runs the PostgreSQL connector.
To specify the clients that are permitted to replicate with the database, add entries to the PostgreSQL host-based authentication file, `pg_hba.conf`.
For more information about the `pg_hba.conf` file, see link:https://www.postgresql.org/docs/10/auth-pg-hba-conf.html[the PostgreSQL] documentation.

.Procedure

* Add entries to the `pg_hba.conf` file to specify the {prodname} connector hosts that can replicate with the database host.
For example,
+
.`pg_hba.conf` file example:
[source]
----
local   replication     <youruser>                          trust   // <1>
host    replication     <youruser>  127.0.0.1/32            trust   // <2>
host    replication     <youruser>  ::1/128                 trust   // <3>
----
+
.Descriptions of `pg_hba.conf` settings
[cols="1,7",options="header",subs="+attributes"]
|===
|Item |Description

|1
|Instructs the server to allow replication for `<youruser>` locally, that is, on the server machine.

|2
|Instructs the server to allow `<youruser>` on `localhost` to receive replication changes using `IPV4`.

|3
|Instructs the server to allow `<youruser>` on `localhost` to receive replication changes using `IPV6`.

|===

[NOTE]
====
For more information about network masks, see link:https://www.postgresql.org/docs/current/static/datatype-net-types.html[the PostgreSQL documentation].
====

[[supported-postgresql-topologies]]
=== Supported PostgreSQL topologies

The PostgreSQL connector can be used with a standalone PostgreSQL server or with a cluster of PostgreSQL servers.

As mentioned xref:postgresql-limitations[in the beginning], PostgreSQL (for all versions <= 12) supports logical replication slots on only `primary` servers. This means that a replica in a PostgreSQL cluster cannot be configured for logical replication, and consequently that the {prodname} PostgreSQL connector can connect and communicate with only the primary server. Should this server fail, the connector stops. When the cluster is repaired, if the original primary server is once again promoted to `primary`, you can restart the connector. However, if a different PostgreSQL server _with the plug-in and proper configuration_ is promoted to `primary`, you must change the connector configuration to point to the new `primary` server and then you can restart the connector.

// Type: concept
// ModuleID: configuring-postgresql-to-manage-debezium-wal-disk-space-consumption
// Title: Configuring PostgreSQL to manage {prodname} WAL disk space consumption
[[postgresql-wal-disk-space]]
=== WAL disk space consumption
In certain cases, it is possible for PostgreSQL disk space consumed by WAL files to spike or increase out of usual proportions.
There are several possible reasons for this situation:

* The LSN up to which the connector has received data is available in the `confirmed_flush_lsn` column of the server's `pg_replication_slots` view. Data that is older than this LSN is no longer available, and the database is responsible for reclaiming the disk space.
+
Also in the `pg_replication_slots` view, the `restart_lsn` column contains the LSN of the oldest WAL that the connector might require. If the value for `confirmed_flush_lsn` is regularly increasing and the value of  `restart_lsn` lags then the database needs to reclaim the space.
+
The database typically reclaims disk space in batch blocks. This is expected behavior and no action by a user is necessary.

* There are many updates in a database that is being tracked but only a tiny number of updates are related to the table(s) and schema(s) for which the connector is capturing changes. This situation can be easily solved with periodic heartbeat events. Set the xref:postgresql-property-heartbeat-interval-ms[`heartbeat.interval.ms`] connector configuration property.
+
[NOTE]
====
For the connector to detect and process events from a heartbeat table, you must add the table to the PostgreSQL publication specified by the xref:postgresql-property-publication-name[publication.name] property.
If this publication predates your {prodname} deployment, the connector uses the publications as defined.
If the publication is not already configured to automatically replicate changes `FOR ALL TABLES` in the database, you must explicitly add the heartbeat table to the publication, for example, +

`ALTER PUBLICATION  _<publicationName>_ ADD TABLE _<heartbeatTableName>_;`
====

* The PostgreSQL instance contains multiple databases and one of them is a high-traffic database. {prodname} captures changes in another database that is low-traffic in comparison to the other database. {prodname} then cannot confirm the LSN as replication slots work per-database and {prodname} is not invoked. As WAL is shared by all databases, the amount used tends to grow until an event is emitted by the database for which {prodname} is capturing changes. To overcome this, it is necessary to:

** Enable periodic heartbeat record generation with the `heartbeat.interval.ms` connector configuration property.
** Regularly emit change events from the database for which {prodname} is capturing changes.

+
A separate process would then periodically update the table by either inserting a new row or repeatedly updating the same row.
PostgreSQL then invokes {prodname}, which confirms the latest LSN and allows the database to reclaim the WAL space.
This task can be automated by means of the xref:postgresql-property-heartbeat-action-query[`heartbeat.action.query`] connector configuration property.

[TIP]
====
For users on AWS RDS with PostgreSQL, a situation similar to the high traffic/low traffic scenario can occur in an idle environment. AWS RDS causes writes to its own system tables to be invisible to clients on a frequent basis (5 minutes).
Again, regularly emitting events solves the problem.
====


[[postgresql-deploying-multiple-connectors]]
=== Setting up multiple connectors for same database server

{prodname} uses replication slots to stream changes from a database. These replication slots maintain the current position in form of a LSN (Log Sequence Number) which is pointer to a location in the WAL being consumed by the Debezium connector. This helps PostgreSQL keep the WAL available until it is processed by {prodname}. A single replication slot can exist only for a single consumer or process - as different consumer might have different state and may need data from different position.

Since a replication slot can only be used by a single connector, it is essential to create a unique replication slot for each Debezium connector. Although when a connector is not active, Postgres may allow other connector to consume the replication slot - which could be dangerous as it may lead to data loss as a slot will emit each change just once [link:https://www.postgresql.org/docs/10/logicaldecoding-explanation.html#LOGICALDECODING-REPLICATION-SLOTS[See More]].

In addition to replication slot, {prodname} uses publication to stream events when using the `pgoutput` plugin. Similar to replication slot, publication is at database level and is defined for a set of tables. Thus, you'll need a unique publication for each connector, unless the connectors work on same set of tables. For more information about the options for enabling {prodname} to create publications, see xref:{link-postgresql-connector}#postgresql-publication-autocreate-mode[`publication.autocreate.mode`]

See xref:{link-postgresql-connector}#postgresql-property-slot-name[`slot.name`] and xref:{link-postgresql-connector}#postgresql-property-publication-name[`publication.name`] on how to set a unique replication slot name and publication name for each connector.

// Type: procedure
// ModuleID: upgrading-postgresql-databases-that-debezium-captures-from
// Title: Upgrading PostgreSQL databases that {prodname} captures from
[id="upgrading-postgresql"]
=== Upgrading PostgreSQL

When you upgrade the PostgreSQL database that {prodname} uses, you must take specific steps to protect against data loss and to ensure that {prodname} continues to operate.
In general, {prodname} is resilient to interruptions caused by network failures and other outages.
For example, when a database server that a connector monitors stops or crashes, after the connector re-establishes communication with the PostgreSQL server, it continues to read from the last position recorded by the log sequence number (LSN) offset.
The connector retrieves information about the last recorded offset from the Kafka Connect offsets topic, and queries the configured PostgreSQL replication slot for a log sequence number (LSN) with the same value.

For the connector to start and to capture change events from a PostgreSQL database, a replication slot must be present.
However, as part of the PostgreSQL upgrade process, replication slots are removed, and the original slots are not restored after the upgrade completes.
As a result, when the connector restarts and requests the last known offset from the replication slot, PostgreSQL cannot return the information.

You can create a new replication slot, but you must do more than create a new slot to guard against data loss.
A new replication slot can provide the LSNs only for changes the occur after you create the slot; it cannot provide the offsets for events that occurred before the upgrade.
When the connector restarts, it first requests the last known offset from the Kafka offsets topic.
It then sends a request to the replication slot to return information for the offset retrieved from the offsets topic.
But the new replication slot cannot provide the information that the connector needs to resume streaming from the expected position.
The connector then skips any existing change events in the log, and only resumes streaming from the most recent position in the log.
This can lead to silent data loss: the connector emits no records for the skipped events, and it does not provide any information to indicate that events were skipped.

For guidance about how to perform a PostgreSQL database upgrade so that {prodname} can continue to capture events while minimizing the risk of data loss, see the following procedure.

.Procedure

1. Temporarily stop applications that write to the database, or put them into a read-only mode.

2. Back up the database.

3. Temporarily disable write access to the database.

4. Verify that any changes that occurred in the database before you blocked write operations are saved to the write-ahead log (WAL), and that the WAL LSN is reflected on the replication slot.

5. Provide the connector with enough time to capture all event records that are written to the replication slot. +
This step ensures that all change events that occurred before the downtime are accounted for, and that they are saved to Kafka.

6. Verify that the connector has finished consuming entries from the replication slot by checking the value of the flushed LSN.

7. Shut down the connector gracefully by stopping Kafka Connect. +
Kafka Connect stops the connectors, flushes all event records to Kafka, and records the last offset received from each connector. +
+
[NOTE]
====
As an alternative to stopping the entire Kafka Connect cluster, you can stop the connector by deleting it.
Do not remove the offset topic, because it might be shared by other Kafka connectors.
Later, after you restore write access to the database and you are ready to restart the connector, you must recreate the connector.
====

8. As a PostgreSQL administrator, drop the replication slot on the primary database server.
Do not use the xref:postgresql-property-slot-drop-on-stop[`slot.drop.on.stop`] property to drop the replication slot.
This property is for testing only.

9. Stop the database.

10. Perform the upgrade using an approved PostgreSQL upgrade procedure, such as `pg_upgrade`, or `pg_dump` and `pg_restore`.

11. (Optional) Use a standard Kafka tool to remove the connector offsets from the offset storage topic. +
For an example of how to remove connector offsets, see https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector[how to remove connector offsets] in the {prodname} community FAQ.

12. Restart the database.

13. As a PostgreSQL administrator, create a {prodname} logical replication slot on the database.
You must create the slot before enabling writes to the database.
Otherwise, {prodname} cannot capture the changes, resulting in data loss.


14. Verify that the publication that defines the tables for {prodname} to capture is still present after the upgrade.
If the publication is not available, connect to the database as a PostgreSQL administrator to create a new publication.

15. If it was necessary to create a new publication in the previous step, update the {prodname} connector configuration to add the name of the new publication to the xref:postgresql-property-publication-name[`publication.name`] property.

16. In the connector configuration, rename the connector.

17. In the connector configuration, set xref:postgresql-property-slot-name[`slot.name`] to the name of the {prodname} replication slot.

18. Verify that the new replication slot is available.

19. Restore write access to the database and restart any applications that write to the database.

20. In the connector configuration, set the xref:postgresql-property-snapshot-mode[`snapshot.mode`] property to `never`, and then restart the connector.
+
[NOTE]
====
If you were unable to verify that {prodname} finished reading all database changes in Step 6, you can configure the connector to perform a new snapshot by setting `snapshot.mode=initial`.
If necessary, you can confirm whether the connector read all changes from the replication slot by checking the contents of a database backup that was taken immediately before the upgrade.
====

.Additional resources
* xref:postgresql-server-configuration[Configuring replication slots for {prodname}]

// Type: assembly
// ModuleID: deployment-of-debezium-postgresql-connectors
// Title: Deployment of {prodname} PostgreSQL connectors
[[postgresql-deployment]]
== Deployment

To deploy a {prodname} PostgreSQL connector, you install the {prodname} PostgreSQL connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect.

.Prerequisites

* link:https://zookeeper.apache.org/[Zookeeper], link:http://kafka.apache.org/[Kafka], and link:{link-kafka-docs}.html#connect[Kafka Connect] are installed.
* PostgreSQL is installed and is xref:setting-up-postgresql[set up to run the {prodname} connector].

.Procedure

. Download the {prodname} link:https://repo1.maven.org/maven2/io/debezium/debezium-connector-postgres/{debezium-version}/debezium-connector-postgres-{debezium-version}-plugin.tar.gz[PostgreSQL connector plug-in archive].
. Extract the files into your Kafka Connect environment.
. Add the directory with the JAR files to {link-kafka-docs}/#connectconfigs[Kafka Connect's `plugin.path`].
. Restart your Kafka Connect process to pick up the new JAR files.

If you are working with immutable containers, see link:https://quay.io/organization/debezium[{prodname}'s Container images] for Zookeeper, Kafka, PostgreSQL and Kafka Connect with the PostgreSQL connector already installed and ready to run. You can also xref:operations/openshift.adoc[run {prodname} on Kubernetes and OpenShift].



[[postgresql-example-configuration]]
=== Connector configuration example

Following is an example of the configuration for a PostgreSQL connector that connects to a PostgreSQL server on port 5432 at 192.168.99.100, whose logical name is `fulfillment`.
Typically, you configure the {prodname} PostgreSQL connector in a JSON file by setting the configuration properties available for the connector.

You can choose to produce events for a subset of the schemas and tables in a database.
Optionally, you can ignore, mask, or truncate columns that contain sensitive data, are larger than a specified size, or that you do not need.

[source,json]
----
{
  "name": "fulfillment-connector",  // <1>
  "config": {
    "connector.class": "io.debezium.connector.postgresql.PostgresConnector", // <2>
    "database.hostname": "192.168.99.100", // <3>
    "database.port": "5432", // <4>
    "database.user": "postgres", // <5>
    "database.password": "postgres", // <6>
    "database.dbname" : "postgres", // <7>
    "topic.prefix": "fulfillment", // <8>
    "table.include.list": "public.inventory" // <9>

  }
}
----
<1> The name of the connector when registered with a Kafka Connect service.
<2> The name of this PostgreSQL connector class.
<3> The address of the PostgreSQL server.
<4> The port number of the PostgreSQL server.
<5> The name of the PostgreSQL user that has the xref:postgresql-permissions[required privileges].
<6> The password for the PostgreSQL user that has the xref:postgresql-permissions[required privileges].
<7> The name of the PostgreSQL database to connect to
<8> The topic prefix for the PostgreSQL server/cluster, which forms a namespace and is used in all the names of the Kafka topics to which the connector writes, the Kafka Connect schema names, and the namespaces of the corresponding Avro schema when the Avro converter is used.
<9> A list of all tables hosted by this server that this connector will monitor. This is optional, and there are other properties for listing the schemas and tables to include or exclude from monitoring.

See the xref:postgresql-connector-properties[complete list of PostgreSQL connector properties] that can be specified in these configurations.

You can send this configuration with a `POST` command to a running Kafka Connect service.
The service records the configuration and starts one connector task that performs the following actions:

* Connects to the PostgreSQL database.
* Reads the transaction log.
* Streams change event records to Kafka topics.

[[postgresql-adding-connector-configuration]]
=== Adding connector configuration

To run a {prodname} PostgreSQL connector, create a connector configuration and add the configuration to your Kafka Connect cluster.

.Prerequisites

* xref:postgresql-server-configuration[PostgreSQL is configured to support logical replication].

* The xref:installing-postgresql-output-plugin[logical decoding plug-in] is installed.

* The PostgreSQL connector is installed.

.Procedure

. Create a configuration for the PostgreSQL connector.

. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster.


.Results

After the connector starts, it xref:postgresql-snapshots[performs a consistent snapshot] of the PostgreSQL server databases that the connector is configured for. The connector then starts generating data change events for row-level operations and streaming change event records to Kafka topics.


// Type: reference
// Title: Descriptions of {prodname} PostgreSQL connector configuration properties
// ModuleID: descriptions-of-debezium-postgresql-connector-configuration-properties
[[postgresql-connector-properties]]
=== Connector properties

The {prodname} PostgreSQL connector has many configuration properties that you can use to achieve the right connector behavior for your application. Many properties have default values. Information about the properties is organized as follows:

* xref:postgresql-required-configuration-properties[Required configuration properties]
* xref:postgresql-advanced-configuration-properties[Advanced configuration properties]
* xref:postgresql-pass-through-properties[Pass-through configuration properties]

[id="postgresql-required-configuration-properties"]
The following configuration properties are _required_ unless a default value is available.

.Required connector configuration properties
[cols="30%a,25%a,45%a",options="header"]
|===
|Property
|Default
|Description

|[[postgresql-property-name]]<<postgresql-property-name, `+name+`>>
|No default
|Unique name for the connector. Attempting to register again with the same name will fail. This property is required by all Kafka Connect connectors.

|[[postgresql-property-connector-class]]<<postgresql-property-connector-class, `+connector.class+`>>
|No default
|The name of the Java class for the connector. Always use a value of `io.debezium.connector.postgresql.PostgresConnector` for the PostgreSQL connector.

|[[postgresql-property-tasks-max]]<<postgresql-property-tasks-max, `+tasks.max+`>>
|`1`
|The maximum number of tasks that should be created for this connector. The PostgreSQL connector always uses a single task and therefore does not use this value, so the default is always acceptable.

|[[postgresql-property-plugin-name]]<<postgresql-property-plugin-name, `+plugin.name+`>>
|`decoderbufs`
|The name of the PostgreSQL xref:postgresql-output-plugin[logical decoding plug-in] installed on the PostgreSQL server.

Supported values are `decoderbufs`, and `pgoutput`.

|[[postgresql-property-slot-name]]<<postgresql-property-slot-name, `+slot.name+`>>
|`debezium`
|The name of the PostgreSQL logical decoding slot that was created for streaming changes from a particular plug-in for a particular database/schema. The server uses this slot to stream events to the {prodname} connector that you are configuring.

Slot names must conform to link:https://www.postgresql.org/docs/current/static/warm-standby.html#STREAMING-REPLICATION-SLOTS-MANIPULATION[PostgreSQL replication slot naming rules], which state: _"Each replication slot has a name, which can contain lower-case letters, numbers, and the underscore character."_

|[[postgresql-property-slot-drop-on-stop]]<<postgresql-property-slot-drop-on-stop, `+slot.drop.on.stop+`>>
|`false`
|Whether or not to delete the logical replication slot when the connector stops in a graceful, expected way. The default behavior is that the replication slot remains configured for the connector when the connector stops. When the connector restarts, having the same replication slot enables the connector to start processing where it left off.

Set to `true` in only testing or development environments. Dropping the slot allows the database to discard WAL segments. When the connector restarts it performs a new snapshot or it can continue from a persistent offset in the Kafka Connect offsets topic.

|[[postgresql-property-publication-name]]<<postgresql-property-publication-name, `+publication.name+`>>
|`dbz_publication`
|The name of the PostgreSQL publication created for streaming changes when using `pgoutput`.

This publication is created at start-up if it does not already exist and it includes _all tables_.
{prodname} then applies its own include/exclude list filtering, if configured, to limit the publication to change events for the specific tables of interest.
The connector user must have superuser permissions to create this publication,
so it is usually preferable to create the publication before starting the connector for the first time.

If the publication already exists, either for all tables or configured with a subset of tables, {prodname} uses the publication as it is defined.

|[[postgresql-property-database-hostname]]<<postgresql-property-database-hostname, `+database.hostname+`>>
|No default
|IP address or hostname of the PostgreSQL database server.

|[[postgresql-property-database-port]]<<postgresql-property-database-port, `+database.port+`>>
|`5432`
|Integer port number of the PostgreSQL database server.

|[[postgresql-property-database-user]]<<postgresql-property-database-user, `+database.user+`>>
|No default
|Name of the PostgreSQL database user for connecting to the PostgreSQL database server.

|[[postgresql-property-database-password]]<<postgresql-property-database-password, `+database.password+`>>
|No default
|Password to use when connecting to the PostgreSQL database server.

|[[postgresql-property-database-dbname]]<<postgresql-property-database-dbname, `+database.dbname+`>>
|No default
|The name of the PostgreSQL database from which to stream the changes.

|[[postgresql-property-topic-prefix]]<<postgresql-property-topic-prefix, `+topic.prefix+`>>
|No default
|Topic prefix that provides a namespace for the particular PostgreSQL database server or cluster in which {prodname} is capturing changes.
The prefix should be unique across all other connectors, since it is used as a topic name prefix for all Kafka topics that receive records from this connector.
Only alphanumeric characters, hyphens, dots and underscores must be used in the database server logical name. +
 +
[WARNING]
====
Do not change the value of this property.
If you change the name value, after a restart, instead of continuing to emit events to the original topics, the connector emits subsequent events to topics whose names are based on the new value.
====

|[[postgresql-property-schema-include-list]]<<postgresql-property-schema-include-list, `+schema.include.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match names of schemas for which you *want* to capture changes.
Any schema name not included in `schema.include.list` is excluded from having its changes captured.
By default, all non-system schemas have their changes captured. +

To match the name of a schema, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire identifier for the schema; it does not match substrings that might be present in a schema name. +
If you include this property in the configuration, do not also set the `schema.exclude.list` property.

|[[postgresql-property-schema-exclude-list]]<<postgresql-property-schema-exclude-list, `+schema.exclude.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match names of schemas for which you *do not* want to capture changes.
Any schema whose name is not included in `schema.exclude.list` has its changes captured, with the exception of system schemas. +

To match the name of a schema, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire identifier for the schema; it does not match substrings that might be present in a schema name. +
If you include this property in the configuration, do not set the `schema.include.list` property.

|[[postgresql-property-table-include-list]]<<postgresql-property-table-include-list, `+table.include.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers for tables whose changes you want to capture.
When this property is set, the connector captures changes only from the specified tables.
Each identifier is of the form _schemaName_._tableName_.
By default, the connector captures changes in every non-system table in each schema whose changes are being captured. +

To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire identifier for the table; it does not match substrings that might be present in a table name. +
If you include this property in the configuration, do not also set the `table.exclude.list` property.

|[[postgresql-property-table-exclude-list]]<<postgresql-property-table-exclude-list, `+table.exclude.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers for tables whose changes you do not want to capture.
Each identifier is of the form _schemaName_._tableName_.
When this property is set, the connector captures changes from every table that you do not specify. +

To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire identifier for the table; it does not match substrings that might be present in a table name. +
If you include this property in the configuration, do not set the `table.include.list` property.

|[[postgresql-property-column-include-list]]<<postgresql-property-column-include-list, `+column.include.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns that should be included in change event record values.
Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_. +

To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the expression is used to match the entire name string of the column; it does not match substrings that might be present in a column name. +
If you include this property in the configuration, do not also set the `column.exclude.list` property.

|[[postgresql-property-column-exclude-list]]<<postgresql-property-column-exclude-list, `+column.exclude.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns that should be excluded from change event record values.
Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_. +

To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the expression is used to match the entire name string of the column; it does not match substrings that might be present in a column name. +
If you include this property in the configuration, do not set the `column.include.list` property.

|[[postgresql-property-skip-messages-without-change]]<<postgresql-property-skip-messages-without-change, `+skip.messages.without.change+`>>
|`false`
| Specifies whether to skip publishing messages when there is no change in included columns. This would essentially filter messages if there is no change in columns included as per `column.include.list` or `column.exclude.list` properties.

Note: Only works when REPLICA IDENTITY of the table is set to FULL


|[[postgresql-property-time-precision-mode]]<<postgresql-property-time-precision-mode, `+time.precision.mode+`>>
|`adaptive`
|Time, date, and timestamps can be represented with different kinds of precision: +
 +
`adaptive` captures the time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type. +
 +
`adaptive_time_microseconds` captures the date, datetime and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type.
An exception is `TIME` type fields, which are always captured as microseconds. +
 +
`connect` always represents time and timestamp values by using Kafka Connect's built-in representations for `Time`, `Date`, and `Timestamp`, which use millisecond precision regardless of the database columns' precision.
For more information, see xref:postgresql-temporal-types[temporal values].

|[[postgresql-property-decimal-handling-mode]]<<postgresql-property-decimal-handling-mode, `+decimal.handling.mode+`>>
|`precise`
|Specifies how the connector should handle values for `DECIMAL` and `NUMERIC` columns: +
 +
`precise` represents values by using `java.math.BigDecimal` to represent values in binary form in change events. +
 +
`double` represents values by using `double` values, which might result in a loss of precision but which is easier to use. +
 +
`string` encodes values as formatted strings, which are easy to consume but semantic information about the real type is lost.
For more information, see xref:postgresql-decimal-types[Decimal types].

|[[postgresql-property-hstore-handling-mode]]<<postgresql-property-hstore-handling-mode, `+hstore.handling.mode+`>>
|`json`
| Specifies how the connector should handle values for `hstore` columns: +
 +
`map` represents values by using `MAP`. +
 +
`json` represents values by using `json string`. This setting encodes values as formatted strings such as `{"key" : "val"}`.
For more information, see xref:postgresql-hstore-type[PostgreSQL `HSTORE` type].

|[[postgresql-property-interval-handling-mode]]<<postgresql-property-interval-handling-mode, `+interval.handling.mode+`>>
|`numeric`
| Specifies how the connector should handle values for `interval` columns: +
 +
`numeric` represents intervals using approximate number of microseconds. +
 +
`string` represents intervals exactly by using the string pattern representation `P<years>Y<months>M<days>DT<hours>H<minutes>M<seconds>S`.
For example: `P1Y2M3DT4H5M6.78S`.
For more information, see xref:postgresql-basic-types[PostgreSQL basic types].

|[[postgresql-property-database-sslmode]]<<postgresql-property-database-sslmode, `+database.sslmode+`>>
|`prefer`
|Whether to use an encrypted connection to the PostgreSQL server. Options include: +
 +
`disable` uses an unencrypted connection. +
 +
`allow` attempts to use an unencrypted connection first and, failing that, a secure (encrypted) connection. +
 +
`prefer` attempts to use a secure (encrypted) connection first and, failing that, an unencrypted connection. +
 +
`require` uses a secure (encrypted) connection, and fails if one cannot be established. +
 +
`verify-ca` behaves like `require` but also verifies the server TLS certificate against the configured Certificate Authority (CA) certificates, or fails if no valid matching CA certificates are found. +
 +
`verify-full` behaves like `verify-ca` but also verifies that the server certificate matches the host to which the connector is trying to connect.
For more information, see link:https://www.postgresql.org/docs/current/static/libpq-connect.html[the PostgreSQL documentation].

|[[postgresql-property-database-sslcert]]<<postgresql-property-database-sslcert, `+database.sslcert+`>>
|No default
|The path to the file that contains the SSL certificate for the client.
For more information, see link:https://www.postgresql.org/docs/current/static/libpq-connect.html[the PostgreSQL documentation].

|[[postgresql-property-database-sslkey]]<<postgresql-property-database-sslkey, `+database.sslkey+`>>
|No default
|The path to the file that contains the SSL private key of the client.
For more information, see link:https://www.postgresql.org/docs/current/static/libpq-connect.html[the PostgreSQL documentation].

|[[postgresql-property-database-sslpassword]]<<postgresql-property-database-sslpassword, `+database.sslpassword+`>>
|No default
|The password to access the client private key from the file specified by `database.sslkey`.
For more information, see link:https://www.postgresql.org/docs/current/static/libpq-connect.html[the PostgreSQL documentation].

|[[postgresql-property-database-sslrootcert]]<<postgresql-property-database-sslrootcert, `+database.sslrootcert+`>>
|No default
|The path to the file that contains the root certificate(s) against which the server is validated.
For more information, see link:https://www.postgresql.org/docs/current/static/libpq-connect.html[the PostgreSQL documentation].

|[[postgresql-property-database-tcpkeepalive]]<<postgresql-property-database-tcpkeepalive, `+database.tcpKeepAlive+`>>
|`true`
|Enable TCP keep-alive probe to verify that the database connection is still alive.
For more information, see link:https://www.postgresql.org/docs/current/static/libpq-connect.html[the PostgreSQL documentation].

|[[postgresql-property-tombstones-on-delete]]<<postgresql-property-tombstones-on-delete, `+tombstones.on.delete+`>>
|`true`
|Controls whether a _delete_ event is followed by a tombstone event. +
 +
`true` - a delete operation is represented by a _delete_ event and a subsequent tombstone event.  +
 +
`false` - only a _delete_ event is emitted. +
 +
After a source record is deleted, emitting a tombstone event (the default behavior) allows Kafka to completely delete all events that pertain to the key of the deleted row in case {link-kafka-docs}/#compaction[log compaction] is enabled for the topic.

|[[postgresql-property-column-truncate-to-length-chars]]<<postgresql-property-column-truncate-to-length-chars, `column.truncate.to._length_.chars`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want to truncate the data in a set of columns when it exceeds the number of characters specified by the _length_ in the property name.
Set `length` to a positive integer value, for example, `column.truncate.to.20.chars`.

The fully-qualified name of a column observes the following format: `_<schemaName>_._<tableName>_._<columnName>_`.
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.

You can specify multiple properties with different lengths in a single configuration.

|[[postgresql-property-column-mask-with-length-chars]]<<postgresql-property-column-mask-with-length-chars, `column.mask.with._length_.chars`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want the connector to mask the values for a set of columns, for example, if they contain sensitive data.
Set `_length_` to a positive integer to replace data in the specified columns with the number of asterisk (`*`) characters specified by the _length_ in the property name.
Set _length_ to `0` (zero) to replace data in the specified columns with an empty string.

The fully-qualified name of a column observes the following format: _schemaName_._tableName_._columnName_.
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.

You can specify multiple properties with different lengths in a single configuration.

|[[postgresql-property-column-mask-hash]]<<postgresql-property-column-mask-hash, `column.mask.hash._hashAlgorithm_.with.salt._salt_`>>;
[[postgresql-property-column-mask-hash-v2]]<<postgresql-property-column-mask-hash-v2, `column.mask.hash.v2._hashAlgorithm_.with.salt._salt_`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Fully-qualified names for columns are of the form _<schemaName>_._<tableName>_._<columnName>_. +
To match the name of a column {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.
In the resulting change event record, the values for the specified columns are replaced with pseudonyms. +

A pseudonym consists of the hashed value that results from applying the specified _hashAlgorithm_ and _salt_.
Based on the hash function that is used, referential integrity is maintained, while column values are replaced with pseudonyms.
Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation. +
 +
In the following example, `CzQMA0cB5K` is a randomly selected salt. +

----
column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName
----

If necessary, the pseudonym is automatically shortened to the length of the column.
The connector configuration can include multiple properties that specify different hash algorithms and salts. +
 +
Depending on the _hashAlgorithm_ used, the _salt_ selected, and the actual data set, the resulting data set might not be completely masked. +
 +
Hashing strategy version 2 should be used to ensure fidelity if the value is being hashed in different places or systems.

|[[postgresql-property-column-propagate-source-type]]<<postgresql-property-column-propagate-source-type, `+column.propagate.source.type+`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns for which you want the connector to emit extra parameters that represent column metadata.
When this property is set, the connector adds the following fields to the schema of event records:

* `pass:[_]pass:[_]debezium.source.column.type` +
* `pass:[_]pass:[_]debezium.source.column.length` +
* `pass:[_]pass:[_]debezium.source.column.scale` +

These parameters propagate a column's original type name and length (for variable-width types), respectively. +
Enabling the connector to emit this extra data can assist in properly sizing specific numeric or character-based columns in sink databases.

The fully-qualified name of a column observes one of the following formats: _databaseName_._tableName_._columnName_, or _databaseName_._schemaName_._tableName_._columnName_. +
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.

|[[postgresql-property-datatype-propagate-source-type]]<<postgresql-property-datatype-propagate-source-type, `+datatype.propagate.source.type+`>>
|_n/a_
|An optional, comma-separated list of regular expressions that specify the fully-qualified names of data types that are defined for columns in a database.
When this property is set, for columns with matching data types, the connector emits event records that include the following extra fields in their schema:

* `pass:[_]pass:[_]debezium.source.column.type` +
* `pass:[_]pass:[_]debezium.source.column.length` +
* `pass:[_]pass:[_]debezium.source.column.scale` +

These parameters propagate a column's original type name and length (for variable-width types), respectively. +
Enabling the connector to emit this extra data can assist in properly sizing specific numeric or character-based columns in sink databases.

The fully-qualified name of a column observes one of the following formats: _databaseName_._tableName_._typeName_, or _databaseName_._schemaName_._tableName_._typeName_. +
To match the name of a data type, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the data type; the expression does not match substrings that might be present in a type name.

For the list of PostgreSQL-specific data type names, see the xref:postgresql-data-types[PostgreSQL data type mappings].

|[[postgresql-property-message-key-columns]]<<postgresql-property-message-key-columns, `+message.key.columns+`>>
|_empty string_
|A list of expressions that specify the columns that the connector uses to form custom message keys for change event records that it publishes to the Kafka topics for specified tables.

By default, {prodname} uses the primary key column of a table as the message key for records that it emits.
In place of the default, or to specify a key for tables that lack a primary key, you can configure custom message keys based on one or more columns. +
 +
To establish a custom message key for a table, list the table, followed by the columns to use as the message key.
Each list entry takes the following format: +
 +
`_<fully-qualified_tableName>_:__<keyColumn>__,_<keyColumn>_` +
 +
To base a table key on multiple column names, insert commas between the column names.

Each fully-qualified table name is a regular expression in the following format: +
 +
`_<schemaName>_._<tableName>_` +
 +
The property can include entries for multiple tables.
Use a semicolon to separate table entries in the list. +
 +
The following example sets the message key for the tables `inventory.customers` and `purchase.orders`: +
 +
`inventory.customers:pk1,pk2;(.*).purchaseorders:pk3,pk4` +
 +
For the table `inventory.customer`, the columns `pk1` and `pk2` are specified as the message key.
For the `purchaseorders` tables in any schema, the columns `pk3` and `pk4` server as the message key.

There is no limit to the number of columns that you use to create custom message keys.
However, it's best to use the minimum number that are required to specify a unique key.

Note that having this property set and `REPLICA IDENTITY` set to `DEFAULT` on the tables, will cause the tombstone events to not be created properly if the key columns are not part of the primary key of the table. +
Setting `REPLICA IDENTITY` to `FULL` is the only solution.
|[[postgresql-publication-autocreate-mode]]<<postgresql-publication-autocreate-mode, `+publication.autocreate.mode+`>>
|_all_tables_
|Applies only when streaming changes by using link:https://www.postgresql.org/docs/current/sql-createpublication.html[the `pgoutput` plug-in].
The setting determines how creation of a link:https://www.postgresql.org/docs/current/logical-replication-publication.html[publication] should work.
Specify one of the following values: +
 +
`all_tables` - If a publication exists, the connector uses it.
If a publication does not exist, the connector creates a publication for all tables in the database for which the connector is capturing changes.
For the connector to create a publication it must access the database through a database user account that has permission to create publications and perform replications.
You grant the required permission by using the following SQL command `CREATE PUBLICATION <publication_name> FOR ALL TABLES;`. +
 +
`disabled` - The connector does not attempt to create a publication.
A database administrator or the user configured to perform replications must have created the publication before running the connector.
If the connector cannot find the publication, the connector throws an exception and stops. +
 +
`filtered` - If a publication exists, the connector uses it.
If no publication exists, the connector creates a new publication for tables that match the current filter configuration as specified by the `schema.include.list`, `schema.exclude.list`, and `table.include.list`, and `table.exclude.list` connector configuration properties.
For example: `CREATE PUBLICATION <publication_name> FOR TABLE <tbl1, tbl2, tbl3>`.
If the publication exists, the connector updates the publication for tables that match the current filter configuration.
For example: `ALTER PUBLICATION <publication_name> SET TABLE <tbl1, tbl2, tbl3>`.

|[[postgresql-replica-autoset-type]]<<postgresql-replica-autoset-type, `+replica.identity.autoset.values+`>>
|_empty string_
|The setting determines the value for link:https://www.postgresql.org/docs/current/sql-altertable.html#SQL-ALTERTABLE-REPLICA-IDENTITY[replica identity] at table level. +
 +
This option will overwrite the existing value in database.
A comma-separated list of regular expressions that match fully-qualified tables and replica identity value to be used in the table. +
 +
Each expression must match the pattern '<fully-qualified table name>:<replica identity>', where the table name could be defined as (`SCHEMA_NAME.TABLE_NAME`), and the replica identity values are: +
 +
`DEFAULT` - Records the old values of the columns of the primary key, if any. This is the default for non-system tables. +
 +
`INDEX index_name` - Records the old values of the columns covered by the named index, that must be unique, not partial, not deferrable, and include only columns marked NOT NULL. If this index is dropped, the behavior is the same as NOTHING. +
 +
`FULL` - Records the old values of all columns in the row. +
 +
`NOTHING` - Records no information about the old row. This is the default for system tables. +
 +
For example,

 schema1.*:FULL,schema2.table2:NOTHING,schema2.table3:INDEX idx_name


|[[postgresql-property-binary-handling-mode]]<<postgresql-property-binary-handling-mode, `+binary.handling.mode+`>>
|bytes
|Specifies how binary (`bytea`) columns should be represented in change events: +
 +
`bytes` represents binary data as  byte array. +
 +
`base64` represents binary data as base64-encoded strings. +
 +
`base64-url-safe` represents binary data as base64-url-safe-encoded strings. +
 +
`hex` represents binary data as hex-encoded (base16) strings.

|[[postgresql-property-schema-name-adjustment-mode]]<<postgresql-property-schema-name-adjustment-mode,`+schema.name.adjustment.mode+`>>
|none
|Specifies how schema names should be adjusted for compatibility with the message converter used by the connector. Possible settings:  +

* `none` does not apply any adjustment. +
* `avro` replaces the characters that cannot be used in the Avro type name with underscore. +
* `avro_unicode` replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java +

|[[postgresql-property-field-name-adjustment-mode]]<<postgresql-property-field-name-adjustment-mode,`+field.name.adjustment.mode+`>>
|none
|Specifies how field names should be adjusted for compatibility with the message converter used by the connector. Possible settings:  +

* `none` does not apply any adjustment. +
* `avro` replaces the characters that cannot be used in the Avro type name with underscore. +
* `avro_unicode` replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java +

For more information, see {link-prefix}:{link-avro-serialization}#avro-naming[Avro naming].

|[[postgresql-property-money-fraction-digits]]<<postgresql-property-money-fraction-digits, `+money.fraction.digits+`>>
|`2`
|Specifies how many decimal digits should be used when converting Postgres `money` type to `java.math.BigDecimal`, which represents the values in change events.
Applicable only when xref:postgresql-property-decimal-handling-mode[`decimal.handling.mode`] is set to `precise`.

|[[postgresql-property-logical-decoding-message-prefix-include-list]]<<postgresql-property-logical-decoding-message-prefix-include-list, `+message.prefix.include.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match the names of the logical decoding message prefixes that you want the connector to capture.
By default, the connector captures all logical decoding messages.
When this property is set, the connector captures only logical decoding message with the prefixes specified by the property.
All other logical decoding messages are excluded.

To match the name of a message prefix, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire message prefix string; the expression does not match substrings that might be present in a prefix.

If you include this property in the configuration, do not also set the xref:postgresql-property-logical-decoding-message-prefix-exclude-list[`message.prefix.exclude.list`] property.

For information about the structure of _message_ events and about their ordering semantics, see xref:postgresql-message-events[].

|[[postgresql-property-logical-decoding-message-prefix-exclude-list]]<<postgresql-property-logical-decoding-message-prefix-exclude-list, `+message.prefix.exclude.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match the names of the logical decoding message prefixes that you do not want the connector to capture.
When this property is set, the connector does not capture logical decoding messages that use the specified prefixes.
All other messages are captured. +
To exclude all logical decoding messages, set the value of this property to `.*`.

To match the name of a message prefix, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire message prefix string; the expression does not match substrings that might be present in a prefix.

If you include this property in the configuration, do not also set xref:postgresql-property-logical-decoding-message-prefix-include-list[`message.prefix.include.list`] property. +

For information about the structure of _message_ events and about their ordering semantics, see xref:postgresql-message-events[].

|===

// Title: Advanced {prodname} PostgreSQL connector configuration properties
[id="postgresql-advanced-configuration-properties"]
The following _advanced_ configuration properties have defaults that work in most situations and therefore rarely need to be specified in the connector's configuration.

.Advanced connector configuration properties
[cols="30%a,28%a,42%a",options="header"]
|===
|Property
|Default
|Description

|[[postgresql-property-converters]]<<postgresql-property-converters, `converters`>>
|No default
|Enumerates a comma-separated list of the symbolic names of the {link-prefix}:{link-custom-converters}#custom-converters[custom converter] instances that the connector can use.
For example, +

`isbn`

You must set the `converters` property to enable the connector to use a custom converter.

For each converter that you configure for a connector, you must also add a `.type` property, which specifies the fully-qualified name of the class that implements the converter interface.
The `.type` property uses the following format: +

`_<converterSymbolicName>_.type` +

For example, +

 isbn.type: io.debezium.test.IsbnConverter

If you want to further control the behavior of a configured converter, you can add one or more configuration parameters to pass values to the converter.
To associate any additional configuration parameter with a converter, prefix the parameter names with the symbolic name of the converter. +
For example, +

 isbn.schema.name: io.debezium.postgresql.type.Isbn

|[[postgresql-property-snapshot-mode]]<<postgresql-property-snapshot-mode, `+snapshot.mode+`>>
|_initial_
|Specifies the criteria for performing a snapshot when the connector starts: +

`always`:: The connector performs a snapshot every time that it starts.
The snapshot includes the structure and data of the captured tables.
Specify this value to populate topics with a complete representation of the data from the captured tables every time that the connector starts.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

`initial`:: The connector performs a snapshot only when no offsets have been recorded for the logical server name.

`initial_only`:: The connector performs an initial snapshot and then stops, without processing any subsequent changes.

`no_data`:: The connector never performs snapshots.
When a connector is configured this way, after it starts, it behaves as follows:

If there is a previously stored LSN in the Kafka offsets topic, the connector continues streaming changes from that position.
If no LSN is stored, the connector starts streaming changes from the point in time when the PostgreSQL logical replication slot was created on the server.
Use this snapshot mode only when you know all data of interest is still reflected in the WAL.

`never`:: Deprecated see `no_data`.

`when_needed`:: After the connector starts, it performs a snapshot only if it detects one of the following circumstances:

* It cannot detect any topic offsets.
* A previously recorded offset specifies a log position that is not available on the server.

`configuration_based`:: With this option, you control snapshot behavior through a set of connector properties that have the prefix 'snapshot.mode.configuration.based'.

`custom`:: The connector performs a snapshot according to the implementation specified by the xref:postgresql-property-snapshot-mode-custom-name[`snapshot.mode.custom.name`] property, which defines a custom implementation of the `io.debezium.spi.snapshot.Snapshotter` interface.

For more information, see the xref:#postgresql-connector-snapshot-mode-options[table of `snapshot.mode` options].

|[[postgresql-property-snapshot-mode-configuration-based-snapshot-data]]<<postgresql-property-configuration-based-snapshot-data, `+snapshot.mode.configuration.based.snapshot.data+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table data when it performs a snapshot.

|[[postgresql-property-snapshot-mode-configuration-based-snapshot-schema]]<<postgresql-property-configuration-based-snapshot-schema, `+snapshot.mode.configuration.based.snapshot.schema+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes the table schema when it performs a snapshot.

|[[postgresql-property-snapshot-mode-configuration-based-start-stream]]<<postgresql-property-configuration-based-start-stream, `+snapshot.mode.configuration.based.start.stream+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector begins to stream change events after a snapshot completes.

|[[postgresql-property-snapshot-mode-configuration-based-snapshot-on-schema-error]]<<postgresql-property-configuration-based-snapshot-on-schema-error, `+snapshot.mode.configuration.based.snapshot.on.schema.error+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table schema in a snapshot if the schema history topic is not available.

|[[postgresql-property-snapshot-mode-configuration-based-snapshot-on-data-error]]<<postgresql-property-configuration-based-snapshot-on-data-error, `+snapshot.mode.configuration.based.snapshot.on.data.error+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, this property specifies whether the connector attempts to snapshot table data if it does not find the last committed offset in the transaction log. +
Set the value to `true` to instruct the connector to perform a new snapshot.

|[[postgresql-property-snapshot-mode-custom-name]]<<postgresql-property-snapshot-mode-custom-name, `+snapshot.mode.custom.name+`>>
|No default
| When `snapshot.mode` is set as `custom`, use this setting to specify the name of the custom implementation provided in the `name()` method that is defined by the 'io.debezium.spi.snapshot.Snapshotter' interface.
The provided implementation is called after a connector restart to determine whether to perform a snapshot.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[postgresql-property-snapshot-locking-mode]]<<postgresql-property-snapshot-locking-mode, `+snapshot.locking.mode+`>>
|`none`
|Specifies how the connector holds locks on tables while performing a schema snapshot: +
Set one of the following options:
 +
`shared`:: The connector holds a table lock that prevents exclusive table access during the initial portion phase of the snapshot in which database schemas and other metadata are read.
After the initial phase, the snapshot no longer requires table locks.
 +
`none`:: The connector avoids locks entirely. +
+
[WARNING]
====
Do not use this mode if schema changes might occur during the snapshot.
====

`custom`:: The connector performs a snapshot according to the implementation specified by the xref:postgresql-property-snapshot-locking-mode-custom-name[`snapshot.locking.mode.custom.name`] property, which is a custom implementation of the `io.debezium.spi.snapshot.SnapshotLock` interface.

|[[postgresql-property-snapshot-locking-mode-custom-name]]<<postgresql-property-snapshot-locking-mode-custom-name, `+snapshot.locking.mode.custom.name+`>>
|No default
| When xref:postgresql-property-snapshot-locking-mode[`snapshot.locking.mode`] is set to `custom`, use this setting to specify the name of the custom implementation provided in the `name()` method that is defined by the 'io.debezium.spi.snapshot.SnapshotLock' interface.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[postgresql-property-snapshot-query-mode]]<<postgresql-property-snapshot-query-mode, `+snapshot.query.mode+`>>
|`select_all`
|Specifies how the connector queries data while performing a snapshot. +
Set one of the following options:

`select_all`:: The connector performs a `select all` query by default, optionally adjusting the columns selected based on the column include and exclude list configurations.

`custom`:: The connector performs a snapshot query according to the implementation specified by the xref:postgresql-property-snapshot-snapshot-query-mode-custom-name[`snapshot.query.mode.custom.name`] property, which defines a custom implementation of the `io.debezium.spi.snapshot.SnapshotQuery` interface. +

This setting enables you to manage snapshot content in a more flexible manner compared to using the xref:postgresql-property-snapshot-select-statement-overrides[`snapshot.select.statement.overrides`] property.

|[[postgresql-property-snapshot-snapshot-query-mode-custom-name]]<<postgresql-property-snapshot-query-mode-custom-name, `+snapshot.query.mode.custom.name+`>>
|No default
| When xref:postgresql-property-snapshot-query-mode[`snapshot.query.mode`] is set as `custom`, use this setting to specify the name of the custom implementation provided in the `name()` method that is defined by the 'io.debezium.spi.snapshot.SnapshotQuery' interface.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[postgresql-property-snapshot-include-collection-list]]<<postgresql-property-snapshot-include-collection-list, `+snapshot.include.collection.list+`>>
| All tables specified in `table.include.list`
|An optional, comma-separated list of regular expressions that match the fully-qualified names (`_<schemaName>.<tableName>_`) of the tables to include in a snapshot.
The specified items must be named in the connector's xref:{context}-property-table-include-list[`table.include.list`] property.
This property takes effect only if the connector's xref:postgresql-property-snapshot-mode[`snapshot.mode`] property is set to a value other than `never`. +
This property does not affect the behavior of incremental snapshots. +

To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name.

|[[postgresql-property-snapshot-lock-timeout-ms]]<<postgresql-property-snapshot-lock-timeout-ms, `+snapshot.lock.timeout.ms+`>>
|`10000`
|Positive integer value that specifies the maximum amount of time (in milliseconds) to wait to obtain table locks when performing a snapshot. If the connector cannot acquire table locks in this time interval, the snapshot fails. xref:postgresql-snapshots[How the connector performs snapshots] provides details.

|[[postgresql-property-snapshot-select-statement-overrides]]<<postgresql-property-snapshot-select-statement-overrides, `+snapshot.select.statement.overrides+`>>
|No default
|Specifies the table rows to include in a snapshot.
Use the property if you want a snapshot to include only a subset of the rows in a table.
This property affects snapshots only.
It does not apply to events that the connector reads from the log.

The property contains a comma-separated list of fully-qualified table names in the form `_<schemaName>.<tableName>_`. For example, +
 +
`+"snapshot.select.statement.overrides": "inventory.products,customers.orders"+` +
 +
For each table in the list, add a further configuration property that specifies the `SELECT` statement for the connector to run on the table when it takes a snapshot.
The specified `SELECT` statement determines the subset of table rows to include in the snapshot.
Use the following format to specify the name of this `SELECT` statement property: +
 +
`snapshot.select.statement.overrides._<schemaName>_._<tableName>_`.
For example,
`snapshot.select.statement.overrides.customers.orders`. +
 +
Example:

From a `customers.orders` table that includes the soft-delete column, `delete_flag`, add the following properties if you want a snapshot to include only those records that are not soft-deleted:

----
"snapshot.select.statement.overrides": "customer.orders",
"snapshot.select.statement.overrides.customer.orders": "SELECT * FROM [customers].[orders] WHERE delete_flag = 0 ORDER BY id DESC"
----

In the resulting snapshot, the connector includes only the records for which `delete_flag = 0`.
|[[postgresql-property-event-processing-failure-handling-mode]]<<postgresql-property-event-processing-failure-handling-mode, `+event.processing.failure.handling.mode+`>>
|`fail`
| Specifies how the connector should react to exceptions during processing of events: +
 +
`fail` propagates the exception, indicates the offset of the problematic event, and causes the connector to stop. +
 +
`warn` logs the offset of the problematic event, skips that event, and continues processing. +
 +
`skip` skips the problematic event and continues processing.

|[[postgresql-property-max-batch-size]]<<postgresql-property-max-batch-size, `+max.batch.size+`>>
|`2048`
|Positive integer value that specifies the maximum size of each batch of events that the connector processes.

|[[postgresql-property-max-queue-size]]<<postgresql-property-max-queue-size, `+max.queue.size+`>>
|`8192`
|Positive integer value that specifies the maximum number of records that the blocking queue can hold.
When {prodname} reads events streamed from the database, it places the events in the blocking queue before it writes them to Kafka.
The blocking queue can provide backpressure for reading change events from the database
in cases where the connector ingests messages faster than it can write them to Kafka, or when Kafka becomes unavailable.
Events that are held in the queue are disregarded when the connector periodically records offsets.
Always set the value of `max.queue.size` to be larger than the value of xref:{context}-property-max-batch-size[`max.batch.size`].

|[[postgresql-property-max-queue-size-in-bytes]]<<postgresql-property-max-queue-size-in-bytes, `+max.queue.size.in.bytes+`>>
|`0`
|A long integer value that specifies the maximum volume of the blocking queue in bytes.
By default, volume limits are not specified for the blocking queue.
To specify the number of bytes that the queue can consume, set this property to a positive long value. +
If xref:postgresql-property-max-queue-size[`max.queue.size`] is also set, writing to the queue is blocked when the size of the queue reaches the limit specified by either property.
For example, if you set `max.queue.size=1000`, and `max.queue.size.in.bytes=5000`, writing to the queue is blocked after the queue contains 1000 records, or after the volume of the records in the queue reaches 5000 bytes.

|[[postgresql-property-poll-interval-ms]]<<postgresql-property-poll-interval-ms, `+poll.interval.ms+`>>
|`500`
|Positive integer value that specifies the number of milliseconds the connector should wait for new change events to appear before it starts processing a batch of events. Defaults to 500 milliseconds.

|[[postgresql-property-include-unknown-datatypes]]<<postgresql-property-include-unknown-datatypes, `+include.unknown.datatypes+`>>
|`false`
|Specifies connector behavior when the connector encounters a field whose data type is unknown. The default behavior is that the connector omits the field from the change event and logs a warning. +
 +
Set this property to `true` if you want the change event to contain an opaque binary representation of the field. This lets consumers decode the field. You can control the exact representation by setting the xref:postgresql-property-binary-handling-mode[`binary handling mode`] property.

NOTE: Consumers risk backward compatibility issues when `include.unknown.datatypes` is set to `true`. Not only may the database-specific binary representation change between releases, but if the data type is eventually supported by {prodname}, the data type will be sent downstream in a logical type, which would require adjustments by consumers. In general, when encountering unsupported data types, create a feature request so that support can be added.

|[[postgresql-property-database-initial-statements]]<<postgresql-property-database-initial-statements, `+database.initial.statements+`>>
|No default
|A semicolon separated list of SQL statements that the connector executes when it establishes a JDBC connection to the database. To use a semicolon as a character and not as a delimiter, specify two consecutive semicolons, `;;`. +
 +
The connector may establish JDBC connections at its own discretion. Consequently, this property is useful for configuration of session parameters only, and not for executing DML statements. +
 +
The connector does not execute these statements when it creates a connection for reading the transaction log. +

|[[postgresql-property-status-update-interval-ms]]<<postgresql-property-status-update-interval-ms, `+status.update.interval.ms+`>>
|`10000`
|Frequency for sending replication connection status updates to the server, given in milliseconds.
 +
The property also controls how frequently the database status is checked to detect a dead connection in case the database was shut down.

|[[postgresql-property-heartbeat-interval-ms]]<<postgresql-property-heartbeat-interval-ms, `+heartbeat.interval.ms+`>>
|`0`
|Controls how frequently the connector sends heartbeat messages to a Kafka topic. The default behavior is that the connector does not send heartbeat messages. +
 +
Heartbeat messages are useful for monitoring whether the connector is receiving change events from the database. Heartbeat messages might help decrease the number of change events that need to be re-sent when a connector restarts. To send heartbeat messages, set this property to a positive integer, which indicates the number of milliseconds between heartbeat messages. +
 +
Heartbeat messages are needed when there are many updates in a database that is being tracked but only a tiny number of updates are related to the table(s) and schema(s) for which the connector is capturing changes. In this situation, the connector reads from the database transaction log as usual but rarely emits change records to Kafka. This means that no offset updates are committed to Kafka and the connector does not have an opportunity to send the latest retrieved LSN to the database. The database retains WAL files that contain events that have already been processed by the connector. Sending heartbeat messages enables the connector to send the latest retrieved LSN to the database, which allows the database to reclaim disk space being used by no longer needed WAL files.

|[[postgresql-property-heartbeat-action-query]]<<postgresql-property-heartbeat-action-query, `+heartbeat.action.query+`>>
|No default
|Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. +
 +
This is useful for resolving the situation described in xref:postgresql-wal-disk-space[WAL disk space consumption], where capturing changes from a low-traffic database on the same host as a high-traffic database prevents {prodname} from processing WAL records and thus acknowledging WAL positions with the database. To address this situation, create a heartbeat table in the low-traffic database, and set this property to a statement that inserts records into that table, for example:  +
 +
`INSERT INTO test_heartbeat_table (text) VALUES ('test_heartbeat')` +
 +
This allows the connector to receive changes from the low-traffic database and acknowledge their LSNs, which prevents unbounded WAL growth on the database host.

|[[postgresql-property-schema-refresh-mode]]<<postgresql-property-schema-refresh-mode, `+schema.refresh.mode+`>>
|`columns_diff`
|Specify the conditions that trigger a refresh of the in-memory schema for a table. +
 +
`columns_diff` is the safest mode. It ensures that the in-memory schema stays in sync with the database table's schema at all times. +
 +
`columns_diff_exclude_unchanged_toast` instructs the connector to refresh the in-memory schema cache if there is a discrepancy with the schema derived from the incoming message, unless unchanged TOASTable data fully accounts for the discrepancy. +
 +
This setting can significantly improve connector performance if there are frequently-updated tables that have TOASTed data that are rarely part of updates. However, it is possible for the in-memory schema to
become outdated if TOASTable columns are dropped from the table.

|[[postgresql-property-snapshot-delay-ms]]<<postgresql-property-snapshot-delay-ms, `+snapshot.delay.ms+`>>
|No default
|An interval in milliseconds that the connector should wait before performing a snapshot when the connector starts. If you are starting multiple connectors in a cluster, this property is useful for avoiding snapshot interruptions, which might cause re-balancing of connectors.

|[[postgresql-property-streaming-delay-ms]]<<postgresql-property-streaming-delay-ms, `+streaming.delay.ms+`>>
|0
|Specifies the time, in milliseconds, that the connector delays the start of the streaming process after it completes a snapshot.
Setting a delay interval helps to prevent the connector from restarting snapshots in the event that a failure occurs immediately after the snapshot completes, but before the streaming process begins.
Set a delay value that is higher than the value of the {link-kafka-docs}/#connectconfigs_offset.flush.interval.ms[`offset.flush.interval.ms`] property that is set for the Kafka Connect worker.

|[[postgresql-property-snapshot-fetch-size]]<<postgresql-property-snapshot-fetch-size, `+snapshot.fetch.size+`>>
|`10240`
|During a snapshot, the connector reads table content in batches of rows. This property specifies the maximum number of rows in a batch.

|[[postgresql-property-slot-stream-params]]<<postgresql-property-slot-stream-params, `+slot.stream.params+`>>
|No default
|Semicolon separated list of parameters to pass to the configured logical decoding plug-in. For example, `add-tables=public.table,public.table2;include-lsn=true`.

|[[postgresql-property-slot-max-retries]]<<postgresql-property-slot-max-retries, `+slot.max.retries+`>>
|`6`
|If connecting to a replication slot fails, this is the maximum number of consecutive attempts to connect.

|[[postgresql-property-slot-retry-delay-ms]]<<postgresql-property-slot-retry-delay-ms, `+slot.retry.delay.ms+`>> +
|`10000` (10 seconds)
|The number of milliseconds to wait between retry attempts when the connector fails to connect to a replication slot.

|[[postgresql-property-unavailable-value-placeholder]]<<postgresql-property-unavailable-value-placeholder, `+unavailable.value.placeholder+`>>
|`__debezium_unavailable_value`
|Specifies the constant that the connector provides to indicate that the original value is a toasted value that is not provided by the database.
If the setting of `unavailable.value.placeholder` starts with the `hex:` prefix it is expected that the rest of the string represents hexadecimally encoded octets.
For more information, see xref:postgresql-toasted-values[toasted values].

|[[postgresql-property-provide-transaction-metadata]]<<postgresql-property-provide-transaction-metadata, `+provide.transaction.metadata+`>>
|`false`
|Determines whether the connector generates events with transaction boundaries and enriches change event envelopes with transaction metadata. Specify `true` if you want the connector to do this.
For more information, see xref:postgresql-transaction-metadata[Transaction metadata].

|[[postgresql-property-flush-lsn-source]]<<postgresql-property-flush-lsn-source, `+flush.lsn.source+`>>
|`true`
|Determines whether the connector should commit the LSN of the processed records in the source postgres database so that the WAL logs can be deleted. Specify `false` if you don't want the connector to do this. Please note that if set to `false` LSN will not be acknowledged by Debezium and as a result WAL logs will not be cleared which might result in disk space issues. User is expected to handle the acknowledgement of LSN outside Debezium.

|[[postgresql-property-retriable-restart-connector-wait-ms]]<<postgresql-property-retriable-restart-connector-wait-ms, `+retriable.restart.connector.wait.ms+`>> +
|10000 (10 seconds)
|The number of milliseconds to wait before restarting a connector after a retriable error occurs.

|[[postgresql-property-skipped-operations]]<<postgresql-property-skipped-operations, `+skipped.operations+`>>
|`t`
|A comma-separated list of operation types that will be skipped during streaming.
The operations include: `c` for inserts/create, `u` for updates, `d` for deletes, `t` for truncates, and `none` to not skip any operations.
By default, truncate operations are skipped.

|[[postgresql-property-signal-data-collection]]<<postgresql-property-signal-data-collection,`+signal.data.collection+`>>
|No default value
|Fully-qualified name of the data collection that is used to send signals to the connector. +
Use the following format to specify the collection name: +
`_<schemaName>_._<tableName>_` +

|[[postgresql-property-signal-enabled-channels]]<<postgresql-property-signal-enabled-channels, `+signal.enabled.channels+`>>
|source
| List of the signaling channel names that are enabled for the connector.
By default, the following channels are available:

* `source`
* `kafka`
* `file`
* `jmx`
Optionally, you can also implement a {link-prefix}:{link-signalling}#debezium-signaling-enabling-custom-signaling-channel[custom signaling channel].
|[[postgresql-property-notification-enabled-channels]]<<postgresql-property-notification-enabled-channels, `+notification.enabled.channels+`>>
|No default
| List of notification channel names that are enabled for the connector.
By default, the following channels are available:

* `sink`
* `log`
* `jmx`
Optionally, you can also implement a {link-prefix}:{link-notification}#debezium-notification-custom-channel[custom notification channel].
|[[postgresql-property-incremental-snapshot-chunk-size]]<<postgresql-property-incremental-snapshot-chunk-size, `+incremental.snapshot.chunk.size+`>>
|1024
|The maximum number of rows that the connector fetches and reads into memory during an incremental snapshot chunk.
Increasing the chunk size provides greater efficiency, because the snapshot runs fewer snapshot queries of a greater size.
However, larger chunk sizes also require more memory to buffer the snapshot data.
Adjust the chunk size to a value that provides the best performance in your environment.

|[[postgresql-property-incremental-snapshot-watermarking-strategy]]<<postgresql-property-incremental-snapshot-watermarking-strategy, `+incremental.snapshot.watermarking.strategy+`>>
|`insert_insert`
|Specifies the watermarking mechanism that the connector uses during an incremental snapshot to deduplicate events that might be captured by an incremental snapshot and then recaptured after streaming resumes. +
You can specify one of the following options:

`insert_insert`:: When you send a signal to initiate an incremental snapshot, for every chunk that {prodname} reads during the snapshot, it writes an entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, {prodname} inserts a second entry to record the closing of the window.
`insert_delete`:: When you send a signal to initiate an incremental snapshot, for every chunk that {prodname} reads, it writes a single entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, this entry is removed.
No entry is created for the signal to close the snapshot window.
Set this option to prevent rapid growth of the signaling data collection.

|[[postgres-property-read-only]]<<postgres-property-read-only, `+read.only+`>>
|`false`
|Specifies whether a connector writes watermarks to the signal data collection to track the progress of an incremental snapshot.
Set the value to `true` to enable a connector that has a read-only connection to the database to use an incremental snapshot watermarking strategy that does not require writing to the signal data collection.

|[[postgresql-property-xmin-fetch-interval-ms]]<<postgresql-property-xmin-fetch-interval-ms, `+xmin.fetch.interval.ms+`>>
|`0`
|How often, in milliseconds, the XMIN will be read from the replication slot.
The XMIN value provides the lower bounds of where a new replication slot could start from.
The default value of `0` disables tracking XMIN tracking.

|[[postgresql-property-topic-naming-strategy]]<<postgresql-property-topic-naming-strategy, `topic.naming.strategy`>>
|`io.debezium.schema.SchemaTopicNamingStrategy`
|The name of the TopicNamingStrategy class that should be used to determine the topic name for data change, schema change, transaction, heartbeat event etc., defaults to `SchemaTopicNamingStrategy`.

|[[postgresql-property-topic-delimiter]]<<postgresql-property-topic-delimiter, `topic.delimiter`>>
|`.`
|Specify the delimiter for topic name, defaults to `.`.

|[[postgresql-property-topic-cache-size]]<<postgresql-property-topic-cache-size, `topic.cache.size`>>
|`10000`
|The size used for holding the topic names in bounded concurrent hash map. This cache will help to determine the topic name corresponding to a given data collection.

|[[postgresql-property-topic-heartbeat-prefix]]<<postgresql-property-topic-heartbeat-prefix, `+topic.heartbeat.prefix+`>>
|`__debezium-heartbeat`
|Controls the name of the topic to which the connector sends heartbeat messages. The topic name has this pattern: +
 +
_topic.heartbeat.prefix_._topic.prefix_ +
 +
For example, if the topic prefix is `fulfillment`, the default topic name is `__debezium-heartbeat.fulfillment`.

|[[postgresql-property-topic-transaction]]<<postgresql-property-topic-transaction, `topic.transaction`>>
|`transaction`
|Controls the name of the topic to which the connector sends transaction metadata messages. The topic name has this pattern: +
 +
_topic.prefix_._topic.transaction_ +
 +
For example, if the topic prefix is `fulfillment`, the default topic name is `fulfillment.transaction`.

|[[postgresql-property-snapshot-max-threads]]<<postgresql-property-snapshot-max-threads, `snapshot.max.threads`>>
|`1`
|Specifies the number of threads that the connector uses when performing an initial snapshot.
To enable parallel initial snapshots, set the property to a value greater than 1.
In a parallel initial snapshot, the connector processes multiple tables concurrently.
This feature is incubating.

|[[postgresql-property-custom-metric-tags]]<<postgresql-property-custom-metric-tags, `custom.metric.tags`>>
|`No default`
|Defines tags that customize MBean object names by adding metadata that provides contextual information.
Specify a comma-separated list of key-value pairs.
Each key represents a tag for the MBean object name, and the corresponding value represents a value for the key, for example,  +
`k1=v1,k2=v2`

The connector appends the specified tags to the base MBean object name.
Tags can help you to organize and categorize metrics data.
You can define tags to identify particular application instances, environments, regions, versions, and so forth.
For more information, see xref:customized-mbean-names[Customized MBean names].

|[[postgresql-property-errors-max-retires]]<<postgresql-property-errors-max-retires, `errors.max.retries`>>
|`-1`
|Specifies how the connector responds after an operation that results in a retriable error, such as a connection error. +
Set one of the following options:

`-1`:: No limit. The connector always restarts automatically, and retries the operation, regardless of the number of previous failures.

`0`:: Disabled. The connector fails immediately, and never retries the operation.
User intervention is required to restart the connector.

`> 0`:: The connector restarts automatically until it reaches the specified maximum number of retries.
After the next failure, the connector stops, and user intervention is required to restart it.

|[[postgresql-property-database-query-timeout-ms]]<<postgresql-property-database-query-timeout-ms, `database.query.timeout.ms`>>
|`600000` (10 minutes)
|Specifies the time, in milliseconds, that the connector waits for a query to complete.
Set the value to `0` (zero) to remove the timeout limit.
|===

[id="postgresql-pass-through-properties"]
.Pass-through connector configuration properties
The connector also supports _pass-through_ configuration properties that are used when creating the Kafka producer and consumer.

Be sure to consult the {link-kafka-docs}.html[Kafka documentation] for all of the configuration properties for Kafka producers and consumers. The PostgreSQL connector does use the {link-kafka-docs}.html#consumerconfigs[new consumer configuration properties].

[id="debezium-{context}-connector-kafka-signals-configuration-properties"]
==== {prodname} connector Kafka signals configuration properties

:leveloffset: +1

{prodname} provides a set of `signal.*` properties that control how the connector interacts with the Kafka signals topic.

The following table describes the Kafka `signal` properties.

.Kafka signals configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-signal-kafka-topic]]<<{context}-property-signal-kafka-topic, `+signal.kafka.topic+`>>
|<topic.prefix>-signal
|The name of the Kafka topic that the connector monitors for ad hoc signals.
[NOTE]
====
If {link-prefix}:{link-topic-auto-creation}#topic-auto-create-config[automatic topic creation] is disabled, you must manually create the required signaling topic.
A signaling topic is required to preserve signal ordering.
The signaling topic must have a single partition.
====

|[[{context}-property-signal-kafka-groupId]]<<{context}-property-signal-kafka-groupId, `+signal.kafka.groupId+`>>
|kafka-signal
|The name of the group ID  that is used by Kafka consumers.

|[[{context}-property-signal-kafka-bootstrap-servers]]<<{context}-property-signal-kafka-bootstrap-servers, `+signal.kafka.bootstrap.servers+`>>
|No default
|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster.
Each pair references the Kafka cluster that is used by the {prodname} Kafka Connect process.

|[[{context}-property-signal-kafka-poll-timeout-ms]]<<{context}-property-signal-kafka-poll-timeout-ms, `+signal.kafka.poll.timeout.ms+`>>
|`100`
|An integer value that specifies the maximum number of milliseconds that the connector waits when polling signals.

|[[{context}-kafka-consumer-offset-commit-enabled]]<<{context}-kafka-consumer-offset-commit-enabled, `+kafka.consumer.offset.commit.enabled+`>>
|`false`
|Enable the offset commit for the signal topic in order to guarantee At-Least-Once delivery. If disabled, only signals received when the consumer is up&running are processed. Any signals received when the consumer is down are lost.

|===

[id="debezium-{context}-connector-pass-through-signals-kafka-consumer-configuration-properties"]
=== {prodname} connector pass-through signals Kafka consumer client configuration properties

The {prodname} connector provides for pass-through configuration of the signals Kafka consumer.
Pass-through signals properties begin with the prefix `signals.consumer.*`.
For example, the connector passes properties such as `signal.consumer.security.protocol=SSL` to the Kafka consumer.

{prodname} strips the prefixes from the properties before it passes the properties to the Kafka signals consumer.

:leveloffset: 1

[id="debezium-{context}-connector-kafka-notifications-configuration-properties"]
==== {prodname} connector sink notifications configuration properties

:leveloffset: +1

The following table describes the `notification` properties.

.Sink notification configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-notification-sink-topic-name]]<<{context}-property-notification-sink-topic-name, `+notification.sink.topic.name+`>>
|No default
|The name of the topic that receives notifications from {prodname}.
This property is required when you configure the xref:{context}-property-notification-enabled-channels[`notification.enabled.channels`] property to include `sink` as one of the enabled notification channels.
|===

:leveloffset: 1

[id="debezium-{context}-connector-pass-through-database-driver-configuration-properties"]
==== {prodname} connector pass-through database driver configuration properties

:leveloffset: +1

The {prodname} connector provides for pass-through configuration of the database driver.
Pass-through database properties begin with the prefix `driver.*`.
For example, the connector passes properties such as `driver.foobar=false` to the JDBC URL.

As is the case with the xref:{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[pass-through properties for database schema history clients], {prodname} strips the prefixes from the properties before it passes them to the database driver.

:leveloffset: 1

// Type: assembly
// ModuleID: monitoring-debezium-postgresql-connector-performance
// Title: Monitoring {prodname} PostgreSQL connector performance
[[postgresql-monitoring]]
== Monitoring

The {prodname} PostgreSQL connector provides two types of metrics that are in addition to the built-in support for JMX metrics that Zookeeper, Kafka, and Kafka Connect provide.

* xref:postgresql-snapshot-metrics[Snapshot metrics] provide information about connector operation while performing a snapshot.
* xref:postgresql-streaming-metrics[Streaming metrics] provide information about connector operation when the connector is capturing changes and streaming change event records.

{link-prefix}:{link-debezium-monitoring}#monitoring-debezium[{prodname} monitoring documentation] provides details for how to expose these metrics by using JMX.

/ Type: concept
// ModuleID: monitoring-debezium-postgresql-connectors-customized-mbean-names
// Title: Customized names for PostgreSQL connector snapshot and streaming MBean objects
=== Customized MBean names

:leveloffset: +1

{prodname} connectors expose metrics via the MBean name for the connector.
These metrics, which are specific to each connector instance, provide data about the behavior of the connector's snapshot, streaming, and schema history processes.

By default, when you deploy a correctly configured connector, {prodname} generates a unique MBean name for each of the different connector metrics.
To view the metrics for a connector process, you configure your observability stack to monitor its MBean.
But these default MBean names depend on the connector configuration; configuration changes can result in changes to the MBean names.
A change to the MBean name breaks the linkage between the connector instance and the MBean, disrupting monitoring activity.
In this scenario, you must reconfigure the observability stack to use the new MBean name if you want to resume monitoring.

To prevent monitoring disruptions that result from MBean name changes, you can configure custom metrics tags.
You configure custom metrics by adding the `custom.metric.tags` property to the connector configuration.
The property accepts key-value pairs in which each key represents a tag for the MBean object name, and the corresponding value represents the value of that tag.
For example: `k1=v1,k2=v2`.
{prodname} appends the specified tags to the MBean name of the connector.

After you configure the `custom.metric.tags` property for a connector, you can configure the observability stack to retrieve metrics associated with the specified tags.
The observability stack then uses the specified tags, rather than the mutable MBean names to uniquely identify connectors.
Later, if {prodname} redefines how it constructs MBean names, or if the `topic.prefix` in the connector configuration changes, metrics collection is uninterrupted,
because the metrics scrape task uses the specified tag patterns to identify the connector.

A further benefit of using custom tags, is that you can use tags that reflect the architecture of your data pipeline, so that metrics are organized in a way that suits you operational needs.
For example, you might specify tags with values that declare the type of connector activity, the application context, or the data source, for example, `db1-streaming-for-application-abc`.
If you specify multiple key-value pairs, all of the specified pairs are appended to the connector's MBean name.

The following example illustrates how tags modify the default MBean name.

.How custom tags modify the connector MBean name
=======
By default, the {connector-name} connector uses the following MBean name for streaming metrics:
 +
[source,subs="attributes+,quotes"]
----
debezium.{context}:type=connector-metrics,context=streaming,server=_<topic.prefix>_
----

If you set the value of `custom.metric.tags` to `database=salesdb-streaming,table=inventory`, {prodname} generates the following custom MBean name:

[source,subs="attributes+,quotes"]
----
debezium.{context}:type=connector-metrics,context=streaming,server=_<topic.prefix>_,database=salesdb-streaming,table=inventory
----
=======


:leveloffset: 1

// Type: reference
// ModuleID: monitoring-debezium-during-snapshots-of-postgresql-databases
// Title: Monitoring {prodname} during snapshots of PostgreSQL databases
[[postgresql-snapshot-metrics]]
=== Snapshot metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=snapshot,server=_<topic.prefix>_`.

:leveloffset: 1

:leveloffset: +1

Snapshot metrics are not exposed unless a snapshot operation is active, or if a snapshot has occurred since the last connector start.

The following table lists the snapshot metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-snaps-metric-lastevent_{context}]]<<connectors-snaps-metric-lastevent_{context}, `LastEvent`>>
|`string`
|The last snapshot event that the connector has read.

|[[connectors-snaps-metric-millisecondssincelastevent_{context}]]<<connectors-snaps-metric-millisecondssincelastevent_{context}, `MilliSecondsSinceLastEvent`>>
|`long`
|The number of milliseconds since the connector has read and processed the most recent event.

|[[connectors-snaps-metric-totalnumberofeventsseen_{context}]]<<connectors-snaps-metric-totalnumberofeventsseen_{context}, `TotalNumberOfEventsSeen`>>
|`long`
|The total number of events that this connector has seen since last started or reset.

|[[connectors-snaps-metric-numberofeventsfiltered_{context}]]<<connectors-snaps-metric-numberofeventsfiltered_{context}, `NumberOfEventsFiltered`>>
|`long`
| The number of events that have been filtered by include/exclude list filtering rules configured on the connector.

|[[connectors-snaps-metric-capturedtables_{context}]]<<connectors-snaps-metric-capturedtables_{context}, `CapturedTables`>>
|`string[]`
|The list of tables that are captured by the connector.

|[[connectors-snaps-metric-queuetotalcapacity_{context}]]<<connectors-snaps-metric-queuetotalcapacity_{context}, `QueueTotalCapacity`>>
|`int`
|The length the queue used to pass events between the snapshotter and the main Kafka Connect loop.

|[[connectors-snaps-metric-queueremainingcapacity_{context}]]<<connectors-snaps-metric-queueremainingcapacity_{context}, `QueueRemainingCapacity`>>
|`int`
|The free capacity of the queue used to pass events between the snapshotter and the main Kafka Connect loop.

|[[connectors-snaps-metric-totaltablecount_{context}]]<<connectors-snaps-metric-totaltablecount_{context}, `TotalTableCount`>>
|`int`
|The total number of tables that are being included in the snapshot.

|[[connectors-snaps-metric-remainingtablecount_{context}]]<<connectors-snaps-metric-remainingtablecount_{context}, `RemainingTableCount`>>
|`int`
|The number of tables that the snapshot has yet to copy.

|[[connectors-snaps-metric-snapshotrunning_{context}]]<<connectors-snaps-metric-snapshotrunning_{context}, `SnapshotRunning`>>
|`boolean`
|Whether the snapshot was started.

|[[connectors-snaps-metric-snapshotpaused_{context}]]<<connectors-snaps-metric-snapshotpaused_{context}, `SnapshotPaused`>>
|`boolean`
|Whether the snapshot was paused.

|[[connectors-snaps-metric-snapshotaborted_{context}]]<<connectors-snaps-metric-snapshotaborted_{context}, `SnapshotAborted`>>
|`boolean`
|Whether the snapshot was aborted.

|[[connectors-snaps-metric-snapshotcompleted_{context}]]<<connectors-snaps-metric-snapshotcompleted_{context}, `SnapshotCompleted`>>
|`boolean`
|Whether the snapshot completed.

|[[connectors-snaps-metric-snapshotdurationinseconds_{context}]]<<connectors-snaps-metric-snapshotdurationinseconds_{context}, `SnapshotDurationInSeconds`>>
|`long`
|The total number of seconds that the snapshot has taken so far, even if not complete. Includes also time when snapshot was paused.

|[[connectors-snaps-metric-snapshotpauseddurationinseconds_{context}]]<<connectors-snaps-metric-snapshotpauseddurationinseconds_{context}, `SnapshotPausedDurationInSeconds`>>
|`long`
|The total number of seconds that the snapshot was paused. If the snapshot was paused several times, the paused time adds up.

|[[connectors-snaps-metric-rowsscanned_{context}]]<<connectors-snaps-metric-rowsscanned_{context}, `RowsScanned`>>
|`Map<String, Long>`
|Map containing the number of rows scanned for each table in the snapshot.
Tables are incrementally added to the Map during processing.
Updates every 10,000 rows scanned and upon completing a table.

|[[connectors-snaps-metric-maxqueuesizeinbytes_{context}]]<<connectors-snaps-metric-maxqueuesizeinbytes_{context}, `MaxQueueSizeInBytes`>>
|`long`
|The maximum buffer of the queue in bytes. This metric is available if xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`] is set to a positive long value.

|[[connectors-snaps-metric-currentqueuesizeinbytes_{context}]]<<connectors-snaps-metric-currentqueuesizeinbytes_{context}, `CurrentQueueSizeInBytes`>>
|`long`
|The current volume, in bytes, of records in the queue.

|===

:leveloffset: 1

:leveloffset: +1

The connector also provides the following additional snapshot metrics when an incremental snapshot is executed:

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-insnap-metric-chunkid_{context}]]<<connectors-insnap-metric-chunkid_{context}, `ChunkId`>>
|`string`
|The identifier of the current snapshot chunk.

|[[connectors-insnap-metric-chunkfrom_{context}]]<<connectors-insnap-metric-chunkfrom_{context}, `ChunkFrom`>>
|`string`
|The lower bound of the primary key set defining the current chunk.

|[[connectors-insnap-metric-chunkto_{context}]]<<connectors-insnap-metric-chunkto_{context}, `ChunkTo`>>
|`string`
|The upper bound of the primary key set defining the current chunk.

|[[connectors-insnap-metric-tablefrom_{context}]]<<connectors-insnap-metric-tablefrom_{context}, `TableFrom`>>
|`string`
|The lower bound of the primary key set of the currently snapshotted table.

|[[connectors-insnap-metric-tableto_{context}]]<<connectors-insnap-metric-tableto_{context}, `TableTo`>>
|`string`
|The upper bound of the primary key set of the currently snapshotted table.

|===

The {prodname} {connector-name} connector also provides the `HoldingGlobalLock` custom snapshot metric.
This metric is set to a Boolean value that indicates whether the connector currently holds a global or table write lock.

:leveloffset: 1

// Type: reference
// ModuleID: monitoring-debezium-postgresql-connector-record-streaming
// Title: Monitoring {prodname} PostgreSQL connector record streaming
[[postgresql-streaming-metrics]]
=== Streaming metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=streaming,server=_<topic.prefix>_`.

:leveloffset: 1

:leveloffset: +1

The following table lists the streaming metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-strm-metric-lastevent_{context}]]<<connectors-strm-metric-lastevent_{context}, `LastEvent`>>
|`string`
|The last streaming event that the connector has read.

|[[connectors-strm-metric-millisecondssincelastevent_{context}]]<<connectors-strm-metric-millisecondssincelastevent_{context}, `MilliSecondsSinceLastEvent`>>
|`long`
|The number of milliseconds since the connector has read and processed the most recent event.

|[[connectors-strm-metric-totalnumberofeventsseen_{context}]]<<connectors-strm-metric-totalnumberofeventsseen_{context}, `TotalNumberOfEventsSeen`>>
|`long`
|The total number of data change events reported by the source database since the last connector start, or since a metrics reset.
Represents the data change workload for {prodname} to process.

|[[connectors-strm-metric-totalnumberofcreateeventsseen_{context}]]<<connectors-strm-metric-totalnumberofcreateeventsseen_{context}, `TotalNumberOfCreateEventsSeen`>>
|`long`
|The total number of create events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-totalnumberofupdateeventsseen_{context}]]<<connectors-strm-metric-totalnumberofupdateeventsseen_{context}, `TotalNumberOfUpdateEventsSeen`>>
|`long`
|The total number of update events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-totalnumberofdeleteeventsseen_{context}]]<<connectors-strm-metric-totalnumberofdeleteeventsseen_{context}, `TotalNumberOfDeleteEventsSeen`>>
|`long`
|The total number of delete events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-numberofeventsfiltered_{context}]]<<connectors-strm-metric-numberofeventsfiltered_{context}, `NumberOfEventsFiltered`>>
|`long`
|The number of events that have been filtered by include/exclude list filtering rules configured on the connector.

|[[connectors-strm-metric-capturedtables_{context}]]<<connectors-strm-metric-capturedtables_{context}, `CapturedTables`>>
|`string[]`
|The list of tables that are captured by the connector.

|[[connectors-strm-metric-queuetotalcapacity_{context}]]<<connectors-strm-metric-queuetotalcapacity_{context}, `QueueTotalCapacity`>>
|`int`
|The length the queue used to pass events between the streamer and the main Kafka Connect loop.

|[[connectors-strm-metric-queueremainingcapacity_{context}]]<<connectors-strm-metric-queueremainingcapacity_{context}, `QueueRemainingCapacity`>>
|`int`
|The free capacity of the queue used to pass events between the streamer and the main Kafka Connect loop.

|[[connectors-strm-metric-connected_{context}]]<<connectors-strm-metric-connected_{context}, `Connected`>>
|`boolean`
|Flag that denotes whether the connector is currently connected to the database server.

|[[connectors-strm-metric-millisecondsbehindsource_{context}]]<<connectors-strm-metric-millisecondsbehindsource_{context}, `MilliSecondsBehindSource`>>
|`long`
|The number of milliseconds between the last change event's timestamp and the connector processing it.
The values will incorporate any differences between the clocks on the machines where the database server and the connector are running.

|[[connectors-strm-metric-numberofcommittedtransactions_{context}]]<<connectors-strm-metric-numberofcommittedtransactions_{context}, `NumberOfCommittedTransactions`>>
|`long`
|The number of processed transactions that were committed.

|[[connectors-strm-metric-sourceeventposition_{context}]]<<connectors-strm-metric-sourceeventposition_{context}, `SourceEventPosition`>>
|`Map<String, String>`
|The coordinates of the last received event.

|[[connectors-strm-metric-lasttransactionid_{context}]]<<connectors-strm-metric-lasttransactionid_{context}, `LastTransactionId`>>
|`string`
|Transaction identifier of the last processed transaction.

|[[connectors-strm-metric-maxqueuesizeinbytes_{context}]]<<connectors-strm-metric-maxqueuesizeinbytes_{context}, `MaxQueueSizeInBytes`>>
|`long`
|The maximum buffer of the queue in bytes. This metric is available if xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`] is set to a positive long value.

|[[connectors-strm-metric-currentqueuesizeinbytes_{context}]]<<connectors-strm-metric-currentqueuesizeinbytes_{context}, `CurrentQueueSizeInBytes`>>
|`long`
|The current volume, in bytes, of records in the queue.

|===

The {prodname} {connector-name} connector also provides the following additional streaming metrics:

.Descriptions of additional {connector-name} streaming metrics
[cols="3,2,5",options="header"]
|===
|Attribute |Type |Description

|[[binlog-filename]]<<binlog-filename,`+BinlogFilename+`>>
|`string`
|The name of the binlog file that the connector has most recently read.

|[[binlog-position]]<<binlog-position,`+BinlogPosition+`>>
|`long`
|The most recent position (in bytes) within the binlog that the connector has read.

|[[is-gtid-mode-enabled]]<<is-gtid-mode-enabled,`+IsGtidModeEnabled+`>>
|`boolean`
|Flag that denotes whether the connector is currently tracking GTIDs from {connector-name} server.

|[[gtid-set]]<<gtid-set,`+GtidSet+`>>
|`string`
|The string representation of the most recent GTID set processed by the connector when reading the binlog.

|[[number-of-skipped-events]]<<number-of-skipped-events,`+NumberOfSkippedEvents+`>>
|`long`
|The number of events that have been skipped by the {connector-name} connector. Typically events are skipped due to a malformed or unparseable event from {connector-name}'s binlog.

|[[number-of-disconnects]]<<number-of-disconnects,`+NumberOfDisconnects+`>>
|`long`
|The number of disconnects by the {connector-name} connector.

|[[number-of-rolled-back-transactions]]<<number-of-rolled-back-transactions,`+NumberOfRolledBackTransactions+`>>
|`long`
|The number of processed transactions that were rolled back and not streamed.

|[[number-of-not-well-formed-transactions]]<<number-of-not-well-formed-transactions,`+NumberOfNotWellFormedTransactions+`>>
|`long`
|The number of transactions that have not conformed to the expected protocol of `BEGIN` + `COMMIT`/`ROLLBACK`. This value should be `0` under normal conditions.

|[[number-of-large-transactions]]<<number-of-large-transactions,`+NumberOfLargeTransactions+`>>
|`long`
|The number of transactions that have not fit into the look-ahead buffer. For optimal performance, this value should be significantly smaller than `NumberOfCommittedTransactions` and `NumberOfRolledBackTransactions`.

|===

:leveloffset: 1



// Type: reference
// ModuleID: how-debezium-postgresql-connectors-handle-faults-and-problems
// Title: How {prodname} PostgreSQL connectors handle faults and problems
[[postgresql-when-things-go-wrong]]
== Behavior when things go wrong

{prodname} is a distributed system that captures all changes in multiple upstream databases; it never misses or loses an event.
When the system is operating normally or being managed carefully then {prodname} provides _exactly once_ delivery of every change event record.
If a fault does happen then the system does not lose any events.
However, while it is recovering from the fault, it's possible that the connector might emit some duplicate change events.
In these abnormal situations, {prodname}, like Kafka, provides _at least once_ delivery of change events.

The rest of this section describes how {prodname} handles various kinds of faults and problems.


[id="postgresql-connector-configuration-and-startup-errors"]
=== Configuration and startup errors

In the following situations, the connector fails when trying to start, reports an error/exception in the log, and stops running:

* The connector's configuration is invalid.
* The connector cannot successfully connect to PostgreSQL by using the specified connection parameters.
* The connector is restarting from a previously-recorded position in the PostgreSQL WAL (by using the LSN) and PostgreSQL no longer has that history available.

In these cases, the error message has details about the problem and possibly a suggested workaround. After you correct the configuration or address the PostgreSQL problem, restart the connector.

[id="postgresql-becomes-unavailable"]
=== PostgreSQL becomes unavailable

When the connector is running, the PostgreSQL server that it is connected to could become unavailable for any number of reasons. If this happens, the connector fails with an error and stops. When the server is available again, restart the connector.

The PostgreSQL connector externally stores the last processed offset in the form of a PostgreSQL LSN. After a connector restarts and connects to a server instance, the connector communicates with the server to continue streaming from that particular offset. This offset is available as long as the {prodname} replication slot remains intact.  Never drop a replication slot on the primary server or you will lose data.
For information about failure cases in which a slot has been removed, see the next section.

[id="postgresql-cluster-failures"]
=== Cluster failures

As of release 12, PostgreSQL allows logical replication slots _only on primary servers_. This means that you can point a {prodname} PostgreSQL connector to only the active primary server of a database cluster.
Also, replication slots themselves are not propagated to replicas.
If the primary server goes down, a new primary must be promoted.

[NOTE]
====
Some managed PostgresSQL services (AWS RDS and GCP CloudSQL for example) implement replication to a standby via disk replication. This means that the replication slot does get replicated and will remain available after a failover.
====

The new primary must have the xref:installing-postgresql-output-plugin[logical decoding plug-in] installed and a replication slot that is configured for use by the plug-in and the database for which you want to capture changes. Only then can you point the connector to the new server and restart the connector.


There are important caveats when failovers occur and you should pause {prodname} until you can verify that you have an intact replication slot that has not lost data. After a failover:

* There must be a process that re-creates the {prodname} replication slot before allowing the application to write to the *new* primary. This is crucial. Without this process, your application can miss change events.

* You might need to verify that {prodname} was able to read all changes in the slot **before the old primary failed**.

One reliable method of recovering and verifying whether any changes were lost is to recover a backup of the failed primary to the point immediately before it failed. While this can be administratively difficult, it allows you to inspect the replication slot for any unconsumed changes.


[NOTE]
====
There are discussions in the PostgreSQL community around a feature called `failover slots` that would help mitigate this problem, but as of PostgreSQL 12, they have not been implemented.  However, there is active development for PostgreSQL 13 to support logical decoding on standbys, which is a major requirement to make failover possible. You can find more about this in this link:https://www.postgresql.org/message-id/CAJ3gD9fE%3D0w50sRagcs%2BjrktBXuJAWGZQdSTMa57CCY%2BDh-xbg%40mail.gmail.com[community thread].

More about the concept of failover slots is in link:http://blog.2ndquadrant.com/failover-slots-postgresql[this blog post].
====

[id="postgresql-kafka-connect-process-stops-gracefully"]
=== Kafka Connect process stops gracefully

Suppose that Kafka Connect is being run in distributed mode and a Kafka Connect process is stopped gracefully. Prior to shutting down that process, Kafka Connect migrates the process's connector tasks to another Kafka Connect process in that group. The new connector tasks start processing exactly where the prior tasks stopped. There is a short delay in processing while the connector tasks are stopped gracefully and restarted on the new processes.

[id="postgresql-kafka-connect-process-crashes"]
=== Kafka Connect process crashes

If the Kafka Connector process stops unexpectedly, any connector tasks it was running terminate without recording their most recently processed offsets. When Kafka Connect is being run in distributed mode, Kafka Connect restarts those connector tasks on other processes. However, PostgreSQL connectors resume from the last offset that was _recorded_ by the earlier processes. This means that the new replacement tasks might generate some of the same change events that were processed just prior to the crash. The number of duplicate events depends on the offset flush period and the volume of data changes just before the crash.

Because there is a chance that some events might be duplicated during a recovery from failure, consumers should always anticipate some duplicate events. {prodname} changes are idempotent, so a sequence of events always results in the same state.

In each change event record, {prodname} connectors insert source-specific information about the origin of the event, including the PostgreSQL server's time of the event, the ID of the server transaction, and the position in the write-ahead log where the transaction changes were written. Consumers can keep track of this information, especially the LSN, to determine whether an event is a duplicate.

[id="postgresql-kafka-becomes-unavailable"]
=== Kafka becomes unavailable

As the connector generates change events, the Kafka Connect framework records those events in Kafka by using the Kafka producer API. Periodically, at a frequency that you specify in the Kafka Connect configuration, Kafka Connect records the latest offset that appears in those change events. If the Kafka brokers become unavailable, the Kafka Connect process that is running the connectors repeatedly tries to reconnect to the Kafka brokers. In other words, the connector tasks pause until a connection can be re-established, at which point the connectors resume exactly where they left off.

[id="postgresql-connector-is-stopped-for-a-duration"]
=== Connector is stopped for a duration

If the connector is gracefully stopped, the database can continue to be used. Any changes are recorded in the PostgreSQL WAL. When the connector restarts, it resumes streaming changes where it left off. That is, it generates change event records for all database changes that were made while the connector was stopped.

A properly configured Kafka cluster is able to handle massive throughput. Kafka Connect is written according to Kafka best practices, and given enough resources a Kafka Connect connector can also handle very large numbers of database change events. Because of this, after being stopped for a while, when a {prodname} connector restarts, it is very likely to catch up with the database changes that were made while it was stopped. How quickly this happens depends on the capabilities and performance of Kafka and the volume of changes being made to the data in PostgreSQL.

:leveloffset!:
:leveloffset: +1

// Category: debezium-using
// Type: assembly
[id="debezium-connector-for-mongodb"]
= {prodname} connector for MongoDB

:context: mongodb
:data-collection: collection
:mbean-name: {context}
:connector-file: {context}
:connector-class: MongoDb
:connector-name: MongoDB
:include-list-example: public.inventory

:toc:
:toc-placement: macro
:linkattrs:
:icons: font
:source-highlighter: highlight.js

toc::[]

{prodname}'s MongoDB connector tracks a MongoDB replica set or a MongoDB sharded cluster for document changes in databases and collections, recording those changes as events in Kafka topics.
The connector automatically handles the addition or removal of shards in a sharded cluster, changes in membership of each replica set, elections within each replica set, and awaiting the resolution of communications problems.

For information about the MongoDB versions that are compatible with this connector, see the link:https://debezium.io/releases/[{prodname} release overview].


// Type: concept
// Title: Overview of {prodname} MongoDB connector
// ModuleID: overview-of-debezium-mongodb-connector
[[mongodb-overview]]
== Overview

MongoDB's replication mechanism provides redundancy and high availability, and is the preferred way to run MongoDB in production.
MongoDB connector captures the changes in a replica set or sharded cluster.

A MongoDB _replica set_ consists of a set of servers that all have copies of the same data, and replication ensures that all changes made by clients to documents on the replica set's _primary_ are correctly applied to the other replica set's servers, called _secondaries_.
MongoDB replication works by having the primary record the changes in its _oplog_ (or operation log), and then each of the secondaries reads the primary's oplog and applies in order all of the operations to their own documents.
When a new server is added to a replica set, that server first performs an https://docs.mongodb.com/manual/core/replica-set-sync/[snapshot] of all of the databases and collections on the primary, and then reads the primary's oplog to apply all changes that might have been made since it began the snapshot.
This new server becomes a secondary (and able to handle queries) when it catches up to the tail of the primary's oplog.

// Type: concept
// Title: Description of how the MongoDB connector uses change streams to capture event records
// ModuleID: description-of-how-the-mongodb-connector-uses-change-streams-to-capture-event-records
[id="change-streams"]
=== Change streams

Although the {prodname} MongoDB connector does not become part of a replica set, it uses a similar replication mechanism to obtain oplog data.
The main difference is that the connector does not read the oplog directly.
Instead, it delegates the capture and decoding of oplog data to the MongoDB https://docs.mongodb.com/manual/changeStreams/[change streams] feature.
With change streams, the MongoDB server exposes the changes that occur in a collection as an event stream.
The {prodname} connector monitors the stream and then delivers the changes downstream.
The first time that the connector detects a replica set, it examines the oplog to obtain the last recorded transaction, and then performs a snapshot of the primary's databases and collections.
After the connector finishes copying the data, it creates a change stream beginning from the oplog position that it read earlier.

As the MongoDB connector processes changes, it periodically records the position at which the event originated in the oplog stream.
When the connector stops, it records the last oplog stream position that it processed, so that after a restart it can resume streaming from that position.
In other words, the connector can be stopped, upgraded or maintained, and restarted some time later, and always pick up exactly where it left off without losing a single event.
Of course, MongoDB oplogs are usually capped at a maximum size, so if the connector is stopped for long periods, operations in the oplog might be purged before the connector has a chance to read them.
In this case, after a restart the connector detects the missing oplog operations, performs a snapshot, and then proceeds to stream changes.

The MongoDB connector is also quite tolerant of changes in membership and leadership of the replica sets, of additions or removals of shards within a sharded cluster, and network problems that might cause communication failures.
The connector always uses the replica set's primary node to stream changes, so when the replica set undergoes an election and a different node becomes primary, the connector will immediately stop streaming changes, connect to the new primary, and start streaming changes using the new primary node.
Similarly, if connector is unable to communicate with the replica set primary, it attempts to reconnect (using exponential backoff so as to not overwhelm the network or replica set).
After connection is reestablished, the connector continues to stream changes from the last event that it captured.
In this way the connector dynamically adjusts to changes in replica set membership, and automatically handles communication disruptions.

.Additional resources

* link:https://docs.mongodb.com/manual/replication/[Replication mechanism]
* link:https://docs.mongodb.com/manual/tutorial/deploy-replica-set/[Replica set]
* link:https://docs.mongodb.com/manual/core/replica-set-elections/[Replica set elections]
* link:https://docs.mongodb.com/manual/core/sharded-cluster-components/[Sharded cluster]
* link:https://docs.mongodb.com/manual/tutorial/add-shards-to-shard-cluster/[Shard addition]
* link:https://docs.mongodb.com/manual/tutorial/remove-shards-from-cluster/[Shard removal]
* link:https://docs.mongodb.com/manual/changeStreams/[Change Streams]

// Type: concept
// Title: Description of how the MongoDB connector uses the MongoDB read preference
// ModuleID: description-of-how-the-mongodb-connector-uses-the-mongodb-read-preference
[id="read-preference"]
=== Read Preference

You specify read preferences for a MongoDB connection by setting the `readPreference` parameter in the xref:mongodb-property-mongodb-connection-string[`mongodb.connection.string`].

// Type: assembly
// ModuleID: how-debezium-mongodb-connectors-work
// Title: How {prodname} MongoDB connectors work
[[how-the-mongodb-connector-works]]
== How the MongoDB connector works

An overview of the MongoDB topologies that the connector supports is useful for planning your application.


// Type: concept
// ModuleID: mongodb-topologies-supported-by-debezium-connectors
// Title: MongoDB topologies supported by {prodname} connectors
[[supported-mongodb-topologies]]
=== Supported MongoDB topologies

The MongoDB connector supports the following MongoDB topologies:

[[mongodb-replicaset]]
MongoDB replica set::
The {prodname} MongoDB connector can capture changes from a single https://docs.mongodb.com/manual/replication/[MongoDB replica set].
Production replica sets require a minimum of https://docs.mongodb.com/manual/core/replica-set-architecture-three-members/[at least three members].
+
To use the MongoDB connector with a replica set, you must set the value of the `mongodb.connection.string` property in the connector configuration to the https://www.mongodb.com/docs/manual/reference/connection-string/[replica set connection string].
When the connector is ready to begin capturing changes from a MongoDB change stream, it starts a connection task.
The connection task then uses the specified connection string to establish a connection to an available replica set member.

[[mongodb-sharded-cluster]]
MongoDB sharded cluster::
A https://docs.mongodb.com/manual/sharding/[MongoDB sharded cluster] consists of:
* One or more _shards_, each deployed as a replica set;
* A separate replica set that acts as the cluster's _configuration server_
* One or more _routers_ (also called `mongos`) to which clients connect and that routes requests to the appropriate shards
+
To use the MongoDB connector with a sharded cluster, in the connector configuration, set the value of the `mongodb.connection.string` property to the  https://www.mongodb.com/docs/manual/reference/connection-string/[sharded cluster connection string].

[[mongodb-standalone-server]]
MongoDB standalone server::
The MongoDB connector is not capable of monitoring the changes of a standalone MongoDB server, since standalone servers do not have an oplog.
The connector will work if the standalone server is converted to a replica set with one member.

[NOTE]
====
MongoDB does not recommend running a standalone server in production.
For more information, see the https://docs.mongodb.com/manual/core/replica-set-architectures/[MongoDB documentation].
====

// Type: concept
// ModuleID: mongodb-user-permissions-required-by-debezium-connectors
// Title: User permissions required by {prodname} connectors
[[required-user-permissions]]
=== Required user permissions

To capture data from MongoDB, {prodname} attaches to the database as a MongoDB user.
The MongoDB user account that you create for {prodname} requires specific database permissions to read from the database.
The connector user requires the following permissions:

* Read from the database.
* Run the `hello` command.

The connector user might also require the following permission:

* Read from the `config.shards` system collection.

.Database read permissions
The connector user must be able to read from all databases, or to read from a specific database, depending on the value of the connector's xref:mongodb-property-capture-scope[`capture.scope`] property.
Assign one of the following permissions to the user, depending on the `capture.scope` setting:

`capture.scope` is set to `deployment`::
Grant the user permission to read any database.

`capture.scope` is set to `database`::
Grant the user permission to read the database specified by the connector's xref:mongodb-property-capture-target[`capture.target`] property.

`capture.scope` is set to `collection`::
Grant the user permission to read the collection specified by the connector's xref:mongodb-property-capture-target[`capture.target`] property.


.Permission to use the MongoDB `hello` command

Regardless of the `capture.scope` setting, the user requires permission to run the MongoDB https://www.mongodb.com/docs/manual/reference/command/hello/[hello] command.

.Permission to read the `config.shards` collection
Depending on your {prodname} environment, to enable the connector to perform offset consolidation, you must grant the connector user explicit permission to read the `config.shards` collection.
Permission to read the `config.shards` collection is required for the following connector environments:

* Connectors upgraded from {prodname} 2.5 or earlier.
* Connectors configured to capture changes from a sharded MongoDB cluster.



// Type: concept
// Title: How {prodname} MongoDB connectors use logical names for replica sets and sharded clusters
// ModuleID: how-debezium-mongodb-connectors-use-logical-names-for-replica-sets-and-sharded-clusters
[[mongodb-logical-connector-name]]
=== Logical connector name

The connector configuration property `topic.prefix` serves as a _logical name_ for the MongoDB replica set or sharded cluster.
The connector uses the logical name in a number of ways: as the prefix for all topic names, and as a unique identifier when recording the change stream position of each replica set.

You should give each MongoDB connector a unique logical name that meaningfully describes the source MongoDB system.
We recommend logical names begin with an alphabetic or underscore character, and remaining characters that are alphanumeric or underscore.

// Type: concept
// Title: How {prodname} MongoDB connectors perform offset consolidation
// ModuleID: how-debezium-mongodb-connectors-perform-offset-consolidation
[[mongodb-offset-consolidation]]
=== Offset consolidation

The {prodname} MongoDB connector no longer supports `replica_set` connections to sharded MongoDB deployments.
As a result, the offsets recorded by connector versions that used the `replica_set` connection mode are incompatible with the current version.

To minimize the affects of the connection mode change, and to prevent the connector from running unnecessary snapshots, when the connector restarts after the upgrade, it runs a procedure to consolidate offsets.
During this offset consolidation procedure, the connector completes the following steps to reconcile offsets that were recorded by the earlier connector version:

1. Offsets that were recorded by connector versions later than 2.5 are used as-is.
2. Offsets for events that were captured in `sharded` connection mode from sharded MongoDB deployments, or from MongoDB replica set deployments, are used as-is.
3. Shard-specific offsets that were recorded by connector versions 2.5.x and earlier are used as-is, if both of the following conditions apply:

* The offsets exist for all current database shards.
* xref:mongodb-property-allow-offset-invalidation[Offset invalidation] is enabled. +
If offset invalidation is disabled, the connector fails to start.


4. After the connector processes existing offsets in the preceding steps, it resumes streaming changes, and then commits offsets for new events that it captures. +
If the offset consolidation procedure does not detect any existing offsets, the connector xref:mongodb-performing-a-snapshot[performs an initial snapshot].


// Type: concept
// Title: How {prodname} MongoDB connectors perform snapshots
// ModuleID: how-debezium-mongodb-connectors-perform-snapshots
[[mongodb-performing-a-snapshot]]
=== Performing a snapshot

When a {prodname} task starts to use a replica set, it uses the connector's logical name and the replica set name to find an _offset_ that describes the position where the connector previously stopped reading changes.
If an offset can be found and it still exists in the oplog, then the task immediately proceeds with xref:mongodb-streaming-changes[streaming changes], starting at the recorded offset position.

However, if no offset is found, or if the oplog no longer contains that position, the task must first obtain the current state of the replica set contents by performing a _snapshot_.
This process starts by recording the current position of the oplog and recording that as the offset (along with a flag that denotes a snapshot has been started).
The task then proceeds to copy each collection, spawning as many threads as possible (up to the value of the `snapshot.max.threads` configuration property) to perform this work in parallel.
The connector records a separate _read event_ for each document it sees.
Each read event contains the object's identifier, the complete state of the object, and _source_ information about the MongoDB replica set where the object was found.
The source information also includes a flag that denotes that the event was produced during a snapshot.

This snapshot will continue until it has copied all collections that match the connector's filters.
If the connector is stopped before the tasks' snapshots are completed, upon restart the connector begins the snapshot again.

[NOTE]
====
Try to avoid task reassignment and reconfiguration while the connector performs snapshots of any replica sets.
The connector generates log messages to report on the progress of the snapshot.
To provide for the greatest control, run a separate Kafka Connect cluster for each connector.
====


[id="mongodb-connector-snapshot-mode-options"]
.Settings for `snapshot.mode` connector configuration property
[cols="30%a,70%a",options="header"]
|===
|Setting |Description

|`always`
|The connector performs a snapshot every time that it starts.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

|`initial`
|After the connector starts, it performs an initial database snapshot.
//as described in the xref:default-workflow-for-performing-an-initial-snapshot[default workflow for creating an initial snapshot].
|`initial_only`
|The connector performs a database snapshot.
After the snapshot completes, the connector stops, and does not stream event records for subsequent database changes.

|`never`
|Deprecated, see `no_data`.

|`no_data`
|The connector captures the structure of all relevant tables,
//performing all the steps described in the xref:default-workflow-for-performing-an-initial-snapshot[default snapshot workflow],
but it does not create `READ` events to represent the data set at the point of the connector's start-up.
//(Step 7.b).

|`when_needed`
|After the connector starts, it performs a snapshot only if it detects one of the following circumstances:

* It cannot detect any topic offsets.
* A previously recorded offset specifies a log position that is not available on the server.

|`configuration_based`
|Set the snapshot mode to `configuration_based` to control snapshot behavior through the set of connector properties that have the prefix 'snapshot.mode.configuration.based'.

|`custom`
|The `custom` snapshot mode lets you inject your own implementation of the `io.debezium.spi.snapshot.Snapshotter` interface.
Set the `snapshot.mode.custom.name` configuration property to the name provided by the `name()` method of your implementation.
The name is specified on the classpath of your Kafka Connect cluster.
If you use the {prodname} `EmbeddedEngine`, the name is included in the connector JAR file.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|===

For more information, see xref:mongodb-property-snapshot-mode[`snapshot.mode`] in the table of connector configuration properties.

// Type: concept
// ModuleID: debezium-mongodb-ad-hoc-snapshots
[id="mongodb-ad-hoc-snapshots"]
=== Ad hoc snapshots

:leveloffset: +3

By default, a connector runs an initial snapshot operation only after it starts for the first time.
Following this initial snapshot, under normal circumstances, the connector does not repeat the snapshot process.
Any future change event data that the connector captures comes in through the streaming process only.

However, in some situations the data that the connector obtained during the initial snapshot might become stale, lost, or incomplete.
To provide a mechanism for recapturing {data-collection} data, {prodname} includes an option to perform ad hoc snapshots.
You might want to perform an ad hoc snapshot after any of the following changes occur in your {prodname} environment:

* The connector configuration is modified to capture a different set of {data-collection}s.
* Kafka topics are deleted and must be rebuilt.
* Data corruption occurs due to a configuration error or some other problem.

You can re-run a snapshot for a {data-collection} for which you previously captured a snapshot by initiating a so-called _ad-hoc snapshot_.
Ad hoc snapshots require the use of {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[signaling {data-collection}s].
You initiate an ad hoc snapshot by sending a signal request to the {prodname} signaling {data-collection}.

When you initiate an ad hoc snapshot of an existing {data-collection}, the connector appends content to the topic that already exists for the {data-collection}.
If a previously existing topic was removed, {prodname} can create a topic automatically if {link-prefix}:{link-topic-auto-creation}#customizing-debezium-automatically-created-topics[automatic topic creation] is enabled.

Ad hoc snapshot signals specify the {data-collection}s to include in the snapshot.
The snapshot can capture the entire contents of the database, or capture only a subset of the {data-collection}s in the database.

You specify the {data-collection}s to capture by sending an `execute-snapshot` message to the signaling {data-collection}.
Set the type of the `execute-snapshot` signal to `incremental` or `blocking`, and provide the names of the {data-collection}s to include in the snapshot, as described in the following table:


.Example of an ad hoc `execute-snapshot` signal record
[cols="2,2,6a",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| Specifies the type of snapshot that you want to run. +
Currently, you can request `incremental` or `blocking` snapshots.


|`data-collections`
|_N/A_
| An array that contains regular expressions matching the fully-qualified names of the {data-collection} to be snapshotted. +
The format of the names is the same as for the `signal.data.collection` configuration option.



|===

.Triggering an ad hoc incremental snapshot

You initiate an ad hoc incremental snapshot by adding an entry with the `execute-snapshot` signal type to the signaling {data-collection}.
After the connector processes the message, it begins the snapshot operation.
The snapshot process reads the first and last primary key values and uses those values as the start and end point for each {data-collection}.
Based on the number of entries in the {data-collection}, and the configured chunk size, {prodname} divides the {data-collection} into chunks, and proceeds to snapshot each chunk, in succession, one at a time.

For more information, see xref:debezium-{context}-incremental-snapshots[Incremental snapshots].

.Triggering an ad hoc blocking snapshot

You initiate an ad hoc blocking snapshot by adding an entry with the `execute-snapshot` signal type to the signaling {data-collection}.
After the connector processes the message, it begins the snapshot operation.
The connector temporarily stops streaming, and then initiates a snapshot of the specified {data-collection}, following the same process that it uses during an initial snapshot.
After the snapshot completes, the connector resumes streaming.

For more information, see xref:{context}-blocking-snapshots[Blocking snapshots].

:leveloffset: 1

// Type: assembly
// ModuleID: debezium-mongodb-incremental-snapshots
[id="debezium-mongodb-incremental-snapshots"]
=== Incremental snapshots

:leveloffset: +3

To provide flexibility in managing snapshots, {prodname} includes a supplementary snapshot mechanism, known as _incremental snapshotting_.
Incremental snapshots rely on the {prodname} mechanism for {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[sending signals to a {prodname} connector].
Incremental snapshots are based on the link:https://github.com/debezium/debezium-design-documents/blob/main/DDD-3.md[DDD-3] design document.

In an incremental snapshot, instead of capturing the full state of a database all at once, as in an initial snapshot, {prodname} captures each {data-collection} in phases, in a series of configurable chunks.
You can specify the {data-collection}s that you want the snapshot to capture and the xref:{context}-property-incremental-snapshot-chunk-size[size of each chunk].
The chunk size determines the number of rows that the snapshot collects during each fetch operation on the database.
The default chunk size for incremental snapshots is 1024 rows.

As an incremental snapshot proceeds, {prodname} uses watermarks to track its progress, maintaining a record of each {data-collection} row that it captures.
This phased approach to capturing data provides the following advantages over the standard initial snapshot process:

* You can run incremental snapshots in parallel with streamed data capture, instead of postponing streaming until the snapshot completes.
  The connector continues to capture near real-time events from the change log throughout the snapshot process, and neither operation blocks the other.
* If the progress of an incremental snapshot is interrupted, you can resume it without losing any data.
  After the process resumes, the snapshot begins at the point where it stopped, rather than recapturing the {data-collection} from the beginning.
* You can run an incremental snapshot on demand at any time, and repeat the process as needed to adapt to database updates.
  For example, you might re-run a snapshot after you modify the connector configuration to add a {data-collection} to its xref:{context}-property-{data-collection}-include-list[`{data-collection}.include.list`] property.

.Incremental snapshot process
When you run an incremental snapshot, {prodname} sorts each {data-collection} by primary key and then splits the {data-collection} into chunks based on the xref:{context}-property-incremental-snapshot-chunk-size[configured chunk size].
Working chunk by chunk, it then captures each {data-collection} row in a chunk.
For each row that it captures, the snapshot emits a `READ` event.
That event represents the value of the row when the snapshot for the chunk began.

As a snapshot proceeds, it’s likely that other processes continue to access the database, potentially modifying {data-collection} records.
To reflect such changes, `INSERT`, `UPDATE`, or `DELETE` operations are committed to the transaction log as per usual.
Similarly, the ongoing {prodname} streaming process continues to detect these change events and emits corresponding change event records to Kafka.

.How {prodname} resolves collisions among records with the same primary key
In some cases, the `UPDATE` or `DELETE` events that the streaming process emits are received out of sequence.
That is, the streaming process might emit an event that modifies a {data-collection} row before the snapshot captures the chunk that contains the `READ` event for that row.
When the snapshot eventually emits the corresponding `READ` event for the row, its value is already superseded.
To ensure that incremental snapshot events that arrive out of sequence are processed in the correct logical order, {prodname} employs a buffering scheme for resolving collisions.
Only after collisions between the snapshot events and the streamed events are resolved does {prodname} emit an event record to Kafka.

.Snapshot window
To assist in resolving collisions between late-arriving `READ` events and streamed events that modify the same {data-collection} row, {prodname} employs a so-called _snapshot window_.
The snapshot windows demarcates the interval during which an incremental snapshot captures data for a specified {data-collection} chunk.
Before the snapshot window for a chunk opens, {prodname} follows its usual behavior and emits events from the transaction log directly downstream to the target Kafka topic.
But from the moment that the snapshot for a particular chunk opens, until it closes, {prodname} performs a de-duplication step to resolve collisions between events that have the same primary key..

For each data collection, the {prodname} emits two types of events, and stores the records for them both in a single destination Kafka topic.
The snapshot records that it  captures directly from a table are emitted as `READ` operations.
Meanwhile, as users continue to update records in the data collection, and the transaction log is updated to reflect each commit, {prodname} emits `UPDATE` or `DELETE` operations for each change.

As the snapshot window opens, and {prodname} begins processing a snapshot chunk, it delivers snapshot records to a memory buffer.
During the snapshot windows, the primary keys of the `READ` events in the buffer are compared to the primary keys of the incoming streamed events.
If no match is found, the streamed event record is sent directly to Kafka.
If {prodname} detects a match, it discards the buffered `READ` event, and writes the streamed record to the destination topic, because the streamed event logically supersede the static snapshot event.
After the snapshot window for the chunk closes, the buffer contains only `READ` events for which no related transaction log events exist.
{prodname} emits these remaining `READ` events to the {data-collection}'s Kafka topic.

The connector repeats the process for each snapshot chunk.

:leveloffset: 1

[WARNING]
====
Incremental snapshots require that the primary key for each table is stably ordered.
Because `String` fields can include special characters, and are subject to different encodings, string-based primary keys do not lend themselves to sorting in a consistent and predictable order.
When performing incremental snapshots, it's best to set the primary key to a data type other than `String`.

For more information about BSON string types in MongoDB, see the https://www.mongodb.com/docs/manual/reference/bson-types/#string/[MongoDB documentation]).
====

.Incremental snapshots for sharded clusters

To use incremental snapshots with sharded MongoDB clusters, you must set xref:mongodb-property-incremental-snapshot-chunk-size[`incremental.snapshot.chunk.size`] to a value that is high enough to compensate for the link:https://www.mongodb.com/docs/manual/administration/change-streams-production-recommendations/#sharded-clusters[increased complexity] of change stream pipelines.

// Type: procedure
// ModuleID: debezium-mongodb-triggering-an-incremental-snapshot
[id="mongodb-triggering-an-incremental-snapshot"]
==== Triggering an incremental snapshot

:leveloffset: +1

Currently, the only way to initiate an incremental snapshot is to send an {link-prefix}:{link-signalling}#debezium-signaling-ad-hoc-snapshots[ad hoc snapshot signal] to the signaling {data-collection} on the source database.

You submit a signal to the signaling {data-collection} by using the MongoDB `insert()` method.

After {prodname} detects the change in the signaling {data-collection}, it reads the signal, and runs the requested snapshot operation.

The query that you submit specifies the {data-collection}s to include in the snapshot, and, optionally, specifies the type of snapshot operation.
Currently, the only valid options for snapshots operations are `incremental` and `blocking`.

To specify the {data-collection}s to include in the snapshot, provide a `data-collections` array that lists the {data-collection}s or an array of regular expressions used to match {data-collection}s, for example, +
`{"data-collections": ["public.Collection1", "public.Collection2"]}` +

The `data-collections` array for an incremental snapshot signal has no default value.
If the `data-collections` array is empty, {prodname} detects that no action is required and does not perform a snapshot.

[NOTE]
====
If the name of a {data-collection} that you want to include in a snapshot contains a dot (`.`) in the name of the database, schema, or table, to add the {data-collection} to the `data-collections` array, you must escape each part of the name in double quotes. +
 +
For example, to include a data collection that exists in the `*public*` database, and that has the name `*My.Collection*`, use the following format: `*"public"."My.Collection"*`.
====

.Prerequisites

* {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[Signaling is enabled]. +
** A signaling data collection exists on the source database.
** The signaling data collection is specified in the xref:{context}-property-signal-data-collection[`signal.data.collection`] property.

.Using a source signaling channel to trigger an incremental snapshot

. Insert a snapshot signal document into the signaling {data-collection}:
+
[source,bash,indent=0,subs="+attributes,+quotes"]
----
_<signalDataCollection>_.insert({"_id" : _<idNumber>_,"type" : _<snapshotType>_, "data" : {"data-collections" ["_<collectionName>_", "_<collectionName>_"],"type": _<snapshotType>_, "additional-conditions" : [{"data-collections" : "_<collectionName>_", "filter" : "_<additional-condition>_"}] }});
----
+
For example,
+
[source,bash,indent=0,subs="+attributes,+quotes"]
----
db.debeziumSignal.insert({ // <1>
"type" : "execute-snapshot", // <2> <3>
"data" : {
"data-collections" ["\"public\".\"Collection1\"", "\"public\".\"Collection2\""], // <4>
"type": "incremental"} // <5>
"additional-conditions":[{"data-collection": "schema1.table1" ,"filter":"color=\'blue\'"}]}'); // <6>
});
----
+
The values of the `id`,`type`, and `data` parameters in the command correspond to the {link-prefix}:{link-signalling}#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection[fields of the signaling {data-collection}].
+
The following table describes the parameters in the example:
+
.Descriptions of fields in a MongoDB insert() command for sending an incremental snapshot signal to the signaling {data-collection}
[cols="1,2,6",options="header"]
|===
|Item |Value |Description

|1
|`db.debeziumSignal`
|Specifies the fully-qualified name of the signaling {data-collection} on the source database.

|2
|null
|The `_id` parameter specifies an arbitrary string that is assigned as the `id` identifier for the signal request. +
The insert method in the preceding example omits use of the optional `_id` parameter.
Because the document does not explicitly assign a value for the parameter, the arbitrary id that MongoDB automatically assigns to the document becomes the `id` identifier for the signal request. +
Use this string to identify logging messages to entries in the signaling {data-collection}.
{prodname} does not use this identifier string.
Rather, during the snapshot, {prodname} generates its own `id` string as a watermarking signal.

|3
|`execute-snapshot`
|Specifies `type` parameter specifies the operation that the signal is intended to trigger. +

|4
|`data-collections`
|A required component of the `data` field of a signal that specifies an array of {data-collection} names or regular expressions to match {data-collection} names to include in the snapshot. +
The array lists regular expressions which match {data-collection}s by their fully-qualified names, using the same format as you use to specify the name of the connector's signaling {data-collection} in the xref:{context}-property-signal-data-collection[`signal.data.collection`] configuration property.

|5
|`incremental`
|An optional `type` component of the `data` field of a signal that specifies the type of snapshot operation to run. +
Currently supports the `incremental` and `blocking` types. +
If you do not specify a value, the connector runs an incremental snapshot.

|6
|`additional-conditions`
| An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot. +
Each element in the `additional-conditions` array is an object that includes the following keys:

`data-collection`:: The fully-qualified name of the data collection for which the filter will be applied.
`filter`:: Specifies the column values that must be present in a data collection record for the snapshot to include it, for example, `"color='blue'"`.
|===

The following example, shows the JSON for an incremental snapshot event that is captured by a connector.

.Example: Incremental snapshot event message
[source,json,index=0]
----
{
    "before":null,
    "after": {
        "pk":"1",
        "value":"New data"
    },
    "source": {
        ...
        "snapshot":"incremental" <1>
    },
    "op":"r", <2>
    "ts_ms":"1620393591654",
    "ts_us":"1620393591654962",
    "ts_ns":"1620393591654962147",
    "transaction":null
}
----
[cols="1,1,4",options="header"]
|===
|Item |Field name |Description
|1
|`snapshot`
|Specifies the type of snapshot operation to run. +
Currently, the only valid options are `blocking` and `incremental`. +
Specifying a `type` value in the SQL query that you submit to the signaling {data-collection} is optional. +
If you do not specify a value, the connector runs an incremental snapshot.

|2
|`op`
|Specifies the event type. +
The value for snapshot events is `r`, signifying a `READ` operation.

|===

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-mongdb-using-the-kafka-signaling-channel-to-trigger-an-incremental-snapshot
[id="mongodb-triggering-an-incremental-snapshot-kafka"]
==== Using the Kafka signaling channel to trigger an incremental snapshot

:leveloffset: +1

You can send a message to the {link-prefix}:{link-signalling}#debezium-signaling-enabling-kafka-signaling-channel[configured Kafka topic] to request the connector to run an ad hoc incremental snapshot.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value of the message is a JSON object with `type` and `data` fields.

The signal type is `execute-snapshot`, and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6a",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed.
Currently {prodname} supports the `incremental` and `blocking` types. +
See the next section for more details.

|`data-collections`
|_N/A_
| An array of comma-separated regular expressions that match the fully-qualified names of tables to include in the snapshot. +
Specify the names by using the same format as is required for the xref:{context}-property-signal-data-collection[signal.data.collection] configuration option.

|`[.line-through]#additional-condition#`
|_N/A_
| An optional string that specifies a condition that the connector evaluates to designate a subset of records to include in a snapshot. +

[NOTE]
====
This property is deprecated and should be replaced by the `additional-conditions` property.
====

|`additional-conditions`
|_N/A_
| An optional array of additional conditions that specifies criteria that the connector evaluates to designate a subset of records to include in a snapshot. +
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:
`data-collection`:: The fully-qualified name of the {data-collection} that the filter applies to.
You can apply different filters to each {data-collection}.
`filter`:: Specifies column values that must be present in a database record for the snapshot to include it, for example,  `"color='blue'"`. +
 +
The values that you assign to the `filter` parameter are the same types of values that you might specify in the `WHERE` clause of `SELECT` statements when you set the `snapshot.select.statement.overrides` property for a blocking snapshot.
In earlier {prodname} releases, an explicit `filter` parameter was not defined for snapshot signals; instead, filter criteria were implied by the values that were specified for the now deprecated `additional-condition` parameter.
|===

An example of the execute-snapshot Kafka message:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

.Ad hoc incremental snapshots with additional-conditions

{prodname} uses the `additional-conditions` field to select a subset of a {data-collection}'s content.

Typically, when {prodname} runs a snapshot, it runs a SQL query such as:

`SELECT * FROM _<tableName>_ ....`

When the snapshot request includes an `additional-conditions` property, the `data-collection` and `filter` parameters of the  property are appended to the SQL query, for example:

`SELECT * FROM _<data-collection>_ WHERE _<filter>_ ....`

For example, given a `products` {data-collection} with the columns `id` (primary key), `color`, and `brand`, if you want a snapshot to include only content for which `color='blue'`, when you request the snapshot, you could add the `additional-conditions` property to filter the content:
----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "schema1.products" ,"filter":"color='blue'"}]}}`
----

You can use the `additional-conditions` property to pass conditions based on multiple columns.
For example, using the same `products` {data-collection} as in the previous example, if you want a snapshot to include only the content from the `products` {data-collection} for which `color='blue'`, and `brand='MyBrand'`, you could send the following request:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "schema1.products" ,"filter":"color='blue' AND brand='MyBrand'"}]}}`
----

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-mongodb-stopping-an-incremental-snapshot
[id="mongodb-stopping-an-incremental-snapshot"]
==== Stopping an incremental snapshot

:leveloffset: +1

You can also stop an incremental snapshot by sending a signal to the {data-collection} on the source database.
You submit a stop snapshot signal by inserting a document into the to the signaling {data-collection}.
After {prodname} detects the change in the signaling {data-collection}, it reads the signal, and stops the incremental snapshot operation if it's in progress.

The query that you submit specifies the snapshot operation of `incremental`, and, optionally, the {data-collection}s of the current running snapshot to be removed.

.Prerequisites

* {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[Signaling is enabled]. +
** A signaling data collection exists on the source database.
** The signaling data collection is specified in the xref:{context}-property-signal-data-collection[`signal.data.collection`] property.

.Using a source signaling channel to stop an incremental snapshot

. Insert a stop snapshot signal document into the signaling {data-collection}:
+
[source,bash,indent=0,subs="+attributes,+quotes"]
----
_<signalDataCollection>_.insert({"_id" : _<idNumber>_,"type" : "stop-snapshot", "data" : {"data-collections" ["_<collectionName>_", "_<collectionName>_"],"type": "incremental"}});
----
+
For example,
+
[source,bash,indent=0,subs="+attributes"]
----
db.debeziumSignal.insert({ // <1>
"type" : "stop-snapshot", // <2> <3>
"data" : {
"data-collections" ["\"public\".\"Collection1\"", "\"public\".\"Collection2\""], // <4>
"type": "incremental"} // <5>
});
----
+
The values of the `id`, `type`, and `data` parameters in the signal command correspond to the {link-prefix}:{link-signalling}#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection[fields of the signaling {data-collection}].
+
The following table describes the parameters in the example:
+
.Descriptions of fields in an insert command for sending a stop incremental snapshot document to the signaling {data-collection}
[cols="1,2,6",options="header"]
|===
|Item|Value |Description

|1
|`db.debeziumSignal`
|Specifies the fully-qualified name of the signaling {data-collection} on the source database.

|2
|null
|The insert method in the preceding example omits use of the optional `_id` parameter.
Because the document does not explicitly assign a value for the parameter, the arbitrary id that MongoDB automatically assigns to the document becomes the `id` identifier for the signal request. +
Use this string to identify logging messages to entries in the signaling {data-collection}.
{prodname} does not use this identifier string.

|3
|`stop-snapshot`
| The `type` parameter specifies the operation that the signal is intended to trigger. +

|4
|`data-collections`
|An optional component of the `data` field of a signal that specifies an array of {data-collection} names or regular expressions to match {data-collection} names to remove from the snapshot. +
The array lists regular expressions which match {data-collection}s by their fully-qualified names, using the same format as you use to specify the name of the connector's signaling {data-collection} in the xref:{context}-property-signal-data-collection[`signal.data.collection`] configuration property.
If this component of the `data` field is omitted, the signal stops the entire incremental snapshot that is in progress.

|5
|`incremental`
|A required component of the `data` field of a signal that specifies the type of snapshot operation that is to be stopped. +
Currently, the only valid option is `incremental`. +
If you do not specify a `type` value, the signal fails to stop the incremental snapshot.
|===

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-mongodb-using-the-kafka-signaling-channel-to-stop-an-incremental-snapshot
[id="mongodb-stopping-an-incremental-snapshot-kafka"]
==== Using the Kafka signaling channel to stop an incremental snapshot
:leveloffset: +1

You can send a signal message to the {link-prefix}:{link-signalling}#debezium-signaling-enabling-kafka-signaling-channel[configured Kafka signaling topic] to stop an ad hoc incremental snapshot.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value of the message is a JSON object with `type` and `data` fields.

The signal type is `stop-snapshot`, and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed.
Currently {prodname} supports only the `incremental` type.  +
See the next section for more details.

|`data-collections`
|_N/A_
| An optional array of comma-separated regular expressions that match the fully-qualified names of the tables to include in the snapshot. +
Specify the names by using the same format as is required for the xref:{context}-property-signal-data-collection[signal.data.collection] configuration option.

|===

The following example shows a typical `stop-snapshot` Kafka message:

----
Key = `test_connector`

Value = `{"type":"stop-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

:leveloffset: 1

[[connector-custom-snapshot]]
=== Custom snapshotter SPI
:leveloffset: +3

For more advanced uses, you can fine-tune control of the snapshot by implementing one of the following interfaces:

`io.debezium.snapshot.spi.Snapshotter`:: Controls whether the connector takes a snapshot.
`io.debezium.snapshot.spi.SnapshotQuery`:: Controls how data is queried during a snapshot.
`io.debezium.snapshot.spi.SnapshotLock`:: Controls whether the connector locks tables when taking a snapshot.


[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.Snapshotter interface. All built-in snapshot modes implement this interface.
----
/**
 * {@link Snapshotter} is used to determine the following details about the snapshot process:
 * <p>
 * - Whether a snapshot occurs. <br>
 * - Whether streaming continues during the snapshot. <br>
 * - Whether the snapshot includes schema (if supported). <br>
 * - Whether to snapshot data or schema following an error.
 * <p>
 * Although Debezium provides many default snapshot modes,
 * to provide more advanced functionality, such as partial snapshots,
 * you can customize implementation of the interface.
 * For more information, see the documentation.
 *
 *
 *
 */
@Incubating
public interface Snapshotter extends Configurable {

    /**
     * @return the name of the snapshotter.
     *
     *
     */
    String name();

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a data snapshot
     */
    boolean shouldSnapshotData(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a schema snapshot
     */
    boolean shouldSnapshotSchema(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @return {@code true} if the snapshotter should stream after taking a snapshot
     */
    boolean shouldStream();

    /**
     * @return {@code true} whether the schema can be recovered if database schema history is corrupted.
     */
    boolean shouldSnapshotOnSchemaError();

    /**
     * @return {@code true} whether the snapshot should be re-executed when there is a gap in data stream.
     */
    boolean shouldSnapshotOnDataError();

    /**
     *
     * @return {@code true} if streaming should resume from the start of the snapshot
     * transaction, or {@code false} for when a connector resumes and takes a snapshot,
     * streaming should resume from where streaming previously left off.
     */
    default boolean shouldStreamEventsStartingFromSnapshot() {
        return true;
    }

    /**
     * Lifecycle hook called after the snapshot phase is successful.
     */
    default void snapshotCompleted() {
        // no operation
    }

    /**
     * Lifecycle hook called after the snapshot phase is aborted.
     */
    default void snapshotAborted() {
        // no operation
    }
}
----

[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.SnapshotQuery interface. All built-in snapshot query modes implement this interface.
----
/**
 * {@link SnapshotQuery} is used to determine the query used during a data snapshot
 *
 *
 */
public interface SnapshotQuery extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Generate a valid query string for the specified table, or an empty {@link Optional}
     * to skip snapshotting this table (but that table will still be streamed from)
     *
     * @param tableId the table to generate a query for
     * @param snapshotSelectColumns the columns to be used in the snapshot select based on the column
     *                              include/exclude filters
     * @return a valid query string, or none to skip snapshotting this table
     */
    Optional<String> snapshotQuery(String tableId, List<String> snapshotSelectColumns);

}
----

[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.SnapshotLock interface. All built-in snapshot lock modes implement this interface.
----
/**
 * {@link SnapshotLock} is used to determine the table lock mode used during schema snapshot
 *
 *
 */
public interface SnapshotLock extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Returns a SQL statement for locking the given table during snapshotting, if required by the specific snapshotter
     * implementation.
     */
    Optional<String> tableLockingStatement(Duration lockTimeout, String tableId);

}
----

:leveloffset: 1

// Type: concept
[id="mongodb-blocking-snapshots"]
=== Blocking snapshots

:leveloffset: +3

To provide more flexibility in managing snapshots, {prodname} includes a supplementary ad hoc snapshot mechanism, known as a _blocking snapshot_.
Blocking snapshots rely on the {prodname} mechanism for {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[sending signals to a {prodname} connector].

A blocking snapshot behaves just like an _initial snapshot_, except that you can trigger it at run time.

You might want to run a blocking snapshot rather than use the standard initial snapshot process in the following situations:

* You add a new {data-collection} and you want to complete the snapshot while the connector is running.
* You add a large {data-collection}, and you want the snapshot to complete in less time than is possible with an incremental snapshot.

.Blocking snapshot process
When you run a blocking snapshot, {prodname} stops streaming, and then initiates a snapshot of the specified {data-collection}, following the same process that it uses during an initial snapshot.
After the snapshot completes, the streaming is resumed.

.Configure snapshot

You can set the following properties in the `data` component of a signal:

 * data-collections: to specify which {data-collection}s must be snapshot
 * additional-conditions: You can specify different filters for different {data-collection}. +
 ** The `data-collection` property is the fully-qualified name of the {data-collection} for which the filter will be applied.
 ** The `filter` property will have the same value used in the  `snapshot.select.statement.overrides`

For example:
[source,json]
----
  {"type": "blocking", "data-collections": ["schema1.table1", "schema1.table2"], "additional-conditions": [{"data-collection": "schema1.table1", "filter": "SELECT * FROM [schema1].[table1] WHERE column1 = 0 ORDER BY column2 DESC"}, {"data-collection": "schema1.table2", "filter": "SELECT * FROM [schema1].[table2] WHERE column2 > 0"}]}
----

.Possible duplicates
A delay might exist between the time that you send the signal to trigger the snapshot, and the time when streaming stops and the snapshot starts.
As a result of this delay, after the snapshot completes, the connector might emit some event records that duplicate records captured by the snapshot.

:leveloffset: 1

// Type: concept
// ModuleID: how-the-debezium-mongodb-connector-streams-change-event-records
// Title: How the {prodname} MongoDB connector streams change event records
[[mongodb-streaming-changes]]
=== Streaming changes
[[mongodb-tailing-the-oplog]]

After the connector task for a replica set records an offset, it uses the offset to determine the position in the oplog where it should start streaming changes.
The task then (depending on the configuration) either connects to the replica set's primary node or connects to a replica-set-wide change stream and starts streaming changes from that position.
It processes all of create, insert, and delete operations, and converts them into {prodname} xref:mongodb-events[change events].
Each change event includes the position in the oplog where the operation was found, and the connector periodically records this as its most recent offset.
The interval at which the offset is recorded is governed by link:https://kafka.apache.org/documentation/#offset.flush.interval.ms[`offset.flush.interval.ms`], which is a Kafka Connect worker configuration property.

When the connector is stopped gracefully, the last offset processed is recorded so that, upon restart, the connector will continue exactly where it left off.
If the connector's tasks terminate unexpectedly, however, then the tasks may have processed and generated events after it last records the offset but before the last offset is recorded; upon restart, the connector begins at the last _recorded_ offset, possibly generating some the same events that were previously generated just prior to the crash.

[NOTE]
====
When all components in a Kafka pipeline operate nominally, Kafka consumers receive every message *_exactly once_*.
However, when things go wrong, Kafka can only guarantee that consumers receive every message *_at least once_*.
To avoid unexpected results, consumers must be able to handle duplicate messages.
====

As mentioned earlier, the connector tasks always use the replica set's primary node to stream changes from the oplog, ensuring that the connector sees the most up-to-date operations as possible and can capture the changes with lower latency than if secondaries were to be used instead.
When the replica set elects a new primary, the connector immediately stops streaming changes, connects to the new primary, and starts streaming changes from the new primary node at the same position.
Likewise, if the connector experiences any problems communicating with the replica set members, it tries to reconnect, by using exponential backoff so as to not overwhelm the replica set, and once connected it continues streaming changes from where it last left off.
In this way, the connector is able to dynamically adjust to changes in replica set membership and automatically handle communication failures.

To summarize, the MongoDB connector continues running in most situations. Communication problems might cause the connector to wait until the problems are resolved.

// Type: concept
// ModuleID: mongodb-support-for-populating-the-before-state-in-debezium-change-events
// Title: MongoDB support for populating the `before` field in {prodname} change event
[[mongodb-pre-image-support]]
=== Pre-image support
In MongoDB 6.0 and later, you can configure change streams to emit the pre-image state of a document to populate the `before` field for MongoDB change events.
To enable the use of pre-images in MongoDB, you must set the `changeStreamPreAndPostImages` for a collection by using `db.createCollection()`, `create`, or `collMod`.
To enable the {prodname} MongoDB to include pre-images in change events, set the `capture.mode` for the connector to one of the `*_with_pre_image` options.

[NOTE]
.Size limits on MongoDB change stream events
====
The size of a MongoDB change stream event is limited to 16 megabytes.
The use of pre-images thus increases the likelihood of exceeding this threshold, which can lead to failures.
For information about how to avoid exceeding the change stream limit, see the https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre--and-post-images/[MongoDB documentation].
====

// Type: concept
// ModuleID: default-names-of-kafka-topics-that-receive-debezium-mongodb-change-event-records
// Title: Default names of Kafka topics that receive {prodname} MongoDB change event records
[[mongodb-topic-names]]
=== Topic names

The MongoDB connector writes events for all insert, update, and delete operations to documents in each collection to a single Kafka topic.
The name of the Kafka topics always takes the form _logicalName_._databaseName_._collectionName_, where _logicalName_ is the xref:mongodb-logical-connector-name[logical name] of the connector as specified with the `topic.prefix` configuration property, _databaseName_ is the name of the database where the operation occurred, and _collectionName_ is the name of the MongoDB collection in which the affected document existed.

For example, consider a MongoDB replica set with an `inventory` database that contains four collections: `products`, `products_on_hand`, `customers`, and `orders`.
If the connector monitoring this database were given a logical name of `fulfillment`, then the connector would produce events on these four Kafka topics:

* `fulfillment.inventory.products`
* `fulfillment.inventory.products_on_hand`
* `fulfillment.inventory.customers`
* `fulfillment.inventory.orders`

Notice that the topic names do not incorporate the replica set name or shard name.
As a result, all changes to a sharded collection (where each shard contains a subset of the collection's documents) all go to the same Kafka topic.

You can set up Kafka to {link-kafka-docs}.html#basic_ops_add_topic[auto-create] the topics as they are needed.
If not, then you must use Kafka administration tools to create the topics before starting the connector.

// Type: concept
// ModuleID: how-event-keys-control-topic-partitioning-for-the-debezium-mongodb-connector
// Title: How event keys control topic partitioning for the {prodname} MongoDB connector
[[mongodb-partitions]]
=== Partitions

The MongoDB connector does not make any explicit determination about how to partition topics for events.
Instead, it allows Kafka to determine how to partition topics based on event keys.
You can change Kafka's partitioning logic by defining the name of the `Partitioner` implementation in the Kafka Connect worker configuration.

Kafka maintains total order only for events written to a single topic partition.
Partitioning the events by key does mean that all events with the same key always go to the same partition.
This ensures that all events for a specific document are always totally ordered.


// Type: concept
// ModuleID: debezium-mongodb-connector-generated-events-that-represent-transaction-boundaries
// Title: {prodname} MongoDB connector-generated events that represent transaction boundaries
[[mongodb-transaction-metadata]]
=== Transaction Metadata

{prodname} can generate events that represents transaction metadata boundaries and enrich change data event messages.

[NOTE]
.Limits on when {prodname} receives transaction metadata
====
{prodname} registers and receives metadata only for transactions that occur after you deploy the connector.
Metadata for transactions that occur before you deploy the connector is not available.
====

For every transaction `BEGIN` and `END`, {prodname} generates an event that contains the following fields:

`status`:: `BEGIN` or `END`
`id`:: String representation of unique transaction identifier.
`event_count` (for `END` events):: Total number of events emitted by the transaction.
`data_collections` (for `END` events):: An array of pairs of `data_collection` and `event_count` that provides number of events emitted by changes originating from given data collection.

The following example shows a typical message:

[source,json,indent=0,subs="+attributes"]
----
{
  "status": "BEGIN",
  "id": "1462833718356672513",
  "event_count": null,
  "data_collections": null
}

{
  "status": "END",
  "id": "1462833718356672513",
  "event_count": 2,
  "data_collections": [
    {
      "data_collection": "rs0.testDB.collectiona",
      "event_count": 1
    },
    {
      "data_collection": "rs0.testDB.collectionb",
      "event_count": 1
    }
  ]
}
----

Unless overridden via the xref:mongodb-property-topic-transaction[`topic.transaction`] option,
transaction events are written to the topic named xref:mongodb-property-topic-prefix[`_<topic.prefix>_`]`.transaction`.

.Change data event enrichment
When transaction metadata is enabled, the data message `Envelope` is enriched with a new `transaction` field.
This field provides information about every event in the form of a composite of fields:

`id`:: String representation of unique transaction identifier.
`total_order`:: The absolute position of the event among all events generated by the transaction.
`data_collection_order`:: The per-data collection position of the event among all events that were emitted by the transaction.

Following is an example of what a message looks like:

[source,json,indent=0,subs="+attributes"]
----
{
  "after": "{\"_id\" : {\"$numberLong\" : \"1004\"},\"first_name\" : \"Anne\",\"last_name\" : \"Kretchmar\",\"email\" : \"annek@noanswer.org\"}",
  "source": {
...
  },
  "op": "c",
  "ts_ms": "1580390884335",
  "ts_us": "1580390884335486",
  "ts_ns": "1580390884335486281",
  "transaction": {
    "id": "1462833718356672513",
    "total_order": "1",
    "data_collection_order": "1"
  }
}
----

// Type: assembly
// ModuleID: descriptions-of-debezium-mongodb-connector-data-change-events
// Title: Descriptions of {prodname} MongoDB connector data change events
[[mongodb-events]]
== Data change events

The {prodname} MongoDB connector generates a data change event for each document-level operation that inserts, updates, or deletes data. Each event contains a key and a value. The structure of the key and the value depends on the collection that was changed.

{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained.

The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converter and you configure it to produce all four basic change event parts, change events have this structure:

[source,json,index=0]
----
{
 "schema": { // <1>
   ...
  },
 "payload": { // <2>
   ...
 },
 "schema": { // <3>
   ...
 },
 "payload": { // <4>
   ...
 },
}
----

.Overview of change event basic content
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the key for the document that was changed.

|2
|`payload`
|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the document that was changed.

|3
|`schema`
|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the document that was changed. Typically, this schema contains nested schemas.

|4
|`payload`
|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the document that was changed.

|===

By default, the connector streams change event records to topics with names that are the same as the event's originating collection. See xref:mongodb-topic-names[topic names].

[WARNING]
====
The MongoDB connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or \_. Each remaining character in the logical server name and each character in the database and collection names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or \_. If there is an invalid character it is replaced with an underscore character.

This can lead to unexpected conflicts if the logical server name, a database name, or a collection name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.
====




// Type: concept
// ModuleID: about-keys-in-debezium-mongodb-change-events
// Title: About keys in {prodname} MongoDB change events
[[mongodb-change-events-key]]
=== Change event keys

A change event's key contains the schema for the changed document's key and the changed document's actual key. For a given collection, both the schema and its corresponding payload contain a single `id` field.
The value of this field is the document's identifier represented as a string that is derived from link:https://docs.mongodb.com/manual/reference/mongodb-extended-json/[MongoDB extended JSON serialization strict mode].

Consider a connector with a logical name of `fulfillment`, a replica set containing an `inventory` database, and a `customers` collection that contains documents such as the following.

.Example document
[source,json,indent=0]
----
  {
    "_id": 1004,
    "first_name": "Anne",
    "last_name": "Kretchmar",
    "email": "annek@noanswer.org"
  }
----

.Example change event key
Every change event that captures a change to the `customers` collection has the same event key schema. For as long as the `customers` collection has the previous definition, every change event that captures a change to the `customers` collection has the following key structure. In JSON, it looks like this:

[source,json,indent=0]
----
  {
    "schema": { // <1>
      "type": "struct",
      "name": "fulfillment.inventory.customers.Key", // <2>
      "optional": false, // <3>
      "fields": [ // <4>
        {
          "field": "id",
          "type": "string",
          "optional": false
        }
      ]
    },
    "payload": { // <5>
      "id": "1004"
    }
  }
----

.Description of change event key
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion.

|2
|`fulfillment.inventory.customers.Key`
a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the key for the document that was changed. Key schema names have the format _connector-name_._database-name_._collection-name_.`Key`. In this example: +

* `fulfillment` is the name of the connector that generated this event. +
* `inventory` is the database that contains the collection that was changed. +
* `customers` is the collection that contains the document that was updated.

|3
|`optional`
|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a document does not have a key.

|4
|`fields`
|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.

|5
|`payload`
|Contains the key for the document for which this change event was generated. In this example, the key contains a single `id` field of type `string` whose value is `1004`.

|===

This example uses a document with an integer identifier, but any valid MongoDB document identifier works the same way, including a document identifier. For a document identifier, an event key's `payload.id` value is a string that represents the updated document's original `_id` field as a MongoDB extended JSON serialization that uses strict mode. The following table provides examples of how different types of `_id` fields are represented.

.Examples of representing document `_id` fields in event key payloads
[options="header",role="code-wordbreak-col2 code-wordbreak-col3"]
|===
|Type    |MongoDB `_id` Value|Key's payload
|Integer |1234|`{ "id" : "1234" }`
|Float   |12.34|`{ "id" : "12.34" }`
|String  |"1234"|`{ "id" : "\"1234\"" }`
|Document|`{ "hi" : "kafka", "nums" : [10.0, 100.0, 1000.0] }`|`{ "id" : "{\"hi\" : \"kafka\", \"nums\" : [10.0, 100.0, 1000.0]}" }`
|ObjectId |`ObjectId("596e275826f08b2730779e1f")`|`{ "id" : "{\"$oid\" : \"596e275826f08b2730779e1f\"}" }`
|Binary  |`BinData("a2Fma2E=",0)`|`{ "id" : "{\"$binary\" : \"a2Fma2E=\", \"$type\" : \"00\"}" }`
|===

// Type: concept
// ModuleID: about-values-in-debezium-mongodb-change-events
// Title: About values in {prodname} MongoDB change events
[[mongodb-change-events-value]]
=== Change event values

The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure.

Consider the same sample document that was used to show an example of a change event key:


.Example document
[source,json,indent=0]
----
  {
    "_id": 1004,
    "first_name": "Anne",
    "last_name": "Kretchmar",
    "email": "annek@noanswer.org"
  }
----

The value portion of a change event for a change to this document is described for each event type:

* <<mongodb-create-events,_create_ events>>
* <<mongodb-update-events,_update_ events>>
* <<mongodb-delete-events,_delete_ events>>
* <<mongodb-tombstone-events,Tombstone events>>

[id="mongodb-create-events"]
=== _create_ events

The following example shows the value portion of a change event that the connector generates for an operation that creates data in the `customers` collection:

[source,json,options="nowrap",indent=0,subs="+attributes"]
----
{
    "schema": { // <1>
      "type": "struct",
      "fields": [
        {
          "type": "string",
          "optional": true,
          "name": "io.debezium.data.Json", // <2>
          "version": 1,
          "field": "after"
        },
        {
          "type": "string",
          "optional": true,
          "name": "io.debezium.data.Json",
          "version": 1,
          "field": "patch"
        },
        {
          "type": "struct",
          "fields": [
            {
              "type": "string",
              "optional": false,
              "field": "version"
            },
            {
              "type": "string",
              "optional": false,
              "field": "connector"
            },
            {
              "type": "string",
              "optional": false,
              "field": "name"
            },
            {
              "type": "int64",
              "optional": false,
              "field": "ts_ms"
            },
            {
              "type": "int64",
              "optional": false,
              "field": "ts_us"
            },
            {
              "type": "int64",
              "optional": false,
              "field": "ts_ns"
            },
            {
              "type": "boolean",
              "optional": true,
              "default": false,
              "field": "snapshot"
            },
            {
              "type": "string",
              "optional": false,
              "field": "db"
            },
            {
              "type": "string",
              "optional": false,
              "field": "rs"
            },
            {
              "type": "string",
              "optional": false,
              "field": "collection"
            },
            {
              "type": "int32",
              "optional": false,
              "field": "ord"
            },
            {
              "type": "int64",
              "optional": true,
              "field": "h"
            }
          ],
          "optional": false,
          "name": "io.debezium.connector.mongo.Source", // <3>
          "field": "source"
        },
        {
          "type": "string",
          "optional": true,
          "field": "op"
        },
        {
          "type": "int64",
          "optional": true,
          "field": "ts_ms"
        },
        {
          "type": "int64",
          "optional": true,
          "field": "ts_us"
        },
        {
          "type": "int64",
          "optional": true,
          "field": "ts_ns"
        }
      ],
      "optional": false,
      "name": "dbserver1.inventory.customers.Envelope" // <4>
      },
    "payload": { // <5>
      "after": "{\"_id\" : {\"$numberLong\" : \"1004\"},\"first_name\" : \"Anne\",\"last_name\" : \"Kretchmar\",\"email\" : \"annek@noanswer.org\"}", // <6>
      "source": { // <7>
        "version": "{debezium-version}",
        "connector": "mongodb",
        "name": "fulfillment",
        "ts_ms": 1558965508000,
        "ts_ms": 1558965508000000,
        "ts_ms": 1558965508000000000,
        "snapshot": false,
        "db": "inventory",
        "rs": "rs0",
        "collection": "customers",
        "ord": 31,
        "h": 1546547425148721999
      },
      "op": "c", // <8>
      "ts_ms": 1558965515240, // <9>
      "ts_us": 1558965515240142, // <10>
      "ts_ns": 1558965515240142879, // <11>
    }
  }
----

.Descriptions of _create_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The value's schema, which describes the structure of the value's payload. A change event's value schema is the same in every change event that the connector generates for a particular collection.

|2
|`name`
a|In the `schema` section, each `name` field specifies the schema for a field in the value's payload. +
 +
`io.debezium.data.Json` is the schema for the payload's `after`, `patch`, and `filter` fields. This schema is specific to the `customers` collection. A _create_ event is the only kind of event that contains an `after` field. An _update_ event contains a `filter` field and a `patch` field. A _delete_ event contains a `filter` field, but not an `after` field nor a `patch` field.

|3
|`name`
a|`io.debezium.connector.mongo.Source` is the schema for the payload's `source` field. This schema is specific to the MongoDB connector. The connector uses it for all events that it generates.

|4
|`name`
a|`dbserver1.inventory.customers.Envelope` is the schema for the overall structure of the payload, where `dbserver1` is the connector name, `inventory` is the database, and `customers` is the collection. This schema is specific to the collection.

|5
|`payload`
|The value's actual data. This is the information that the change event is providing. +
 +
It may appear that the JSON representations of the events are much larger than the documents they describe. This is because the JSON representation must include the schema and the payload portions of the message.
However, by using the {link-prefix}:{link-avro-serialization}#avro-serialization[Avro converter], you can significantly decrease the size of the messages that the connector streams to Kafka topics.

|6
|`after`
|An optional field that specifies the state of the document after the event occurred.
In this example, the `after` field contains the values of the new document's `\_id`, `first_name`, `last_name`, and `email` fields.
The `after` value is always a string.
By convention, it contains a JSON representation of the document.
MongoDB oplog entries contain the full state of a document only for _create_ events and also for `update` events, when the `capture.mode` option is set to `change_streams_update_full`;
in other words, a _create_ event is the only kind of event that contains an _after_ field regardless of `capture.mode` option.

|7
|`source`
a|Mandatory field that describes the source metadata for the event. This field contains information that you can use to compare this event with other events, with regard to the origin of the events, the order in which the events occurred, and whether events were part of the same transaction. The source metadata includes:

* {prodname} version.
* Name of the connector that generated the event.
* Logical name of the MongoDB replica set, which forms a namespace for generated events and is used in Kafka topic names to which the connector writes.
* Names of the collection and database that contain the new document.
* If the event was part of a snapshot.
* Timestamp for when the change was made in the database and ordinal of the event within the timestamp.
* Unique identifier of the MongoDB operation (the `h` field in the oplog event).
* Unique identifiers of the MongoDB session `lsid` and transaction number `txnNumber` in case the change was executed inside a transaction (change streams capture mode only).

|8
|`op`
a|Mandatory string that describes the type of operation that caused the connector to generate the event. In this example, `c` indicates that the operation created a document. Valid values are:

* `c` = create
* `u` = update
* `d` = delete
* `r` = read (applies to only snapshots)

|9
|`ts_ms`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|10
|`ts_us`
a|Optional field that displays the time at which the connector processed the event, in microseconds.
The time is based on the system clock in the JVM running the Kafka Connect task.

|9
|`ts_ns`
a|Optional field that displays the time at which the connector processed the event, in nanoseconds.
The time is based on the system clock in the JVM running the Kafka Connect task.

|===

[id="mongodb-update-events"]
=== _update_ events

==== Change streams capture mode
The value of a change event for an update in the sample `customers` collection has the same schema as a _create_ event for that collection.
Likewise, the event value's payload has the same structure.
However, the event value payload contains different values in an _update_ event.
An _update_ event includes an `after` value only if the `capture.mode` option is set to `change_streams_update_full`.
A `before` value is provided if the `capture.mode` option is set to one of the `*_with_pre_image` option.
There is a new structured field `updateDescription` with a few additional fields in this case:

* `updatedFields` is a string field that contains the JSON representation of the updated document fields with their values

* `removedFields` is a list of field names that were removed from the document

* `truncatedArrays` is a list of arrays in the document that were truncated

Here is an example of a change event value in an event that the connector generates for an update in the `customers` collection:

[source,json,indent=0,options="nowrap",subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
      "op": "u", // <1>
      "ts_ms": 1465491461815, // <2>
      "ts_us": 1465491461815698, // <2>
      "ts_ns": 1465491461815698142, // <2>
      "before":"{\"_id\": {\"$numberLong\": \"1004\"},\"first_name\": \"unknown\",\"last_name\": \"Kretchmar\",\"email\": \"annek@noanswer.org\"}", // <3>
      "after":"{\"_id\": {\"$numberLong\": \"1004\"},\"first_name\": \"Anne Marie\",\"last_name\": \"Kretchmar\",\"email\": \"annek@noanswer.org\"}", // <4>
      "updateDescription": {
        "removedFields": null,
        "updatedFields": "{\"first_name\": \"Anne Marie\"}", // <5>
        "truncatedArrays": null
      },
      "source": { // <6>
        "version": "{debezium-version}",
        "connector": "mongodb",
        "name": "fulfillment",
        "ts_ms": 1558965508000,
        "ts_us": 1558965508000000,
        "ts_ns": 1558965508000000000,
        "snapshot": false,
        "db": "inventory",
        "rs": "rs0",
        "collection": "customers",
        "ord": 1,
        "h": null,
        "tord": null,
        "stxnid": null,
        "lsid":"{\"id\": {\"$binary\": \"FA7YEzXgQXSX9OxmzllH2w==\",\"$type\": \"04\"},\"uid\": {\"$binary\": \"47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\",\"$type\": \"00\"}}",
        "txnNumber":1
      }
    }
  }
----

.Descriptions of _update_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`op`
a|Mandatory string that describes the type of operation that caused the connector to generate the event. In this example, `u` indicates that the operation updated a document.

|2
|`ts_ms`, `ts_us`, `ts_ns`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|3
|`before`
|Contains the JSON string representation of the actual MongoDB document before change.
+
An _update_ event value does not contain an `before` field if the capture mode is not set to one of the `*_with_preimage` options.

|4
|`after`
|Contains the JSON string representation of the actual MongoDB document.
 +
An _update_ event value does not contain an `after` field if the capture mode is not set to `change_streams_update_full`

|5
|`updatedFields`
|Contains the JSON string representation of the updated field values of the document. In this example, the update changed the `first_name` field to a new value.

|6
|`source`
a|Mandatory field that describes the source metadata for the event. This field contains the same information as a _create_ event for the same collection, but the values are different since this event is from a different position in the oplog. The source metadata includes:

* {prodname} version.
* Name of the connector that generated the event.
* Logical name of the MongoDB replica set, which forms a namespace for generated events and is used in Kafka topic names to which the connector writes.
* Names of the collection and database that contain the updated document.
* If the event was part of a snapshot.
* Timestamp for when the change was made in the database and ordinal of the event within the timestamp.
* Unique identifiers of the MongoDB session `lsid` and transaction number `txnNumber` in case the change was executed inside a transaction.

|===

[WARNING]
====
The `after` value in the event should be handled as the at-point-of-time value of the document.
The value is not calculated dynamically but is obtained from the collection.
It is thus possible if multiple updates are closely following one after the other, that all _update_ updates events will contain the same `after` value which will be representing the last value stored in the document.

If your application depends on gradual change evolution then you should rely on `updateDescription` only.
====

[id="mongodb-delete-events"]
=== _delete_ events

The value in a _delete_ change event has the same `schema` portion as _create_ and _update_ events for the same collection. The `payload` portion in a _delete_ event contains values that are different from _create_ and _update_ events for the same collection. In particular, a _delete_ event contains neither an `after` value nor a `updateDescription` value. Here is an example of a _delete_ event for a document in the `customers` collection:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
      "op": "d", // <1>
      "ts_ms": 1465495462115, // <2>
      "ts_us": 1465495462115748, // <2>
      "ts_ns": 1465495462115748263, // <2>
      "before":"{\"_id\": {\"$numberLong\": \"1004\"},\"first_name\": \"Anne Marie\",\"last_name\": \"Kretchmar\",\"email\": \"annek@noanswer.org\"}",// <3>
      "source": { // <4>
        "version": "{debezium-version}",
        "connector": "mongodb",
        "name": "fulfillment",
        "ts_ms": 1558965508000,
        "ts_us": 1558965508000000,
        "ts_ns": 1558965508000000000,
        "snapshot": true,
        "db": "inventory",
        "rs": "rs0",
        "collection": "customers",
        "ord": 6,
        "h": 1546547425148721999
      }
    }
  }
----

.Descriptions of _delete_ event value fields
[cols="1,2,7",options="header",subs="+attributes"]
|===
|Item |Field name |Description

|1
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `d`, signifying that this document was deleted.

|2
|`ts_ms`, `ts_us`. `ts_ns`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task.  +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|3
|`before`
|Contains the JSON string representation of the actual MongoDB document before change.
+
An _update_ event value does not contain an `before` field if the capture mode is not set to one of the `*_with_preimage` options.

|4
|`source`
a|Mandatory field that describes the source metadata for the event. This field contains the same information as a _create_ or _update_ event for the same collection, but the values are different since this event is from a different position in the oplog. The source metadata includes:

* {prodname} version.
* Name of the connector that generated the event.
* Logical name of the MongoDB replica set, which forms a namespace for generated events and is used in Kafka topic names to which the connector writes.
* Names of the collection and database that contained the deleted document.
* If the event was part of a snapshot.
* Timestamp for when the change was made in the database and ordinal of the event within the timestamp.
* Unique identifier of the MongoDB operation (the `h` field in the oplog event).
* Unique identifiers of the MongoDB session `lsid` and transaction number `txnNumber` in case the change was executed inside a transaction (change streams capture mode only).

|===

MongoDB connector events are designed to work with link:{link-kafka-docs}/#compaction[Kafka log compaction]. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.

[id="mongodb-tombstone-events"]
=== Tombstone events
All MongoDB connector events for a uniquely identified document have exactly the same key. When a document is deleted, the _delete_ event value still works with log compaction because Kafka can remove all earlier messages that have that same key. However, for Kafka to remove all messages that have that key, the message value must be `null`. To make this possible, after {prodname}’s MongoDB connector emits a _delete_ event, the connector emits a special tombstone event that has the same key but a `null` value. A tombstone event informs Kafka that all messages with that same key can be removed.


// Type: assembly
// ModuleID: setting-up-mongodb-to-work-with-debezium
// Title: Setting up MongoDB to work with a {prodname} connector
[[setting-up-mongodb]]
== Setting up MongoDB

The MongoDB connector uses MongoDB's change streams to capture the changes, so the connector works only with MongoDB replica sets or with sharded clusters where each shard is a separate replica set.
See the MongoDB documentation for setting up a https://docs.mongodb.com/manual/replication/[replica set] or https://docs.mongodb.com/manual/sharding/[sharded cluster].
Also, be sure to understand how to enable https://docs.mongodb.com/manual/tutorial/deploy-replica-set-with-keyfile-access-control/#deploy-repl-set-with-auth[access control and authentication] with replica sets.

You must also have a MongoDB user that has the appropriate roles to read the `admin` database where the oplog can be read. Additionally, the user must also be able to read the `config` database in the configuration server of a sharded cluster and must have `listDatabases` privilege action.
When change streams are used (the default) the user also must have cluster-wide privilege actions `find` and `changeStream`.

When you intend to utilize pre-image and populate the `before` field, you need to first enable `changeStreamPreAndPostImages` for a collection using `db.createCollection()`, `create`, or `collMod`.

[[mongodb-in-the-cloud]]
=== MongoDB in the Cloud

You can use the {prodname} connector for MongoDB with https://www.mongodb.com/atlas/database[MongoDB Atlas].
Note that MongoDB Atlas only supports secure connections via SSL, i.e. the xref:mongodb-property-mongodb-ssl-enabled[`+mongodb.ssl.enabled`] connector option _must_ be set to `true`.


[[mongodb-optimal-oplog-config]]
=== Optimal Oplog Config


The {prodname} MongoDB connector reads https://www.mongodb.com/docs/manual/changeStreams/[change streams] to obtain oplog data for a replica set.
Because the oplog is a fixed-sized, capped collection, if it exceeds its maximum configured size, it begins to overwrite its oldest entries.
If the connector is stopped for any reason, when it restarts, it attempts to resume streaming from the last oplog stream position.
However, if last stream position was removed from the oplog, depending on the value specified in the connector's xref:mongodb-property-snapshot-mode[`snapshot.mode`] property, the connector might fail to start, reporting an xref:connector-error-invalid-resume-token[invalid resume token error].
In the event of a failure, you must create a new connector to enable {prodname} to continue capturing records from the database.
For more information, see xref:debezium-mongodb-connector-is-stopped-for-a-long-interval[Connector fails after it is stopped for a long interval if snapshot.mode is set to initial].

To ensure that the oplog retains the offset values that {prodname} requires to resume streaming, you can use either of the following approaches:

* https://www.mongodb.com/docs/manual/core/replica-set-oplog/[Increase the size of the oplog].
Based on your typical workloads, set the oplog size to a value that is greater than the peak number of oplog entries per hour.

* https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size/[Increase the minimum number of hours that an oplog entry is retained] (MongoDB 4.4 and greater).
This setting is time-based, such that entries in the last _n_ hours are guaranteed to be available even if the oplog reaches its maximum configured size.
Although this is generally the preferred option, for clusters with high workloads that are nearing capacity, specify the maximum oplog size.

To help prevent failures that are related to missing oplog entries, it's important to track metrics that report replication behavior, and to optimize the oplog size to support {prodname}.
In particular, you should monitor the values of Oplog GB/Hour and Replication Oplog Window.
If {prodname} is offline for an interval that exceeds the value of the replication oplog window, and the primary oplog grows faster than {prodname} can consume entries, a connector failure can result.

For information about how to monitor these metrics, see https://www.mongodb.com/basics/how-to-monitor-mongodb-and-what-metrics-to-monitor#mongodb-replication-metrics[the MongoDB documentation].

It's best to set the maximum oplog size to a value that is based on the anticipated hourly growth of the oplog (https://www.mongodb.com/basics/how-to-monitor-mongodb-and-what-metrics-to-monitor#oplog-gbhour[Oplog GB/Hour]), multiplied by the time that might be required to address a {prodname} failure.

That is,

`_Oplog GB/Hour_` X  `_average reaction time to {prodname} failure_`

For example, if the oplog size limit is set to 1GB, and the oplog grows by 3GB per hour, oplog entries are cleared three times per hour.
If {prodname} were to fail during this time, its last oplog position is likely to be removed.

If the oplog grows at the rate of 3GB/hour, and {prodname} is offline for two hours, you would thus set the oplog size to 3GB/hour X 2 hours, or 6GB.

// Type: assembly
// ModuleID: deployment-of-debezium-mongodb-connectors
// Title: Deployment of {prodname} MongoDB connectors
[[mongodb-deploying-a-connector]]
== Deployment

To deploy a {prodname} MongoDB connector, you install the {prodname} MongoDB connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect.

.Prerequisites
* link:https://zookeeper.apache.org/[Apache Zookeeper], link:http://kafka.apache.org/[Apache Kafka], and link:{link-kafka-docs}.html#connect[Kafka Connect] are installed.
* MongoDB is installed and is xref:setting-up-mongodb[set up to work with the {prodname} connector].

.Procedure
. Download the
https://repo1.maven.org/maven2/io/debezium/debezium-connector-mongodb/{debezium-version}/debezium-connector-mongodb-{debezium-version}-plugin.tar.gz[connector's plug-in archive],
. Extract the JAR files into your Kafka Connect environment.
. Add the directory with the JAR files to {link-kafka-docs}/#connectconfigs[Kafka Connect's `plugin.path`].
. Restart your Kafka Connect process to pick up the new JAR files.

If you are working with immutable containers, see link:https://quay.io/organization/debezium[{prodname}'s Container images] for Apache Zookeeper, Apache Kafka, and Kafka Connect with the MongoDB connector already installed and ready to run.

You can also xref:operations/openshift.adoc[run {prodname} on Kubernetes and OpenShift].

The {prodname} xref:tutorial.adoc[tutorial] walks you through using these images, and this is a great way to learn about {prodname}.


[[mongodb-example-configuration]]
=== MongoDB connector configuration example

Following is an example of the configuration for a connector instance that captures data from a MongoDB replica set `rs0` at port 27017 on 192.168.99.100, which we logically name `fullfillment`.
Typically, you configure the {prodname} MongoDB connector in a JSON file by setting the configuration properties that are available for the connector.

You can choose to produce events for a particular MongoDB replica set or sharded cluster.
Optionally, you can filter out collections that are not needed.

[source,json]
----
{
  "name": "inventory-connector", // <1>
  "config": {
    "connector.class": "io.debezium.connector.mongodb.MongoDbConnector", // <2>
    "mongodb.connection.string": "mongodb://192.168.99.100:27017/?replicaSet=rs0", // <3>
    "topic.prefix": "fullfillment", // <4>
    "collection.include.list": "inventory[.]*" // <5>
  }
}
----
<1> The name of our connector when we register it with a Kafka Connect service.
<2> The name of the MongoDB connector class.
<3> The connection string to use to connect to the MongoDB replica set.
<4> The _logical name_ of the MongoDB replica set, which forms a namespace for generated events and is used in all the names of the Kafka topics to which the connector writes, the Kafka Connect schema names, and the namespaces of the corresponding Avro schema when the Avro converter is used.
<5> A list of regular expressions that match the collection namespaces (for example, <dbName>.<collectionName>) of all collections to be monitored. This is optional.


For the complete list of the configuration properties that you can set for the {prodname} MongoDB connector,
see xref:mongodb-connector-properties[MongoDB connector configuration properties].

You can send this configuration with a `POST` command to a running Kafka Connect service.
The service records the configuration and starts one connector task that performs the following actions:

* Connects to the MongoDB replica set or sharded cluster.
* Assigns tasks for each replica set.
* Performs a snapshot, if necessary.
* Reads the change stream.
* Streams change event records to Kafka topics.

[[mongodb-adding-connector-configuration]]
=== Adding connector configuration

To start running a {prodname} MongoDB connector, create a connector configuration, and add the configuration to your Kafka Connect cluster.

.Prerequisites

* xref:setting-up-mongodb[MongoDB is set up to work with a {prodname} connector].
* The {prodname} MongoDB connector is installed.

.Procedure

. Create a configuration for the MongoDB connector.

. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster.

.Results
After the connector starts, it completes the following actions:

* xref:mongodb-performing-a-snapshot[Performs a consistent snapshot] of the collections in your MongoDB replica sets.
* Reads the change streams for the replica sets.
* Produces change events for every inserted, updated, and deleted document.
* Streams change event records to Kafka topics.


// Type: reference
// Title: Descriptions of {prodname} MongoDB connector configuration properties
[[mongodb-connector-properties]]
=== Connector properties

The {prodname} MongoDB connector has numerous configuration properties that you can use to achieve the right connector behavior for your application.
Many properties have default values. Information about the properties is organized as follows:

* xref:debezium-mongodb-connector-required-configuration-properties[Required {prodname} MongoDB connector configuration properties]
* xref:debezium-mongodb-connector-advanced-configuration-properties[Advanced {prodname} MongoDB connector configuration properties]

The following configuration properties are _required_ unless a default value is available.

[id="debezium-mongodb-connector-required-configuration-properties"]
.Required {prodname} MongoDB connector configuration properties
[cols="30%a,25%a,45%a",options="header"]
|===
|Property |Default |Description

|[[mongodb-property-allow-offset-invalidation]]<<mongodb-property-allow-offset-invalidation, `+internal.mongodb.allow.offset.invalidation+`>>
|false
|Set this property to `true` to enable the connector to invalidate and xref:mongodb-offset-consolidation[consolidate] shard-specific offsets that were recorded by earlier connector versions.

[WARNING]
====

This property permits you to modify the current default behavior.
The property is subject to removal in a future release if the default behavior changes to permit the connector to automatically invalidate and consolidate offsets that are recorded by earlier connector versions.
====

|[[mongodb-property-name]]<<mongodb-property-name, `+name+`>>
|No default
|Unique name for the connector. Attempting to register again with the same name will fail. (This property is required by all Kafka Connect connectors.)

|[[mongodb-property-connector-class]]<<mongodb-property-connector-class, `+connector.class+`>>
|No default
|The name of the Java class for the connector. Always use a value of `io.debezium.connector.mongodb.MongoDbConnector` for the MongoDB connector.

|[[mongodb-property-mongodb-connection-string]]<<mongodb-property-mongodb-connection-string, `+mongodb.connection.string+`>>
|No default
|Specifies a https://www.mongodb.com/docs/manual/reference/connection-string/[connection string] that the connector uses to connect to a MongoDB replica set.
This property replaces the `mongodb.hosts` property that was available in previous versions of the MongoDB connector. +

|[[mongodb-property-topic-prefix]]<<mongodb-property-topic-prefix, `+topic.prefix+`>>
|No default
|A unique name that identifies the connector and/or MongoDB replica set or sharded cluster that this connector monitors.
Each server should be monitored by at most one {prodname} connector, since this server name prefixes all persisted Kafka topics emanating from the MongoDB replica set or cluster.
Use only alphanumeric characters, hyphens, dots and underscores to form the name.
The logical name should be unique across all other connectors, because the name is used as the prefix in naming the Kafka topics that receive records from this connector. +
 +
[WARNING]
====
Do not change the value of this property.
If you change the name value, after a restart, instead of continuing to emit events to the original topics, the connector emits subsequent events to topics whose names are based on the new value.
====

|[[mongodb-property-mongodb-authentication-class]]<<mongodb-property-mongodb-authentication-class, `+mongodb.authentication.class+`>>
|_DefaultMongoDbAuthProvider_
|A full Java class name that is an implementation of the io.debezium.connector.mongodb.connection.MongoDbAuthProvider interface.
This class handles setting the credentials on the MongoDB connection (called on each app boot).
Default behavior uses the xref:mongodb-property-mongodb-user[`mongodb.user`], xref:mongodb-property-mongodb-password[`mongodb.password`], and xref:mongodb-property-mongodb-authsource[`mongodb.authsource`] properties according to each of their documentation,
but other implementations may use them differently or ignore them altogether.
Note that any setting in xref:mongodb-property-mongodb-connection-string[`mongodb.connection.string`] will override settings set by this class

|[[mongodb-property-mongodb-user]]<<mongodb-property-mongodb-user, `+mongodb.user+`>>
|No default
|When using default xref:mongodb-property-mongodb-authentication-class[`mongodb.authentication.class`]:
Name of the database user to be used when connecting to MongoDB. This is required only when MongoDB is configured to use authentication.

|[[mongodb-property-mongodb-password]]<<mongodb-property-mongodb-password, `+mongodb.password+`>>
|No default
|When using default xref:mongodb-property-mongodb-authentication-class[`mongodb.authentication.class`]:
Password to be used when connecting to MongoDB. This is required only when MongoDB is configured to use authentication.

|[[mongodb-property-mongodb-authsource]]<<mongodb-property-mongodb-authsource, `+mongodb.authsource+`>>
|`admin`
|When using default xref:mongodb-property-mongodb-authentication-class[`mongodb.authentication.class`]:
Database (authentication source) containing MongoDB credentials. This is required only when MongoDB is configured to use authentication with another authentication database than `admin`.

|[[mongodb-property-mongodb-ssl-enabled]]<<mongodb-property-mongodb-ssl-enabled, `+mongodb.ssl.enabled+`>>
|`false`
|Connector will use SSL to connect to MongoDB instances.

|[[mongodb-property-mongodb-ssl-invalid-hostname-allowed]]<<mongodb-property-mongodb-ssl-invalid-hostname-allowed, `+mongodb.ssl.invalid.hostname.allowed+`>>
|`false`
|When SSL is enabled this setting controls whether strict hostname checking is disabled during connection phase. If `true` the connection will not prevent man-in-the-middle attacks.

|[[mongodb-property-filters-match-mode]]<<mongodb-property-filters-match-mode, `+filters.match.mode+`>>
|regex
|The mode used to match events based on included/excluded database and collection names.
Set the property to one of the following values:

`regex`::
Database and collection includes/excludes are evaluated as comma-separated list of regular expressions.

`literal`::
Database and collection includes/excludes are evaluated as comma-separated list of string literals. Whitespace characters surrounding these literals are stripped.

|[[mongodb-property-database-include-list]]<<mongodb-property-database-include-list, `+database.include.list+`>>
|_empty string_
|An optional comma-separated list of regular expressions or literals that match database names to be monitored.
By default, all databases are monitored. +
When `database.include.list` is set, the connector monitors only the databases that the property specifies.
Other databases are excluded from monitoring.

To match the name of a database, {prodname} performs one of the following actions based on the value of xref:mongodb-property-filters-match-mode[`filters.match.mode`] property

- applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the database; it does not match substrings that might be present in a database name.
- compares the literals that you specify with the entire name string of the database +


If you include this property in the configuration, do not also set the `database.exclude.list` property.

|[[mongodb-property-database-exclude-list]]<<mongodb-property-database-exclude-list, `+database.exclude.list+`>>
|_empty string_
|An optional comma-separated list of regular expressions or literals that match database names to be excluded from monitoring.
When `database.exclude.list` is set, the connector monitors every database except the ones that the property specifies.

To match the name of a database, {prodname} performs one of the following actions based on the value of xref:mongodb-property-filters-match-mode[`filters.match.mode`] property

- applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the database; it does not match substrings that might be present in a database name.
- compares the literals that you specify with the entire name string of the database +

If you include this property in the configuration, do not set the `database.include.list` property.

|[[mongodb-property-collection-include-list]]<<mongodb-property-collection-include-list, `+collection.include.list+`>>
|_empty string_
|An optional comma-separated list of regular expressions or literals that match fully-qualified namespaces for MongoDB collections to be monitored.
By default, the connector monitors all collections except those in the `local` and `admin` databases.
When `collection.include.list` is set, the connector monitors only the collections that the property specifies.
Other collections are excluded from monitoring.
Collection identifiers are of the form _databaseName_._collectionName_.

To match the name of a namespace, {prodname} performs one of the following actions based on the value of xref:mongodb-property-filters-match-mode[`filters.match.mode`] property

- applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the namespace; it does not match substrings in the name.
- compares the literals that you specify with the entire name string of the namespace +


If you include this property in the configuration, do not also set the `collection.exclude.list` property.

|[[mongodb-property-collection-exclude-list]]<<mongodb-property-collection-exclude-list, `+collection.exclude.list+`>>
|_empty string_
|An optional comma-separated list of regular expressions or literals that match fully-qualified namespaces for MongoDB collections to be excluded from monitoring.
When `collection.exclude.list` is set, the connector monitors every collection except the ones that the property specifies.
Collection identifiers are of the form _databaseName_._collectionName_. +

To match the name of a namespace, {prodname} performs one of the following actions based on the value of xref:mongodb-property-filters-match-mode[`filters.match.mode`] property

- applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the namespace; it does not match substrings that might be present in a database name.
- compares the literals that you specify with the entire name string of the namespace +

If you include this property in the configuration, do not set the `collection.include.list` property.

|[[mongodb-property-capture-mode]]<<mongodb-property-capture-mode, `+capture.mode+`>>
|`change_streams_update_full`
|Specifies the method that the connector uses to capture `update` event changes from a MongoDB server.
Set this property to one of the following values:

`change_streams`:: `update` event messages do not include the full document.
Messages do not include a field that represents the state of the document `before` the change.

`change_streams_update_full`:: `update` event messages include the full document.
Messages do not include a `before` field that represents the state of the document before the update.
The event message returns the full state of the document in the `after` field.
Set xref:mongodb-property-capture-mode-full-update-type[capture.mode.full.update.type] to specify how the connector fetches full documents from the database.
+
[NOTE]
====
In some situations, when `capture.mode` is configured to return full documents, the `updateDescription` and `after` fields of the update event message might report inconsistent values.
Such discrepancies can result after multiple updates are applied to a document in rapid succession.
The connector requests the full document from the MongoDB database only after it receives the update described in the event's `updateDescription` field.
If a later update modifies the source document before the connector can retrieve it from the database, the connector receives the document that is modified by this later update.
====

`change_streams_update_full_with_pre_image`::
`update` event event messages include the full document, and include a field that represents the state of the document `before` the change.
Set xref:mongodb-property-capture-mode-full-update-type[capture.mode.full.update.type] to specify how the connector fetches full documents from the database.

`change_streams_with_pre_image`::
`update` events do not include the full document, but include a field that represents the state of the document `before` the change.

|[[mongodb-property-capture-scope]]<<mongodb-property-capture-scope, `+capture.scope+`>>
|`deployment`
|Specifies the https://www.mongodb.com/docs/manual/changeStreams/#watch-a-collection--database--or-deployment[scope of the change streams] that the connector opens.
Set this property to one of the following values:

`deployment`:: Opens a change stream cursor for a deployment (either a replica set or a sharded cluster) to watch for changes to all non-system collections across all databases, except for `admin`, `local`, and `config`.

`database`:: Opens a change stream cursor for a single database to watch for changes to all of its non-system collections.
+
[WARNING]
====
To support {link-prefix}:{link-signalling}#[{prodname} signaling], if you set `capture.scope` to `database`, the xref:mongodb-property-signal-data-collection[signaling data collection] must reside in a database that is specified by the xref:mongodb-property-capture-target[`capture.target`] property.
====

`collection`:: Opens a change stream cursor for a single collection to watch for changes to that collection.
+
[NOTE]
====
This feature is currently in an incubating state.
The exact semantics, configuration options, and so forth are subject to change, based on the feedback that we receive.
====
+
[WARNING]
====
Setting the value of the `capture.scope` property to `collection` prevents the connector from using the default `source` {link-prefix}:{link-signalling}[signaling] channel.
Because the `source` channel must be enabled to permit connectors to process incremental snapshot signals -- even for signals are sent over the Kafka, JMX, or File channels -- the connector cannot perform incremental snapshots when `capture-scope` is set to `collection`.
====

|[[mongodb-property-capture-target]]<<mongodb-property-capture-target, `+capture.target+`>>
|
| Specifies the database that the connector monitors for changes.
This property applies only if the xref:mongodb-property-capture-scope[`capture.scope`] is set to `database`.

|[[mongodb-property-field-exclude-list]]<<mongodb-property-field-exclude-list, `+field.exclude.list+`>>
|_empty string_
|An optional comma-separated list of the fully-qualified names of fields that should be excluded from change event message values.
Fully-qualified names for fields are of the form _databaseName_._collectionName_._fieldName_._nestedFieldName_, where _databaseName_ and _collectionName_ may contain the wildcard (*) which matches any characters.

|[[mongodb-property-field-renames]]<<mongodb-property-field-renames, `+field.renames+`>>
|_empty string_
|An optional comma-separated list of the fully-qualified replacements of fields that should be used to rename fields in change event message values. Fully-qualified replacements for fields are of the form _databaseName_._collectionName_._fieldName_._nestedFieldName_:__newNestedFieldName__, where _databaseName_ and _collectionName_ may contain the wildcard (*) which matches any characters, the colon character (:) is used to determine rename mapping of field. The next field replacement is applied to the result of the previous field replacement in the list, so keep this in mind when renaming multiple fields that are in the same path.

|[[mongodb-property-tombstones-on-delete]]<<mongodb-property-tombstones-on-delete, `+tombstones.on.delete+`>>
|`true`
|Controls whether a _delete_ event is followed by a tombstone event. +
 +
`true` - a delete operation is represented by a _delete_ event and a subsequent tombstone event.  +
 +
`false` - only a _delete_ event is emitted. +
 +
After a source record is deleted, emitting a tombstone event (the default behavior) allows Kafka to completely delete all events that pertain to the key of the deleted row in case {link-kafka-docs}/#compaction[log compaction] is enabled for the topic.

|[[mongodb-property-schema-name-adjustment-mode]]<<mongodb-property-schema-name-adjustment-mode,`+schema.name.adjustment.mode+`>>
|none
|Specifies how schema names should be adjusted for compatibility with the message converter used by the connector. Possible settings:  +

* `none` does not apply any adjustment. +
* `avro` replaces the characters that cannot be used in the Avro type name with underscore. +
* `avro_unicode` replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java +

|[[mongodb-property-field-name-adjustment-mode]]<<mongodb-property-field-name-adjustment-mode,`+field.name.adjustment.mode+`>>
|none
|Specifies how field names should be adjusted for compatibility with the message converter used by the connector. Possible settings:  +

* `none` does not apply any adjustment. +
* `avro` replaces the characters that cannot be used in the Avro type name with underscore. +
* `avro_unicode` replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java +

See {link-prefix}:{link-avro-serialization}#avro-naming[Avro naming] for more details.
|===

The following _advanced_ configuration properties have good defaults that will work in most situations and therefore rarely need to be specified in the connector's configuration.

// Title: Advanced {prodname} MongoDB connector configuration properties
[id="debezium-mongodb-connector-advanced-configuration-properties"]
.{prodname} MongoDB connector advanced configuration properties
[cols="30%a,25%a,45%a",options="header"]
|===
|Property
|Default
|Description

|[[mongodb-property-capture-mode-full-update-type]]<<mongodb-property-capture-mode-full-update-type, `+capture.mode.full.update.type+`>>
|`lookup`
|Specifies how the connector looks up the full value of an updated document when the xref:mongodb-property-capture-mode[`capture.mode`] is set retrieve full documents.
The connector retrieves full documents when its `capture.mode` is set to one of the following options:

* `change_streams_update_full`
* `change_streams_update_full_with_pre-image`

To use this option with a MongoDB change streams collection, you must configure the collection to https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre--and-post-images[return document pre- and post-images].
Pre- and post-images for an operation are available only if the required configuration is in place before the operation occurs.

Set this property to one of the following values:

`lookup`:: The connector uses a separate lookup to fetch the updated full MongoDB document.

[WARNING]
====
If the lookup process fails to retrieve a document, it cannot populate the full document to the `after` state in the event payload.
In such a situation, the connector emits an event message that contains a `null` value in the `after` field.

Failed lookups can occur because a delete operation removed the document immediately after it was created, or because a change to the sharding key results in the document being moved to a different location.
Sharding key changes can result when you modify any of the properties that make up the key.
====
`post_image`:: The connector uses MongoDB post images to populate events with the full MongoDB document.
The database must be running MongoDB 6.0 or later to use this option.

|[[mongodb-property-max-batch-size]]<<mongodb-property-max-batch-size, `+max.batch.size+`>>
|`2048`
|Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector. Defaults to 2048.

|[[mongodb-property-max-queue-size]]<<mongodb-property-max-queue-size, `+max.queue.size+`>>
|`8192`
|Positive integer value that specifies the maximum number of records that the blocking queue can hold.
When {prodname} reads events streamed from the database, it places the events in the blocking queue before it writes them to Kafka.
The blocking queue can provide backpressure for reading change events from the database
in cases where the connector ingests messages faster than it can write them to Kafka, or when Kafka becomes unavailable.
Events that are held in the queue are disregarded when the connector periodically records offsets.
Always set the value of `max.queue.size` to be larger than the value of xref:{context}-property-max-batch-size[`max.batch.size`].

|[[mongodb-property-max-queue-size-in-bytes]]<<mongodb-property-max-queue-size-in-bytes, `+max.queue.size.in.bytes+`>>
|`0`
|A long integer value that specifies the maximum volume of the blocking queue in bytes.
By default, volume limits are not specified for the blocking queue.
To specify the number of bytes that the queue can consume, set this property to a positive long value. +
If xref:mongodb-property-max-queue-size[`max.queue.size`] is also set, writing to the queue is blocked when the size of the queue reaches the limit specified by either property.
For example, if you set `max.queue.size=1000`, and `max.queue.size.in.bytes=5000`, writing to the queue is blocked after the queue contains 1000 records, or after the volume of the records in the queue reaches 5000 bytes.

|[[mongodb-property-poll-interval-ms]]<<mongodb-property-poll-interval-ms, `+poll.interval.ms+`>>
|`1000`
|Positive integer value that specifies the number of milliseconds the connector should wait during each iteration for new change events to appear. Defaults to 500 milliseconds, or 0.5 second.

|[[mongodb-property-connect-backoff-initial-delay-ms]]<<mongodb-property-connect-backoff-initial-delay-ms, `+connect.backoff.initial.delay.ms+`>>
|`1000`
|Positive integer value that specifies the initial delay when trying to reconnect to a primary after the first failed connection attempt or when no primary is available. Defaults to 1 second (1000 ms).

|[[mongodb-property-connect-backoff-max-delay-ms]]<<mongodb-property-connect-backoff-max-delay-ms, `+connect.backoff.max.delay.ms+`>>
|`1000`
|Positive integer value that specifies the maximum delay when trying to reconnect to a primary after repeated failed connection attempts or when no primary is available. Defaults to 120 seconds (120,000 ms).

|[[mongodb-property-connect-max-attempts]]<<mongodb-property-connect-max-attempts, `+connect.max.attempts+`>>
|`16`
|Positive integer value that specifies the maximum number of failed connection attempts to a replica set primary before an exception occurs and task is aborted. Defaults to 16, which with the defaults for `connect.backoff.initial.delay.ms` and `connect.backoff.max.delay.ms` results in just over 20 minutes of attempts before failing.

|[[mongodb-property-source-struct-version]]<<mongodb-property-source-struct-version, `+source.struct.version+`>>
|v2
|Schema version for the `source` block in CDC events. {prodname} 0.10 introduced a few breaking +
changes to the structure of the `source` block in order to unify the exposed structure across
all the connectors. +
By setting this option to `v1` the structure used in earlier versions can be produced.
Note that this setting is not recommended and is planned for removal in a future {prodname} version.

|[[mongodb-property-heartbeat-interval-ms]]<<mongodb-property-heartbeat-interval-ms, `+heartbeat.interval.ms+`>>
|`0`
|Controls how frequently heartbeat messages are sent. +
This property contains an interval in milliseconds that defines how frequently the connector sends messages into a heartbeat topic.
This can be used to monitor whether the connector is still receiving change events from the database.
You also should leverage heartbeat messages in cases where only records in non-captured collections are changed for a longer period of time.
In such situation the connector would proceed to read the oplog/change stream from the database but never emit any change messages into Kafka,
which in turn means that no offset updates are committed to Kafka.
This will cause the oplog files to be rotated out but connector will not notice it so on restart some events are no longer available which leads to the need of re-execution of the initial snapshot.

Set this parameter to `0` to not send heartbeat messages at all. +
Disabled by default.

|[[mongodb-property-skipped-operations]]<<mongodb-property-skipped-operations, `+skipped.operations+`>>
|`t`
|A comma-separated list of operation types that will be skipped during streaming.
The operations include: `c` for inserts/create, `u` for updates/replace, `d` for deletes, `t` for truncates, and `none` to not skip any aforementioned operations.
By default, for consistency with other Debezium connectors, truncate operations are skipped (not emitted by this connector). However, since MongoDB https://www.mongodb.com/docs/manual/reference/change-events/#operation-types[does not support] truncate change events, this is effectively the same as specifying `none`.

|[[mongodb-property-snapshot-collection-filter-overrides]]<<mongodb-property-snapshot-collection-filter-overrides, `+snapshot.collection.filter.overrides+`>>
|No default
| Controls which collection items are included in snapshot. This property affects snapshots only. Specify a comma-separated list of collection names in the form _databaseName.collectionName_.

For each collection that you specify, also specify another configuration property: `snapshot.collection.filter.overrides._databaseName_._collectionName_`. For example, the name of the other configuration property might be: `snapshot.collection.filter.overrides.customers.orders`. Set this property to a valid filter expression that retrieves only the items that you want in the snapshot. When the connector performs a snapshot, it retrieves only the items that matches the filter expression.

|[[mongodb-property-snapshot-delay-ms]]<<mongodb-property-snapshot-delay-ms, `+snapshot.delay.ms+`>>
|No default
|An interval in milliseconds that the connector should wait before taking a snapshot after starting up; +
Can be used to avoid snapshot interruptions when starting multiple connectors in a cluster, which may cause re-balancing of connectors.

|[[mongodb-property-streaming-delay-ms]]<<mongodb-property-streaming-delay-ms, `+streaming.delay.ms+`>>
|0
|Specifies the time, in milliseconds, that the connector delays the start of the streaming process after it completes a snapshot.
Setting a delay interval helps to prevent the connector from restarting snapshots in the event that a failure occurs immediately after the snapshot completes, but before the streaming process begins.
Set a delay value that is higher than the value of the {link-kafka-docs}/#connectconfigs_offset.flush.interval.ms[`offset.flush.interval.ms`] property that is set for the Kafka Connect worker.

|[[mongodb-property-snapshot-fetch-size]]<<mongodb-property-snapshot-fetch-size, `+snapshot.fetch.size+`>>
|`0`
|Specifies the maximum number of documents that should be read in one go from each collection while taking a snapshot.
The connector will read the collection contents in multiple batches of this size. +
Defaults to 0, which indicates that the server chooses an appropriate fetch size.

|[[mongodb-property-snapshot-include-collection-list]]<<mongodb-property-snapshot-include-collection-list, `+snapshot.include.collection.list+`>>
| All collections specified in `collection.include.list`
|An optional, comma-separated list of regular expressions that match the fully-qualified names (`_<databaseName>_._<collectionName>_`) of the schemas that you want to include in a snapshot.
The specified items must be named in the connectors's xref:mongodb-property-collection-include-list[`collection.include.list`] property.
This property takes effect only if the connector's xref:mongodb-property-snapshot-mode[`snapshot.mode`] property is set to a value other than `never`. +
This property does not affect the behavior of incremental snapshots. +

To match the name of a schema, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the schema; it does not match substrings that might be present in a schema name.

|[[mongodb-property-snapshot-max-threads]]<<mongodb-property-snapshot-max-threads, `+snapshot.max.threads+`>>
|`1`
|Positive integer value that specifies the maximum number of threads used to perform an intial sync of the collections in a replica set. Defaults to 1.

|[[mongodb-property-snapshot-mode]]<<mongodb-property-snapshot-mode, `+snapshot.mode+`>>
|_initial_
|Specifies the criteria for performing a snapshot when the connector starts.
Set the property to one of the following values:

`always`:: The connector performs a snapshot every time that it starts.
The snapshot includes the structure and data of the captured tables.
Specify this value to populate topics with a complete representation of the data from the captured tables every time that the connector starts.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

`initial`:: When the connector starts, it performs an initial database snapshot.
//as described in the xref:default-workflow-for-performing-an-initial-snapshot[default workflow for creating an initial snapshot].
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

`initial_only`:: The connector performs a database a snapshot only when no offsets have been recorded for the logical server name.
After the snapshot completes, the connector stops.
It does not transition to streaming event records for subsequent database changes.

`never`:: Deprecated, see `no_data`.

`no_data`:: The connector runs a snapshot that captures the structure of all relevant tables,
//, performing all the steps described in the xref:default-workflow-for-performing-an-initial-snapshot[default snapshot workflow], except that
but it does not create `READ` events to represent the data set at the point of the connector's start-up.
// (Step 7.b).

`when_needed`:: After the connector starts, it performs a snapshot only if it detects one of the following circumstances:

* It cannot detect any topic offsets.
* A previously recorded offset specifies a log position that is not available on the server.

`configuration_based`:: With this option, you control snapshot behavior through a set of connector properties that have the prefix 'snapshot.mode.configuration.based'.


`custom`:: The `custom` snapshot mode lets you inject your own implementation of the `io.debezium.spi.snapshot.Snapshotter` interface.
Set the `snapshot.mode.custom.name` configuration property to the name provided by the `name()` method of your implementation.

For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[mongodb-property-snapshot-mode-configuration-based-snapshot-data]]<<mongodb-property-configuration-based-snapshot-data, `+snapshot.mode.configuration.based.snapshot.data+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table data when it performs a snapshot.

|[[mongodb-property-snapshot-mode-configuration-based-snapshot-schema]]<<mongodb-property-configuration-based-snapshot-schema, `+snapshot.mode.configuration.based.snapshot.schema+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes the table schema when it performs a snapshot.

|[[mongodb-property-snapshot-mode-configuration-based-start-stream]]<<mongodb-property-configuration-based-start-stream, `+snapshot.mode.configuration.based.start.stream+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector begins to stream change events after a snapshot completes.

|[[mongodb-property-snapshot-mode-configuration-based-snapshot-on-schema-error]]<<mongodb-property-configuration-based-snapshot-on-schema-error, `+snapshot.mode.configuration.based.snapshot.on.schema.error+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table schema in a snapshot if the schema history topic is not available.

|[[mongodb-property-snapshot-mode-configuration-based-snapshot-on-data-error]]<<mongodb-property-configuration-based-snapshot-on-data-error, `+snapshot.mode.configuration.based.snapshot.on.data.error+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, this property specifies whether the connector attempts to snapshot table data if it does not find the last committed offset in the transaction log. +
Set the value to `true` to instruct the connector to perform a new snapshot.

|[[mongodb-property-snapshot-mode-custom-name]]<<mongodb-property-snapshot-mode-custom-name, `+snapshot.mode.custom.name+`>>
|No default
|If `snapshot.mode` is set to `custom`, use this setting to specify the name of the custom implementation that is provided in the `name()` method that is defined in the 'io.debezium.spi.snapshot.Snapshotter' interface.
After a connector restart, {prodname} calls the specified custom implementation to determine whether to perform a snapshot.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[mongodb-property-provide-transaction-metadata]]<<mongodb-property-provide-transaction-metadata, `+provide.transaction.metadata+`>>
|`false`
|When set to `true` {prodname} generates events with transaction boundaries and enriches data events envelope with transaction metadata.

See xref:mongodb-transaction-metadata[Transaction Metadata] for additional details.

|[[mongodb-property-retriable-restart-connector-wait-ms]]<<mongodb-property-retriable-restart-connector-wait-ms, `+retriable.restart.connector.wait.ms+`>>
|10000 (10 seconds)
|The number of milliseconds to wait before restarting a connector after a retriable error occurs.

|[[mongodb-property-mongodb-poll-interval-ms]]<<mongodb-property-mongodb-poll-interval-ms, `+mongodb.poll.interval.ms+`>>
|`30000`
|The interval in which the connector polls for new, removed, or changed replica sets.

|[[mongodb-property-mongodb-connect-timeout-ms]]<<mongodb-property-mongodb-connect-timeout-ms, `+mongodb.connect.timeout.ms+`>>
|10000 (10 seconds)
|The number of milliseconds the driver will wait before a new connection attempt is aborted.

|[[mongodb-property-mongodb-heartbeat-frequency-ms]]<<mongodb-property-mongodb-heartbeat-frequency-ms, `+mongodb.heartbeat.frequency.ms+`>>
|10000 (10 seconds)
|The frequency that the cluster monitor attempts to reach each server.

|[[mongodb-property-mongodb-socket-timeout-ms]]<<mongodb-property-mongodb-socket-timeout-ms, `+mongodb.socket.timeout.ms+`>>
|0
|The number of milliseconds before a send/receive on the socket can take before a timeout occurs.
A value of `0` disables this behavior.

|[[mongodb-property-mongodb-server-selection-timeout-ms]]<<mongodb-property-mongodb-server-selection-timeout-ms, `+mongodb.server.selection.timeout.ms+`>>
|30000 (30 seconds)
|The number of milliseconds the driver will wait to select a server before it times out and throws an error.

|[[mongodb-property-cursor-pipeline]]<<mongodb-property-cursor-pipeline, `+cursor.pipeline+`>>
|No default
|When streaming changes, this setting applies processing to change stream events as part of the standard MongoDB aggregation stream pipeline. A pipeline is a MongoDB aggregation pipeline composed of instructions to the database to filter or transform data. This can be used customize the data that the connector consumes.
The value of this property must be an array of permitted https://www.mongodb.com/docs/manual/changeStreams/#modify-change-stream-output[aggregation pipeline stages] in JSON format.
Note that this is appended after the internal pipeline used to support the connector (e.g. filtering operation types, database names, collection names, etc.).

|[[mongodb-property-cursor-pipeline-order]]<<mongodb-property-cursor-pipeline-order, `+cursor.pipeline.order+`>>
|internal_first
|The order used to construct the effective MongoDB aggregation stream pipeline.
Set the property to one of the following values:

`internal_first`::
Internal stages defined by the connector are applied first. This means that only the events which ought to be captured by the connector are fed to the user defined stages (configured by setting `cursor.pipeline`).

`user_first`::
Stages defined by the 'cursor.pipeline' property are applied first. In this mode  all events, included those not captured by the connector, are fed to user defined pipeline stages. This mode can have negative performance impact if the value of `cursor.pipeline` contains complex operations.

`user_only`::
Stages defined by the 'cursor.pipeline' property will replace internal stages defined by the connector. This mode is **intended only for expert users** since  all events are processed only by user defined pipeline stages. **This mode can have negative impact on performance and overall functionality of the connector!**

|[[mongodb-property-cursor-oversize-handling-mode]]<<mongodb-property-cursor-oversize-handling-mode, `+cursor.oversize.handling.mode+`>>
|fail
|The strategy used to handle change events for documents exceeding specified BSON size.
Set the property to one of the following values:

`fail`::
The connector fails if the total size of change event exceed the maximum BSON size.

`skip`::
Any change events for documents exceeding the maximum (specified by the `cursor.oversize.skip.threshold` property) size will be ignored

`split`::
Change events exceeding the maximum BSON size will be split using the https://www.mongodb.com/docs/v6.0/reference/operator/aggregation/changeStreamSplitLargeEvent/[$changeStreamSplitLargeEvent] aggregation. This option requires **MongoDB 6.0.9 or newer**.

|[[mongodb-property-cursor-oversize-skip-threshold]]<<mongodb-property-cursor-oversize-skip-threshold, `+cursor.oversize.skip.threshold+`>>
|0
|The maximum allowed size **in bytes** of the stored document for which change events are processed. This includes both, the size before and after database operation, more specifically this limits the size of fullDocument and fullDocumentBeforeChange filed of MongoDB change events.

|[[mongodb-property-cursor-max-await-time-ms]]<<mongodb-property-cursor-max-await-time-ms, `+cursor.max.await.time.ms+`>>
|`0`
|Specifies the maximum number of milliseconds the oplog/change stream cursor will wait for the server to produce a result before causing an execution timeout exception.
A value of `0` indicates using the server/driver default wait timeout.

|[[mongodb-property-signal-data-collection]]<<mongodb-property-signal-data-collection, `+signal.data.collection+`>>
|No default
| Fully-qualified name of the data collection that is used to send {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[signals] to the connector.
Use the following format to specify the collection name: +
`_<databaseName>_._<collectionName>_` +

|[[mongodb-property-signal-enabled-channels]]<<mongodb-property-signal-enabled-channels, `+signal.enabled.channels+`>>
|source
| List of the signaling channel names that are enabled for the connector.
By default, the following channels are available:

* `source`
* `kafka`
* `file`
* `jmx`
Optionally, you can also implement a {link-prefix}:{link-signalling}#debezium-signaling-enabling-custom-signaling-channel[custom signaling channel].
|[[mongodb-property-notification-enabled-channels]]<<mongodb-property-notification-enabled-channels, `+notification.enabled.channels+`>>
|No default
| List of notification channel names that are enabled for the connector.
By default, the following channels are available:

* `sink`
* `log`
* `jmx`
Optionally, you can also implement a {link-prefix}:{link-notification}#debezium-notification-custom-channel[custom notification channel].
|[[mongodb-property-incremental-snapshot-chunk-size]]<<mongodb-property-incremental-snapshot-chunk-size, `+incremental.snapshot.chunk.size+`>>
|`1024`
|The maximum number of documents that the connector fetches and reads into memory during an incremental snapshot chunk.
Increasing the chunk size provides greater efficiency, because the snapshot runs fewer snapshot queries of a greater size.
However, larger chunk sizes also require more memory to buffer the snapshot data.
Adjust the chunk size to a value that provides the best performance in your environment. +


|[[mongodb-property-incremental-snapshot-watermarking-strategy]]<<mongodb-property-incremental-snapshot-watermarking-strategy, `+incremental.snapshot.watermarking.strategy+`>>
|`insert_insert`
|Specifies the watermarking mechanism that the connector uses during an incremental snapshot to deduplicate events that might be captured by an incremental snapshot and then recaptured after streaming resumes. +
You can specify one of the following options:

`insert_insert`:: When you send a signal to initiate an incremental snapshot, for every chunk that {prodname} reads during the snapshot, it writes an entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, {prodname} inserts a second entry that records the signal to close the window.
`insert_delete`:: When you send a signal to initiate an incremental snapshot, for every chunk that {prodname} reads, it writes a single entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, this entry is removed.
No entry is created for the signal to close the snapshot window.
Set this option to prevent rapid growth of the signaling data collection.

|[[mongodb-property-topic-naming-strategy]]<<mongodb-property-topic-naming-strategy, `topic.naming.strategy`>>
|`io.debezium.schema.DefaultTopicNamingStrategy`
|The name of the TopicNamingStrategy class that should be used to determine the topic name for data change, schema change, transaction, heartbeat event etc., defaults to `DefaultTopicNamingStrategy`.

|[[mongodb-property-topic-delimiter]]<<mongodb-property-topic-delimiter, `topic.delimiter`>>
|`.`
|Specify the delimiter for topic name, defaults to `.`.

|[[mongodb-property-topic-cache-size]]<<mongodb-property-topic-cache-size, `topic.cache.size`>>
|`10000`
|The size used for holding the topic names in bounded concurrent hash map. This cache will help to determine the topic name corresponding to a given data collection.

|[[mongodb-property-topic-heartbeat-prefix]]<<mongodb-property-topic-heartbeat-prefix, `+topic.heartbeat.prefix+`>>
|`__debezium-heartbeat`
|Controls the name of the topic to which the connector sends heartbeat messages. The topic name has this pattern: +
 +
_topic.heartbeat.prefix_._topic.prefix_ +
 +
For example, if the topic prefix is `fulfillment`, the default topic name is `__debezium-heartbeat.fulfillment`.

|[[mongodb-property-topic-transaction]]<<mongodb-property-topic-transaction, `topic.transaction`>>
|`transaction`
|Controls the name of the topic to which the connector sends transaction metadata messages. The topic name has this pattern: +
 +
_topic.prefix_._topic.transaction_ +
 +
For example, if the topic prefix is `fulfillment`, the default topic name is `fulfillment.transaction`.

|[[mongodb-property-custom-metric-tags]]<<mongodb-property-custom-metric-tags, `custom.metric.tags`>>
|`No default`
|Defines tags that customize MBean object names by adding metadata that provides contextual information.
Specify a comma-separated list of key-value pairs.
Each key represents a tag for the MBean object name, and the corresponding value represents a value for the key, for example,  +
`k1=v1,k2=v2`

The connector appends the specified tags to the base MBean object name.
Tags can help you to organize and categorize metrics data.
You can define tags to identify particular application instances, environments, regions, versions, and so forth.
For more information, see xref:customized-mbean-names[Customized MBean names].

|[[mongodb-property-errors-max-retires]]<<mongodb-property-errors-max-retires, `errors.max.retries`>>
|`-1`
|Specifies how the connector responds after an operation that results in a retriable error, such as a connection error. +
Set one of the following options:

`-1`:: No limit. The connector always restarts automatically, and retries the operation, regardless of the number of previous failures.

`0`:: Disabled. The connector fails immediately, and never retries the operation.
User intervention is required to restart the connector.

`> 0`:: The connector restarts automatically until it reaches the specified maximum number of retries.
After the next failure, the connector stops, and user intervention is required to restart it.

|===

[id="debezium-mongodb-connector-kafka-signals-configuration-properties"]
==== {prodname} connector Kafka signals configuration properties

:leveloffset: +1

{prodname} provides a set of `signal.*` properties that control how the connector interacts with the Kafka signals topic.

The following table describes the Kafka `signal` properties.

.Kafka signals configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-signal-kafka-topic]]<<{context}-property-signal-kafka-topic, `+signal.kafka.topic+`>>
|<topic.prefix>-signal
|The name of the Kafka topic that the connector monitors for ad hoc signals.
[NOTE]
====
If {link-prefix}:{link-topic-auto-creation}#topic-auto-create-config[automatic topic creation] is disabled, you must manually create the required signaling topic.
A signaling topic is required to preserve signal ordering.
The signaling topic must have a single partition.
====

|[[{context}-property-signal-kafka-groupId]]<<{context}-property-signal-kafka-groupId, `+signal.kafka.groupId+`>>
|kafka-signal
|The name of the group ID  that is used by Kafka consumers.

|[[{context}-property-signal-kafka-bootstrap-servers]]<<{context}-property-signal-kafka-bootstrap-servers, `+signal.kafka.bootstrap.servers+`>>
|No default
|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster.
Each pair references the Kafka cluster that is used by the {prodname} Kafka Connect process.

|[[{context}-property-signal-kafka-poll-timeout-ms]]<<{context}-property-signal-kafka-poll-timeout-ms, `+signal.kafka.poll.timeout.ms+`>>
|`100`
|An integer value that specifies the maximum number of milliseconds that the connector waits when polling signals.

|[[{context}-kafka-consumer-offset-commit-enabled]]<<{context}-kafka-consumer-offset-commit-enabled, `+kafka.consumer.offset.commit.enabled+`>>
|`false`
|Enable the offset commit for the signal topic in order to guarantee At-Least-Once delivery. If disabled, only signals received when the consumer is up&running are processed. Any signals received when the consumer is down are lost.

|===

[id="debezium-{context}-connector-pass-through-signals-kafka-consumer-configuration-properties"]
=== {prodname} connector pass-through signals Kafka consumer client configuration properties

The {prodname} connector provides for pass-through configuration of the signals Kafka consumer.
Pass-through signals properties begin with the prefix `signals.consumer.*`.
For example, the connector passes properties such as `signal.consumer.security.protocol=SSL` to the Kafka consumer.

{prodname} strips the prefixes from the properties before it passes the properties to the Kafka signals consumer.

:leveloffset: 1

[id="debezium-mongodb-connector-kafka-notifications-configuration-properties"]
==== {prodname} connector sink notifications configuration properties

:leveloffset: +1

The following table describes the `notification` properties.

.Sink notification configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-notification-sink-topic-name]]<<{context}-property-notification-sink-topic-name, `+notification.sink.topic.name+`>>
|No default
|The name of the topic that receives notifications from {prodname}.
This property is required when you configure the xref:{context}-property-notification-enabled-channels[`notification.enabled.channels`] property to include `sink` as one of the enabled notification channels.
|===

:leveloffset: 1

// Type: assembly
// ModuleID: monitoring-debezium-mongodb-connector-performance
// Title: Monitoring {prodname} MongoDB connector performance
[[mongodb-monitoring]]
== Monitoring

The {prodname} MongoDB connector has two metric types in addition to the built-in support for JMX metrics that Zookeeper, Kafka, and Kafka Connect have.

* xref:mongodb-snapshot-metrics[Snapshot metrics] provide information about connector operation while performing a snapshot.
* xref:mongodb-streaming-metrics[Streaming metrics] provide information about connector operation when the connector is capturing changes and streaming change event records.

The {link-prefix}:{link-debezium-monitoring}#monitoring-debezium[{prodname} monitoring documentation] provides details about how to expose these metrics by using JMX.

// Type: concept
// ModuleID: monitoring-debezium-mongodb-connectors-customized-mbean-names
// Title: Customized names for MongoDB connector snapshot and streaming MBean objects
=== Customized MBean names

:leveloffset: +1

{prodname} connectors expose metrics via the MBean name for the connector.
These metrics, which are specific to each connector instance, provide data about the behavior of the connector's snapshot, streaming, and schema history processes.

By default, when you deploy a correctly configured connector, {prodname} generates a unique MBean name for each of the different connector metrics.
To view the metrics for a connector process, you configure your observability stack to monitor its MBean.
But these default MBean names depend on the connector configuration; configuration changes can result in changes to the MBean names.
A change to the MBean name breaks the linkage between the connector instance and the MBean, disrupting monitoring activity.
In this scenario, you must reconfigure the observability stack to use the new MBean name if you want to resume monitoring.

To prevent monitoring disruptions that result from MBean name changes, you can configure custom metrics tags.
You configure custom metrics by adding the `custom.metric.tags` property to the connector configuration.
The property accepts key-value pairs in which each key represents a tag for the MBean object name, and the corresponding value represents the value of that tag.
For example: `k1=v1,k2=v2`.
{prodname} appends the specified tags to the MBean name of the connector.

After you configure the `custom.metric.tags` property for a connector, you can configure the observability stack to retrieve metrics associated with the specified tags.
The observability stack then uses the specified tags, rather than the mutable MBean names to uniquely identify connectors.
Later, if {prodname} redefines how it constructs MBean names, or if the `topic.prefix` in the connector configuration changes, metrics collection is uninterrupted,
because the metrics scrape task uses the specified tag patterns to identify the connector.

A further benefit of using custom tags, is that you can use tags that reflect the architecture of your data pipeline, so that metrics are organized in a way that suits you operational needs.
For example, you might specify tags with values that declare the type of connector activity, the application context, or the data source, for example, `db1-streaming-for-application-abc`.
If you specify multiple key-value pairs, all of the specified pairs are appended to the connector's MBean name.

The following example illustrates how tags modify the default MBean name.

.How custom tags modify the connector MBean name
=======
By default, the {connector-name} connector uses the following MBean name for streaming metrics:
 +
[source,subs="attributes+,quotes"]
----
debezium.{context}:type=connector-metrics,context=streaming,server=_<topic.prefix>_
----

If you set the value of `custom.metric.tags` to `database=salesdb-streaming,table=inventory`, {prodname} generates the following custom MBean name:

[source,subs="attributes+,quotes"]
----
debezium.{context}:type=connector-metrics,context=streaming,server=_<topic.prefix>_,database=salesdb-streaming,table=inventory
----
=======


:leveloffset: 1

// Type: reference
// ModuleID: monitoring-debezium-during-mongodb-snapshots
// Title: Monitoring {prodname} during MongoDB snapshots
[[mongodb-snapshot-metrics]]
=== Snapshot Metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=snapshot,server=_<topic.prefix>_,task=_<task.id>_`.

:leveloffset: 1

:leveloffset: +1

Snapshot metrics are not exposed unless a snapshot operation is active, or if a snapshot has occurred since the last connector start.

The following table lists the snapshot metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-snaps-metric-lastevent_{context}]]<<connectors-snaps-metric-lastevent_{context}, `LastEvent`>>
|`string`
|The last snapshot event that the connector has read.

|[[connectors-snaps-metric-millisecondssincelastevent_{context}]]<<connectors-snaps-metric-millisecondssincelastevent_{context}, `MilliSecondsSinceLastEvent`>>
|`long`
|The number of milliseconds since the connector has read and processed the most recent event.

|[[connectors-snaps-metric-totalnumberofeventsseen_{context}]]<<connectors-snaps-metric-totalnumberofeventsseen_{context}, `TotalNumberOfEventsSeen`>>
|`long`
|The total number of events that this connector has seen since last started or reset.

|[[connectors-snaps-metric-numberofeventsfiltered_{context}]]<<connectors-snaps-metric-numberofeventsfiltered_{context}, `NumberOfEventsFiltered`>>
|`long`
| The number of events that have been filtered by include/exclude list filtering rules configured on the connector.

|[[connectors-snaps-metric-capturedtables_{context}]]<<connectors-snaps-metric-capturedtables_{context}, `CapturedTables`>>
|`string[]`
|The list of tables that are captured by the connector.

|[[connectors-snaps-metric-queuetotalcapacity_{context}]]<<connectors-snaps-metric-queuetotalcapacity_{context}, `QueueTotalCapacity`>>
|`int`
|The length the queue used to pass events between the snapshotter and the main Kafka Connect loop.

|[[connectors-snaps-metric-queueremainingcapacity_{context}]]<<connectors-snaps-metric-queueremainingcapacity_{context}, `QueueRemainingCapacity`>>
|`int`
|The free capacity of the queue used to pass events between the snapshotter and the main Kafka Connect loop.

|[[connectors-snaps-metric-totaltablecount_{context}]]<<connectors-snaps-metric-totaltablecount_{context}, `TotalTableCount`>>
|`int`
|The total number of tables that are being included in the snapshot.

|[[connectors-snaps-metric-remainingtablecount_{context}]]<<connectors-snaps-metric-remainingtablecount_{context}, `RemainingTableCount`>>
|`int`
|The number of tables that the snapshot has yet to copy.

|[[connectors-snaps-metric-snapshotrunning_{context}]]<<connectors-snaps-metric-snapshotrunning_{context}, `SnapshotRunning`>>
|`boolean`
|Whether the snapshot was started.

|[[connectors-snaps-metric-snapshotpaused_{context}]]<<connectors-snaps-metric-snapshotpaused_{context}, `SnapshotPaused`>>
|`boolean`
|Whether the snapshot was paused.

|[[connectors-snaps-metric-snapshotaborted_{context}]]<<connectors-snaps-metric-snapshotaborted_{context}, `SnapshotAborted`>>
|`boolean`
|Whether the snapshot was aborted.

|[[connectors-snaps-metric-snapshotcompleted_{context}]]<<connectors-snaps-metric-snapshotcompleted_{context}, `SnapshotCompleted`>>
|`boolean`
|Whether the snapshot completed.

|[[connectors-snaps-metric-snapshotdurationinseconds_{context}]]<<connectors-snaps-metric-snapshotdurationinseconds_{context}, `SnapshotDurationInSeconds`>>
|`long`
|The total number of seconds that the snapshot has taken so far, even if not complete. Includes also time when snapshot was paused.

|[[connectors-snaps-metric-snapshotpauseddurationinseconds_{context}]]<<connectors-snaps-metric-snapshotpauseddurationinseconds_{context}, `SnapshotPausedDurationInSeconds`>>
|`long`
|The total number of seconds that the snapshot was paused. If the snapshot was paused several times, the paused time adds up.

|[[connectors-snaps-metric-rowsscanned_{context}]]<<connectors-snaps-metric-rowsscanned_{context}, `RowsScanned`>>
|`Map<String, Long>`
|Map containing the number of rows scanned for each table in the snapshot.
Tables are incrementally added to the Map during processing.
Updates every 10,000 rows scanned and upon completing a table.

|[[connectors-snaps-metric-maxqueuesizeinbytes_{context}]]<<connectors-snaps-metric-maxqueuesizeinbytes_{context}, `MaxQueueSizeInBytes`>>
|`long`
|The maximum buffer of the queue in bytes. This metric is available if xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`] is set to a positive long value.

|[[connectors-snaps-metric-currentqueuesizeinbytes_{context}]]<<connectors-snaps-metric-currentqueuesizeinbytes_{context}, `CurrentQueueSizeInBytes`>>
|`long`
|The current volume, in bytes, of records in the queue.

|===

:leveloffset: 1

The {prodname} MongoDB connector also provides the following custom snapshot metrics:

[cols="3,2,5",options="header"]
|===
|Attribute |Type |Description

|`NumberOfDisconnects`
|`long`
|Number of database disconnects.

|===

// Type: reference
// ModuleID: monitoring-debezium-mongodb-connector-record-streaming
// Title: Monitoring {prodname} MongoDB connector record streaming
[[mongodb-streaming-metrics]]
=== Streaming Metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=streaming,server=_<topic.prefix>_,task=_<task.id>_`.

:leveloffset: 1

:leveloffset: +1

The following table lists the streaming metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-strm-metric-lastevent_{context}]]<<connectors-strm-metric-lastevent_{context}, `LastEvent`>>
|`string`
|The last streaming event that the connector has read.

|[[connectors-strm-metric-millisecondssincelastevent_{context}]]<<connectors-strm-metric-millisecondssincelastevent_{context}, `MilliSecondsSinceLastEvent`>>
|`long`
|The number of milliseconds since the connector has read and processed the most recent event.

|[[connectors-strm-metric-totalnumberofeventsseen_{context}]]<<connectors-strm-metric-totalnumberofeventsseen_{context}, `TotalNumberOfEventsSeen`>>
|`long`
|The total number of data change events reported by the source database since the last connector start, or since a metrics reset.
Represents the data change workload for {prodname} to process.

|[[connectors-strm-metric-totalnumberofcreateeventsseen_{context}]]<<connectors-strm-metric-totalnumberofcreateeventsseen_{context}, `TotalNumberOfCreateEventsSeen`>>
|`long`
|The total number of create events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-totalnumberofupdateeventsseen_{context}]]<<connectors-strm-metric-totalnumberofupdateeventsseen_{context}, `TotalNumberOfUpdateEventsSeen`>>
|`long`
|The total number of update events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-totalnumberofdeleteeventsseen_{context}]]<<connectors-strm-metric-totalnumberofdeleteeventsseen_{context}, `TotalNumberOfDeleteEventsSeen`>>
|`long`
|The total number of delete events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-numberofeventsfiltered_{context}]]<<connectors-strm-metric-numberofeventsfiltered_{context}, `NumberOfEventsFiltered`>>
|`long`
|The number of events that have been filtered by include/exclude list filtering rules configured on the connector.

|[[connectors-strm-metric-capturedtables_{context}]]<<connectors-strm-metric-capturedtables_{context}, `CapturedTables`>>
|`string[]`
|The list of tables that are captured by the connector.

|[[connectors-strm-metric-queuetotalcapacity_{context}]]<<connectors-strm-metric-queuetotalcapacity_{context}, `QueueTotalCapacity`>>
|`int`
|The length the queue used to pass events between the streamer and the main Kafka Connect loop.

|[[connectors-strm-metric-queueremainingcapacity_{context}]]<<connectors-strm-metric-queueremainingcapacity_{context}, `QueueRemainingCapacity`>>
|`int`
|The free capacity of the queue used to pass events between the streamer and the main Kafka Connect loop.

|[[connectors-strm-metric-connected_{context}]]<<connectors-strm-metric-connected_{context}, `Connected`>>
|`boolean`
|Flag that denotes whether the connector is currently connected to the database server.

|[[connectors-strm-metric-millisecondsbehindsource_{context}]]<<connectors-strm-metric-millisecondsbehindsource_{context}, `MilliSecondsBehindSource`>>
|`long`
|The number of milliseconds between the last change event's timestamp and the connector processing it.
The values will incorporate any differences between the clocks on the machines where the database server and the connector are running.

|[[connectors-strm-metric-numberofcommittedtransactions_{context}]]<<connectors-strm-metric-numberofcommittedtransactions_{context}, `NumberOfCommittedTransactions`>>
|`long`
|The number of processed transactions that were committed.

|[[connectors-strm-metric-sourceeventposition_{context}]]<<connectors-strm-metric-sourceeventposition_{context}, `SourceEventPosition`>>
|`Map<String, String>`
|The coordinates of the last received event.

|[[connectors-strm-metric-lasttransactionid_{context}]]<<connectors-strm-metric-lasttransactionid_{context}, `LastTransactionId`>>
|`string`
|Transaction identifier of the last processed transaction.

|[[connectors-strm-metric-maxqueuesizeinbytes_{context}]]<<connectors-strm-metric-maxqueuesizeinbytes_{context}, `MaxQueueSizeInBytes`>>
|`long`
|The maximum buffer of the queue in bytes. This metric is available if xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`] is set to a positive long value.

|[[connectors-strm-metric-currentqueuesizeinbytes_{context}]]<<connectors-strm-metric-currentqueuesizeinbytes_{context}, `CurrentQueueSizeInBytes`>>
|`long`
|The current volume, in bytes, of records in the queue.

|===

The {prodname} {connector-name} connector also provides the following additional streaming metrics:

.Descriptions of additional {connector-name} streaming metrics
[cols="3,2,5",options="header"]
|===
|Attribute |Type |Description

|[[binlog-filename]]<<binlog-filename,`+BinlogFilename+`>>
|`string`
|The name of the binlog file that the connector has most recently read.

|[[binlog-position]]<<binlog-position,`+BinlogPosition+`>>
|`long`
|The most recent position (in bytes) within the binlog that the connector has read.

|[[is-gtid-mode-enabled]]<<is-gtid-mode-enabled,`+IsGtidModeEnabled+`>>
|`boolean`
|Flag that denotes whether the connector is currently tracking GTIDs from {connector-name} server.

|[[gtid-set]]<<gtid-set,`+GtidSet+`>>
|`string`
|The string representation of the most recent GTID set processed by the connector when reading the binlog.

|[[number-of-skipped-events]]<<number-of-skipped-events,`+NumberOfSkippedEvents+`>>
|`long`
|The number of events that have been skipped by the {connector-name} connector. Typically events are skipped due to a malformed or unparseable event from {connector-name}'s binlog.

|[[number-of-disconnects]]<<number-of-disconnects,`+NumberOfDisconnects+`>>
|`long`
|The number of disconnects by the {connector-name} connector.

|[[number-of-rolled-back-transactions]]<<number-of-rolled-back-transactions,`+NumberOfRolledBackTransactions+`>>
|`long`
|The number of processed transactions that were rolled back and not streamed.

|[[number-of-not-well-formed-transactions]]<<number-of-not-well-formed-transactions,`+NumberOfNotWellFormedTransactions+`>>
|`long`
|The number of transactions that have not conformed to the expected protocol of `BEGIN` + `COMMIT`/`ROLLBACK`. This value should be `0` under normal conditions.

|[[number-of-large-transactions]]<<number-of-large-transactions,`+NumberOfLargeTransactions+`>>
|`long`
|The number of transactions that have not fit into the look-ahead buffer. For optimal performance, this value should be significantly smaller than `NumberOfCommittedTransactions` and `NumberOfRolledBackTransactions`.

|===

:leveloffset: 1

The {prodname} MongoDB connector also provides the following custom streaming metrics:

[cols="3,2,5",options="header"]
|===
|Attribute |Type |Description

|`NumberOfDisconnects`
|`long`
|Number of database disconnects.

|`NumberOfPrimaryElections`
|`long`
|Number of primary node elections.

|===

// Type: concept
// ModuleID: how-debezium-mongodb-connectors-handle-faults-and-problems
// Title: How {prodname} MongoDB connectors handle faults and problems
[[mongodb-when-things-go-wrong]]
== MongoDB connector common issues

{prodname} is a distributed system that captures all changes in multiple upstream databases, and will never miss or lose an event.
When the system is operating normally and is managed carefully, then {prodname} provides _exactly once_ delivery of every change event.

If a fault occurs, the system does not lose any events.
However, while it is recovering from the fault, it might repeat some change events.
In such situations, {prodname}, like Kafka, provides _at least once_ delivery of change events.

The rest of this section describes how {prodname} handles various kinds of faults and problems.


[id="debezium-mongodb-connector-configuration-and-startup-errors"]
=== Configuration and startup errors

In the following situations, the connector fails when trying to start, reports an error or exception in the log, and stops running:

* The connector's configuration is invalid.
* The connector cannot successfully connect to MongoDB by using the specified connection parameters.

After a failure, the connector attempts to reconnect by using exponential backoff.
You can configure the maximum number of reconnection attempts.

In these cases, the error will have more details about the problem and possibly a suggested work around. The connector can be restarted when the configuration has been corrected or the MongoDB problem has been addressed.

[id="mongodb-becomes-unavailable-while-debezium-is-running"]
=== MongoDB becomes unavailable

Once the connector is running, if the primary node of any of the MongoDB replica sets become unavailable or unreachable, the connector will repeatedly attempt to reconnect to the primary node, using exponential backoff to prevent saturating the network or servers. If the primary remains unavailable after the configurable number of connection attempts, the connector will fail.

The attempts to reconnect are controlled by three properties:

* `connect.backoff.initial.delay.ms` - The delay before attempting to reconnect for the first time, with a default of 1 second (1000 milliseconds).
* `connect.backoff.max.delay.ms` - The maximum delay before attempting to reconnect, with a default of 120 seconds (120,000 milliseconds).
* `connect.max.attempts` - The maximum number of attempts before an error is produced, with a default of 16.

Each delay is double that of the prior delay, up to the maximum delay. Given the default values, the following table shows the delay for each failed connection attempt and the total accumulated time before failure.

[cols="30%a,30%a,40%a",options="header"]
|===
|Reconnection attempt number
|Delay before attempt, in seconds
|Total delay before attempt, in minutes and seconds

|1 |1 |00:01
|2 |2 |00:03
|3 |4 |00:07
|4 |8 |00:15
|5 |16 |00:31
|6 |32 |01:03
|7 |64 |02:07
|8 |120|04:07
|9 |120|06:07
|10 |120|08:07
|11 |120|10:07
|12 |120|12:07
|13 |120|14:07
|14 |120|16:07
|15 |120|18:07
|16 |120|20:07
|===

[id="connector-error-invalid-resume-token"]
=== Connector Unable to Start - InvalidResumeToken or ChangeStreamHistoryLost

A connector that is stopped for a long period fails to start, and reports the following exception:
----
Command failed with error 286 (ChangeStreamHistoryLost): 'PlanExecutor error during aggregation :: caused by :: Resume of change stream was not possible, as the resume point may no longer be in the oplog
----
The preceding exception indicates that the entry that corresponds to the connector's resume token is no longer present in the oplog.
Because the oplog no longer contains the last offset that the connector processed, the connector cannot resume streaming.

You can use either of the following options to recover from the failure:

* Delete the failed connector, and create a new connector with the same configuration but with a different connector name.

* Pause the connector and then remove offsets, or change the offset topic.

To help prevent failures related to missing resume tokens, xref:mongodb-optimal-oplog-config[optimize configuration of the oplog].

[id="debezium-mongodb-kafka-connect-process-stops-gracefully"]
=== Kafka Connect process stops gracefully

If Kafka Connect is being run in distributed mode, and a Kafka Connect process is stopped gracefully, then prior to shutdown of that processes Kafka Connect will migrate all of the process' connector tasks to another Kafka Connect process in that group, and the new connector tasks will pick up exactly where the prior tasks left off.
There is a short delay in processing while the connector tasks are stopped gracefully and restarted on the new processes.

If the group contains only one process and that process is stopped gracefully, then Kafka Connect will stop the connector and record the last offset for each replica set. Upon restart, the replica set tasks will continue exactly where they left off.

[id="debezium-mongodb-kafka-connect-process-crashes"]
=== Kafka Connect process crashes

If the Kafka Connector process stops unexpectedly, then any connector tasks it was running will terminate without recording their most recently-processed offsets.
When Kafka Connect is being run in distributed mode, it will restart those connector tasks on other processes.
However, the MongoDB connectors will resume from the last offset _recorded_ by the earlier processes, which means that the new replacement tasks may generate some of the same change events that were processed just prior to the crash.
The number of duplicate events depends on the offset flush period and the volume of data changes just before the crash.

[NOTE]
====
Because there is a chance that some events may be duplicated during a recovery from failure, consumers should always anticipate some events may be duplicated. {prodname} changes are idempotent, so a sequence of events always results in the same state.

{prodname} also includes with each change event message the source-specific information about the origin of the event, including the MongoDB event's unique transaction identifier (`h`) and timestamp (`sec` and `ord`). Consumers can keep track of other of these values to know whether it has already seen a particular event.
====

[id="debezium-mongodb-kafka-process-becomes-unavailable"]
=== Kafka becomes unavailable

As the connector generates change events, the Kafka Connect framework records those events in Kafka using the Kafka producer API. Kafka Connect will also periodically record the latest offset that appears in those change events, at a frequency that you have specified in the Kafka Connect worker configuration. If the Kafka brokers become unavailable, the Kafka Connect worker process running the connectors will simply repeatedly attempt to reconnect to the Kafka brokers. In other words, the connector tasks will simply pause until a connection can be reestablished, at which point the connectors will resume exactly where they left off.

[id="debezium-mongodb-connector-is-stopped-for-a-long-interval"]
=== Connector fails after it is stopped for a long interval if `snapshot.mode` is set to `initial`

If the connector is gracefully stopped, users might continue to perform operations on replica set members.
Changes that occur while the connector is offline continue to be recorded in MongoDB's oplog.
In most cases, after the connector is restarted, it reads the offset value in the oplog to determine the last operation that it streamed for each replica set, and then resumes streaming changes from that point.
After the restart, database operations that occurred while the connector was stopped are emitted to Kafka as usual, and after some time, the connector catches up with the database.
The amount of time required for the connector to catch up depends on the capabilities and performance of Kafka and the volume of changes that occurred in the database.

However, if the connector remains stopped for a long enough interval, it can occur that MongoDB purges the oplog during the time that the connector is inactive, resulting in the loss of information about the connector's last position.
After the connector restarts, it cannot resume streaming, because the oplog no longer contains the previous offset value that marks the last operation that the connector processed.
The connector also cannot perform a snapshot, as it typically would when the `snapshot.mode` property is set to `initial`, and no offset value is present.
In this case, a mismatch exists, because the oplog does not contain the value of the previous offset, but the offset value is present in the connector's internal Kafka offsets topic.
An error results and the connector fails.

To recover from the failure, delete the failed connector, and create a new connector with the same configuration but with a different connector name.
When you start the new connector, it performs a snapshot to ingest the state of database, and then resumes streaming.

[id="mongodb-crash-results-in-lost-commits"]
=== MongoDB loses writes

In certain failure situations, MongoDB can lose commits, which results in the MongoDB connector being unable to capture the lost changes.
For example, if the primary crashes suddenly after it applies a change and records the change to its oplog, the oplog might become unavailable before secondary nodes can read its contents.
As a result, the secondary node that is elected as the new primary node might be missing the most recent changes from its oplog.

At this time, there is no way to prevent this side effect in MongoDB.

:leveloffset!:
:leveloffset: +1

// Category: debezium-using
// Type: assembly
// ModuleID: debezium-connector-for-sql-server
[id="debezium-connector-for-sql-server"]
= {prodname} connector for SQL Server

:context: sqlserver
:data-collection: table
:database-port: 1433
:mbean-name: sql_server
:connector-file: {context}
:connector-class: SqlServer
:connector-name: SQL Server
:include-list-example: dbo.customers

:toc:
:toc-placement: macro
:linkattrs:
:icons: font
:source-highlighter: highlight.js

[NOTE]
====
Want to help us further hone and improve it? link:/docs/contribute/[Learn how].
====

toc::[]

The {prodname} SQL Server connector captures row-level changes that occur in the schemas of a SQL Server database.

For information about the SQL Server versions that are compatible with this connector, see the link:https://debezium.io/releases/[{prodname} release overview].


The first time that the {prodname} SQL Server connector connects to a SQL Server database or cluster, it takes a consistent snapshot of the schemas in the database.
After the initial snapshot is complete, the connector continuously captures row-level changes for `INSERT`, `UPDATE`, or `DELETE` operations that are committed to the SQL Server databases that are enabled for CDC.
The connector produces events for each data change operation, and streams them to Kafka topics.
The connector streams all of the events for a table to a dedicated Kafka topic.
Applications and services can then consume data change event records from that topic.


// Type: concept
// Title: Overview of {prodname} SQL Server connector
// ModuleID: overview-of-debezium-sql-server-connector
[[sqlserver-overview]]
== Overview

The {prodname} SQL Server connector is based on the https://docs.microsoft.com/en-us/sql/relational-databases/track-changes/about-change-data-capture-sql-server?view=sql-server-2017[change data capture]
feature that is available in https://blogs.msdn.microsoft.com/sqlreleaseservices/sql-server-2016-service-pack-1-sp1-released/[SQL Server 2016 Service Pack 1 (SP1) and later] Standard edition or Enterprise edition.
The SQL Server capture process monitors designated databases and tables, and stores the changes into specifically created _change tables_ that have stored procedure facades.

To enable the {prodname} SQL Server connector to capture change event records for database operations,
you must first enable change data capture on the SQL Server database.
CDC must be enabled on both the database and on each table that you want to capture.
After you set up CDC on the source database, the connector can capture row-level `INSERT`, `UPDATE`, and `DELETE` operations
that occur in the database.
The connector writes event records for each source table to a Kafka topic especially dedicated to that table.
One topic exists for each captured table.
Client applications read the Kafka topics for the database tables that they follow, and can respond to the row-level events they consume from those topics.

The first time that the connector connects to a SQL Server database or cluster, it takes a consistent snapshot of the schemas for all tables for which it is configured to capture changes,
and streams this state to Kafka.
After the snapshot is complete, the connector continuously captures subsequent row-level changes that occur.
By first establishing a consistent view of all of the data, the connector can continue reading without having lost any of the changes that were made while the snapshot was taking place.

The {prodname} SQL Server connector is tolerant of failures.
As the connector reads changes and produces events, it periodically records the position of events in the database log (_LSN / Log Sequence Number_).
If the connector stops for any reason (including communication failures, network problems, or crashes), after a restart the connector resumes reading the SQL Server _CDC_ tables from the last point that it read.

NOTE: Offsets are committed periodically.
They are not committed at the time that a change event occurs.
As a result, following an outage, duplicate events might be generated.

Fault tolerance also applies to snapshots.
That is, if the connector stops during a snapshot, the connector begins a new snapshot when it restarts.

// Type: assembly
// ModuleID: how-debezium-sql-server-connectors-work
// Title: How {prodname} SQL Server connectors work
[[how-the-sqlserver-connector-works]]
== How the SQL Server connector works

To optimally configure and run a {prodname} SQL Server connector, it is helpful to understand how the connector performs snapshots, streams change events, determines Kafka topic names, and uses metadata.


// Type: concept
// Title: How {prodname} SQL Server connectors perform database snapshots
// ModuleID: how-debezium-sql-server-connectors-perform-database-snapshots
[[sqlserver-snapshots]]
=== Snapshots

SQL Server CDC is not designed to store a complete history of database changes.
For the {prodname} SQL Server connector to establish a baseline for the current state of the database, it uses a process called _snapshotting_.
The initial snapshot captures the structure and data of the tables in the database.


// Type: concept
// ModuleID: default-workflow-that-the-sqlserver-connector-uses-to-perform-an-initial-snapshot
[[sqlserver-default-workflow-for-performing-an-initial-snapshot]]
==== Default workflow that the {prodname} SQL Server connector uses to perform an initial snapshot

The following workflow lists the steps that {prodname} takes to create a snapshot.
These steps describe the process for a snapshot when the xref:{context}-property-snapshot-mode[`snapshot.mode`] configuration property is set to its default value, which is `initial`.
You can customize the way that the connector creates snapshots by changing the value of the `snapshot.mode` property.
If you configure a different snapshot mode, the connector completes the snapshot by using a modified version of this workflow.

1.  Establish a connection to the database.

2.  Determine the tables to be captured.
   By default, the connector captures all non-system tables.
   To have the connector capture a subset of tables or table elements, you can set a number of `include` and `exclude` properties to filter the data, for example, xref:sqlserver-property-table-include-list[`table.include.list`] or xref:sqlserver-property-table-exclude-list[`table.exclude.list`].

3. Obtain a lock on the SQL Server tables for which CDC is enabled to prevent structural changes from occurring during creation of the snapshot.
   The level of the lock is determined by the xref:sqlserver-property-snapshot-isolation-mode[`snapshot.isolation.mode`] configuration property.

4. Read the maximum log sequence number (LSN) position in the server's transaction log.

5. Capture the structure of all non-system, or all tables that are designated for capture.
The connector persists this information in its internal database schema history topic.
The schema history provides information about the structure that is in effect when a change event occurs. +
+
[NOTE]
====
By default, the connector captures the schema of every table in the database that is in capture mode, including tables that are not configured for capture.
If tables are not configured for capture, the initial snapshot captures only their structure; it does not capture any table data.
For more information about why snapshots persist schema information for tables that you did not include in the initial snapshot, see xref:understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables[Understanding why initial snapshots capture the schema for all tables].
====

6. Release the locks obtained in Step 3, if necessary.
Other database clients can now write to any previously locked tables.

7. At the LSN position read in Step 4, the connector scans the tables to be captured.
   During the scan, the connector completes the following tasks:

.. Confirms that the table was created before the snapshot began.
If the table was created after the snapshot began, the connector skips the table.
After the snapshot is complete, and the connector transitions to streaming, it emits change events for any tables that were created after the snapshot began.

.. Produces a `read` event for each row that is captured from a table.
   All `read` events contain the same LSN position, which is the LSN position that was obtained in step 4.

.. Emits each `read` event to the Kafka topic for the table.

8. Records the successful completion of the snapshot in the connector offsets.

The resulting initial snapshot captures the current state of each row in the tables that are enabled for CDC.
From this baseline state, the connector captures subsequent changes as they occur.

After the snapshot process begins, if the process is interrupted due to connector failure, rebalancing, or other reasons, the process restarts after the connector restarts.

After the connector completes the initial snapshot, it continues streaming from the position that it read in Step 4 so that it does not miss any updates.

If the connector stops again for any reason, after it restarts, it resumes streaming changes from where it previously left off.

[id="sqlserver-connector-snapshot-mode-options"]
.Settings for `snapshot.mode` connector configuration property
[cols="30%a,70%a",options="header"]
|===
|Setting |Description

|`always`
|Perform snapshot on each connector start.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

|`initial`
|The connector performs a database snapshot as described in the xref:sqlserver-default-workflow-for-performing-an-initial-snapshot[default workflow for creating an initial snapshot].
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

|`initial_only`
|The connector performs a database snapshot and stops before streaming any change event records, not allowing any subsequent change events to be captured.

|`schema_only`
|Deprecated, see `no_data`.

|`no_data`
|The connector captures the structure of all relevant tables, performing all the steps described in the xref:sqlserver-default-workflow-for-performing-an-initial-snapshot[default snapshot workflow], except that it does not create `READ` events to represent the data set at the point of the connector's start-up (Step 7.b).

|`recovery`
|Set this option to restore a database schema history topic that is lost or corrupted.
After a restart, the connector runs a snapshot that rebuilds the topic from the source tables.
You can also set the property to periodically prune a database schema history topic that experiences unexpected growth. +
+
WARNING: Do not use this mode to perform a snapshot if schema changes were committed to the database after the last connector shutdown.

|`when_needed`
|After the connector starts, it performs a snapshot only if it detects one of the following circumstances:

* It cannot detect any topic offsets.
* A previously recorded offset specifies a log position that is not available on the server.

|`configuration_based`
|Set the snapshot mode to `configuration_based` to control snapshot behavior through the set of connector properties that have the prefix 'snapshot.mode.configuration.based'.

|`custom`
|The `custom` snapshot mode lets you inject your own implementation of the `io.debezium.spi.snapshot.Snapshotter` interface.
Set the `snapshot.mode.custom.name` configuration property to the name provided by the `name()` method of your implementation.
The name is specified on the classpath of your Kafka Connect cluster.
If you use the {prodname} `EmbeddedEngine`, the name is included in the connector JAR file.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|===

For more information, see xref:sqlserver-property-snapshot-mode[`snapshot.mode`] in the table of connector configuration properties.

// ModuleID: sqlserver-description-of-why-initial-snapshots-capture-the-schema-history-for-all-tables
// Title: Description of why initial snapshots capture the schema history for all tables
// Type: concept
[id="understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables"]
==== Understanding why initial snapshots capture the schema history for all tables

The initial snapshot that a connector runs captures two types of information:

Table data::
Information about `INSERT`, `UPDATE`, and `DELETE` operations in tables that are named in the connector's xref:{context}-property-table-include-list[`table.include.list`] property.
Schema data::
DDL statements that describe the structural changes that are applied to tables.
Schema data is persisted to both the internal schema history topic, and to the connector's schema change topic, if one is configured.

After you run an initial snapshot, you might notice that the snapshot captures schema information for tables that are not designated for capture.
By default, initial snapshots are designed to capture schema information for every table that is present in the database, not only from tables that are designated for capture.
Connectors require that the table's schema is present in the schema history topic before they can capture a table.
By enabling the initial snapshot to capture schema data for tables that are not part of the original capture set, {prodname} prepares the connector to readily capture event data from these tables should that later become necessary.
If the initial snapshot does not capture a table's schema, you must add the schema to the history topic before the connector can capture data from the table.

In some cases, you might want to limit schema capture in the initial snapshot.
This can be useful when you want to reduce the time required to complete a snapshot.
Or when {prodname} connects to the database instance through a user account that has access to multiple logical databases, but you want the connector to capture changes only from tables in a specific logic database.

.Additional information
* xref:{context}-capturing-data-from-tables-not-captured-by-the-initial-snapshot[Capturing data from tables not captured by the initial snapshot (no schema change)]
* xref:{context}-capturing-data-from-new-tables-with-schema-changes[Capturing data from tables not captured by the initial snapshot (schema change)]
* Setting the xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.store.only.captured.tables.ddl`] property to specify the tables from which to capture schema information.
* Setting the xref:{context}-property-database-history-store-only-captured-databases-ddl[`schema.history.internal.store.only.captured.databases.ddl`] property to specify the logical databases from which to capture schema changes.

// Type: procedure
[id="sqlserver-capturing-data-from-tables-not-captured-by-the-initial-snapshot"]
==== Capturing data from tables not captured by the initial snapshot (no schema change)

In some cases, you might want the connector to capture data from a table whose schema was not captured by the initial snapshot.
Depending on the connector configuration, the initial snapshot might capture the table schema only for specific tables in the database.
If the table schema is not present in the history topic, the connector fails to capture the table, and reports a missing schema error.

You might still be able to capture data from the table, but you must perform additional steps to add the table schema.

.Prerequisites

* You want to capture data from a table with a schema that the connector did not capture during the initial snapshot.
* No schema changes were applied to the table between the LSNs of the earliest and latest change table entry that the connector reads.
For information about capturing data from a new table that has undergone structural changes, see xref:db2-capturing-data-from-new-tables-with-schema-changes[].

.Procedure

1. Stop the connector.
2. Remove the internal database schema history topic that is specified by the xref:{context}-property-database-history-kafka-topic[`schema.history.internal.kafka.topic property`].
3. Clear the offsets in the configured Kafka Connect link:{link-kafka-docs}/#connectconfigs_offset.storage.topic[`offset.storage.topic`].
For more information about how to remove offsets, see the link:https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector[{prodname} community FAQ].
+
[WARNING]
====
Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.
====
4. Apply the following changes to the connector configuration:
.. (Optional) Set the value of xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.store.only.captured.tables.ddl`] to `false`.
This setting causes the snapshot to capture the schema for all tables, and guarantees that, in the future, the connector can reconstruct the schema history for all tables. +
+
[NOTE]
====
Snapshots that capture the schema for all tables require more time to complete.
====
.. Add the tables that you want the connector to capture to xref:{context}-property-table-include-list[`table.include.list`].
.. Set the xref:{context}-property-snapshot-mode[`snapshot.mode`] to one of the following values:
`initial`:: When you restart the connector, it takes a full snapshot of the database that captures the table data and table structures. +
If you select this option, consider setting the value of the xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.store.only.captured.tables.ddl`] property to `false` to enable the connector to capture the schema of all tables.
`schema_only`:: When you restart the connector, it takes a snapshot that captures only the table schema.
Unlike a full data snapshot, this option does not capture any table data.
Use this option if you want to restart the connector more quickly than with a full snapshot.

5. Restart the connector.
The connector completes the type of snapshot specified by the `snapshot.mode`.
6. (Optional) If the connector performed a `schema_only` snapshot, after the snapshot completes, initiate an xref:sqlserver-incremental-snapshots[incremental snapshot] to capture data from the tables that you added.
The connector runs the snapshot while it continues to stream real-time changes from the tables.
Running an incremental snapshot captures the following data changes:
+
* For tables that the connector previously captured, the incremental snapsot captures changes that occur while the connector was down, that is, in the interval between the time that the connector was stopped, and the current restart.
* For newly added tables, the incremental snapshot captures all existing table rows.

// Type: procedure
[id="sqlserver-capturing-data-from-new-tables-with-schema-changes"]
==== Capturing data from tables not captured by the initial snapshot (schema change)

If a schema change is applied to a table, records that are committed before the schema change have different structures than those that were committed after the change.
When {prodname} captures data from a table, it reads the schema history to ensure that it applies the correct schema to each event.
If the schema is not present in the schema history topic, the connector is unable to capture the table, and an error results.

If you want to capture data from a table that was not captured by the initial snapshot, and the schema of the table was modified, you must add the schema to the history topic, if it is not already available.
You can add the schema by running a new schema snapshot, or by running an initial snapshot for the table.

.Prerequisites
* You want to capture data from a table with a schema that the connector did not capture during the initial snapshot.
* A schema change was applied to the table so that the records to be captured do not have a uniform structure.

.Procedure

Initial snapshot captured the schema for all tables (`store.only.captured.tables.ddl` was set to `false`)::
1. Edit the xref:{context}-property-table-include-list[`table.include.list`] property to specify the tables that you want to capture.
2. Restart the connector.
3. Initiate an xref:sqlserver-incremental-snapshots[incremental snapshot] if you want to capture existing data from the newly added tables.

Initial snapshot did not capture the schema for all tables (`store.only.captured.tables.ddl` was set to `true`)::
If the initial snapshot did not save the schema of the table that you want to capture, complete one of the following procedures:

Procedure 1: Schema snapshot, followed by incremental snapshot:::
In this procedure, the connector first performs a schema snapshot.
You can then initiate an incremental snapshot to enable the connector to synchronize data.
1. Stop the connector.
2. Remove the internal database schema history topic that is specified by the xref:{context}-property-database-history-kafka-topic[`schema.history.internal.kafka.topic property`].
3. Clear the offsets in the configured Kafka Connect link:{link-kafka-docs}/#connectconfigs_offset.storage.topic[`offset.storage.topic`].
For more information about how to remove offsets, see the link:https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector[{prodname} community FAQ].
+
[WARNING]
====
Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.
====
4. Set values for properties in the connector configuration as described in the following steps:
.. Set the value of the xref:{context}-property-snapshot-mode[`snapshot.mode`] property to `schema_only`.
.. Edit the xref:{context}-property-table-include-list[`table.include.list`] to add the tables that you want to capture.
5. Restart the connector.
6. Wait for {prodname} to capture the schema of the new and existing tables.
Data changes that occurred any tables after the connector stopped are not captured.
7. To ensure that no data is lost, initiate an xref:sqlserver-incremental-snapshots[incremental snapshot].

Procedure 2: Initial snapshot, followed by optional incremental snapshot:::
In this procedure the connector performs a full initial snapshot of the database.
As with any initial snapshot, in a database with many large tables, running an initial snapshot can be a time-consuming operation.
After the snapshot completes, you can optionally trigger an incremental snapshot to capture any changes that occur while the connector is off-line.

1. Stop the connector.
2. Remove the internal database schema history topic that is specified by the xref:{context}-property-database-history-kafka-topic[`schema.history.internal.kafka.topic property`].
3. Clear the offsets in the configured Kafka Connect link:{link-kafka-docs}/#connectconfigs_offset.storage.topic[`offset.storage.topic`].
For more information about how to remove offsets, see the link:https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector[{prodname} community FAQ].
+
[WARNING]
====
Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.
====
4. Edit the xref:{context}-property-table-include-list[`table.include.list`] to add the tables that you want to capture.
5. Set values for properties in the connector configuration as described in the following steps:
.. Set the value of the xref:{context}-property-snapshot-mode[`snapshot.mode`] property to `initial`.
.. (Optional) Set xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.store.only.captured.tables.ddl`] to `false`.
6. Restart the connector.
The connector takes a full database snapshot.
After the snapshot completes, the connector transitions to streaming.
7. (Optional) To capture any data that changed while the connector was off-line, initiate an xref:sqlserver-incremental-snapshots[incremental snapshot].

// Type: concept
// ModuleID: debezium-sqlserver-ad-hoc-snapshots
[id="sqlserver-ad-hoc-snapshots"]
=== Ad hoc snapshots

:leveloffset: +1

By default, a connector runs an initial snapshot operation only after it starts for the first time.
Following this initial snapshot, under normal circumstances, the connector does not repeat the snapshot process.
Any future change event data that the connector captures comes in through the streaming process only.

However, in some situations the data that the connector obtained during the initial snapshot might become stale, lost, or incomplete.
To provide a mechanism for recapturing {data-collection} data, {prodname} includes an option to perform ad hoc snapshots.
You might want to perform an ad hoc snapshot after any of the following changes occur in your {prodname} environment:

* The connector configuration is modified to capture a different set of {data-collection}s.
* Kafka topics are deleted and must be rebuilt.
* Data corruption occurs due to a configuration error or some other problem.

You can re-run a snapshot for a {data-collection} for which you previously captured a snapshot by initiating a so-called _ad-hoc snapshot_.
Ad hoc snapshots require the use of {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[signaling {data-collection}s].
You initiate an ad hoc snapshot by sending a signal request to the {prodname} signaling {data-collection}.

When you initiate an ad hoc snapshot of an existing {data-collection}, the connector appends content to the topic that already exists for the {data-collection}.
If a previously existing topic was removed, {prodname} can create a topic automatically if {link-prefix}:{link-topic-auto-creation}#customizing-debezium-automatically-created-topics[automatic topic creation] is enabled.

Ad hoc snapshot signals specify the {data-collection}s to include in the snapshot.
The snapshot can capture the entire contents of the database, or capture only a subset of the {data-collection}s in the database.
Also, the snapshot can capture a subset of the contents of the {data-collection}(s) in the database.

You specify the {data-collection}s to capture by sending an `execute-snapshot` message to the signaling {data-collection}.
Set the type of the `execute-snapshot` signal to `incremental` or `blocking`, and provide the names of the {data-collection}s to include in the snapshot, as described in the following table:


.Example of an ad hoc `execute-snapshot` signal record
[cols="2,2,6a",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| Specifies the type of snapshot that you want to run. +
Currently, you can request `incremental` or `blocking` snapshots.


|`data-collections`
|_N/A_
| An array that contains regular expressions matching the fully-qualified names of the {data-collection} to be snapshotted. +
The format of the names is the same as for the `signal.data.collection` configuration option.

|`[.line-through]#additional-condition#`
|_N/A_
| An optional string, which specifies a condition based on the column(s) of the {data-collection}(s), to capture a
subset of the contents of the {data-collection}(s). +

[NOTE]
====
This property is deprecated.
To specify criteria for defining the subset of data that you want the snapshot to capture, use the `additional-conditions` parameter.
====

|`additional-conditions`
|_N/A_
|An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot. +
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:

`data-collection`:: The fully-qualified name of the {data-collection} that the filter applies to.
You can apply different filters to each {data-collection}.
`filter`:: Specifies column values that must be present in a database record for the snapshot to include it, for example,  `"color='blue'"`. +
 +
The values that you assign to the `filter` parameter are the same types of values that you might specify in the `WHERE` clause of `SELECT` statements when you set the `snapshot.select.statement.overrides` property for a blocking snapshot.
In earlier {prodname} releases, an explicit `filter` parameter was not defined for snapshot signals; instead, filter criteria were implied by the values that were specified for the now deprecated  `additional-condition` parameter.

|`surrogate-key`
|_N/A_
| An optional string that specifies the column name that the connector uses as the primary key of a {data-collection} during the snapshot process.

|===

.Triggering an ad hoc incremental snapshot

You initiate an ad hoc incremental snapshot by adding an entry with the `execute-snapshot` signal type to the signaling {data-collection}.
After the connector processes the message, it begins the snapshot operation.
The snapshot process reads the first and last primary key values and uses those values as the start and end point for each {data-collection}.
Based on the number of entries in the {data-collection}, and the configured chunk size, {prodname} divides the {data-collection} into chunks, and proceeds to snapshot each chunk, in succession, one at a time.

For more information, see xref:debezium-{context}-incremental-snapshots[Incremental snapshots].

.Triggering an ad hoc blocking snapshot

You initiate an ad hoc blocking snapshot by adding an entry with the `execute-snapshot` signal type to the signaling {data-collection}.
After the connector processes the message, it begins the snapshot operation.
The connector temporarily stops streaming, and then initiates a snapshot of the specified {data-collection}, following the same process that it uses during an initial snapshot.
After the snapshot completes, the connector resumes streaming.

For more information, see xref:{context}-blocking-snapshots[Blocking snapshots].

:leveloffset: 1

// Type: assembly
// ModuleID: debezium-sqlserver-incremental-snapshots
[id="sqlserver-incremental-snapshots"]
=== Incremental snapshots

.SQL Server collations
[WARNING]
====
Each SQL Server server or database is configured to use a specific https://learn.microsoft.com/en-us/sql/relational-databases/collations/collation-and-unicode-support?view=sql-server-ver16#Collation_Defn[collation], which determines how character data is stored, sorted, compared, and displayed.
The sorting rules for some collation sets, such as the https://learn.microsoft.com/en-us/sql/relational-databases/collations/collation-and-unicode-support?view=sql-server-ver16#SQL-collations[SQL Server collations (SQL_*)] are not compatible with the Unicode sorting algorithm.
In some cases, the incompatible sorting rules can lead to lost data when the connector runs an ad hoc snapshot.
For example, if SQL Server is configured to send strings as Unicode (that is, the connection property `sendStringParametersAsUnicode` is set to `true`), the connector can skip records during the snapshot.
To protect against lost data during an ad hoc snapshot, set the value of the `driver.sendStringParametersAsUnicode` connection string property to `false`.

For more information about using the `sendStringParametersAsUnicode` property, see the https://learn.microsoft.com/en-us/sql/connect/jdbc/setting-the-connection-properties?view=sql-server-ver16[SQL Server connection properties documentation].
====

:leveloffset: +1

To provide flexibility in managing snapshots, {prodname} includes a supplementary snapshot mechanism, known as _incremental snapshotting_.
Incremental snapshots rely on the {prodname} mechanism for {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[sending signals to a {prodname} connector].
Incremental snapshots are based on the link:https://github.com/debezium/debezium-design-documents/blob/main/DDD-3.md[DDD-3] design document.

In an incremental snapshot, instead of capturing the full state of a database all at once, as in an initial snapshot, {prodname} captures each {data-collection} in phases, in a series of configurable chunks.
You can specify the {data-collection}s that you want the snapshot to capture and the xref:{context}-property-incremental-snapshot-chunk-size[size of each chunk].
The chunk size determines the number of rows that the snapshot collects during each fetch operation on the database.
The default chunk size for incremental snapshots is 1024 rows.

As an incremental snapshot proceeds, {prodname} uses watermarks to track its progress, maintaining a record of each {data-collection} row that it captures.
This phased approach to capturing data provides the following advantages over the standard initial snapshot process:

* You can run incremental snapshots in parallel with streamed data capture, instead of postponing streaming until the snapshot completes.
  The connector continues to capture near real-time events from the change log throughout the snapshot process, and neither operation blocks the other.
* If the progress of an incremental snapshot is interrupted, you can resume it without losing any data.
  After the process resumes, the snapshot begins at the point where it stopped, rather than recapturing the {data-collection} from the beginning.
* You can run an incremental snapshot on demand at any time, and repeat the process as needed to adapt to database updates.
  For example, you might re-run a snapshot after you modify the connector configuration to add a {data-collection} to its xref:{context}-property-{data-collection}-include-list[`{data-collection}.include.list`] property.

.Incremental snapshot process
When you run an incremental snapshot, {prodname} sorts each {data-collection} by primary key and then splits the {data-collection} into chunks based on the xref:{context}-property-incremental-snapshot-chunk-size[configured chunk size].
Working chunk by chunk, it then captures each {data-collection} row in a chunk.
For each row that it captures, the snapshot emits a `READ` event.
That event represents the value of the row when the snapshot for the chunk began.

As a snapshot proceeds, it’s likely that other processes continue to access the database, potentially modifying {data-collection} records.
To reflect such changes, `INSERT`, `UPDATE`, or `DELETE` operations are committed to the transaction log as per usual.
Similarly, the ongoing {prodname} streaming process continues to detect these change events and emits corresponding change event records to Kafka.

.How {prodname} resolves collisions among records with the same primary key
In some cases, the `UPDATE` or `DELETE` events that the streaming process emits are received out of sequence.
That is, the streaming process might emit an event that modifies a {data-collection} row before the snapshot captures the chunk that contains the `READ` event for that row.
When the snapshot eventually emits the corresponding `READ` event for the row, its value is already superseded.
To ensure that incremental snapshot events that arrive out of sequence are processed in the correct logical order, {prodname} employs a buffering scheme for resolving collisions.
Only after collisions between the snapshot events and the streamed events are resolved does {prodname} emit an event record to Kafka.

.Snapshot window
To assist in resolving collisions between late-arriving `READ` events and streamed events that modify the same {data-collection} row, {prodname} employs a so-called _snapshot window_.
The snapshot windows demarcates the interval during which an incremental snapshot captures data for a specified {data-collection} chunk.
Before the snapshot window for a chunk opens, {prodname} follows its usual behavior and emits events from the transaction log directly downstream to the target Kafka topic.
But from the moment that the snapshot for a particular chunk opens, until it closes, {prodname} performs a de-duplication step to resolve collisions between events that have the same primary key..

For each data collection, the {prodname} emits two types of events, and stores the records for them both in a single destination Kafka topic.
The snapshot records that it  captures directly from a table are emitted as `READ` operations.
Meanwhile, as users continue to update records in the data collection, and the transaction log is updated to reflect each commit, {prodname} emits `UPDATE` or `DELETE` operations for each change.

As the snapshot window opens, and {prodname} begins processing a snapshot chunk, it delivers snapshot records to a memory buffer.
During the snapshot windows, the primary keys of the `READ` events in the buffer are compared to the primary keys of the incoming streamed events.
If no match is found, the streamed event record is sent directly to Kafka.
If {prodname} detects a match, it discards the buffered `READ` event, and writes the streamed record to the destination topic, because the streamed event logically supersede the static snapshot event.
After the snapshot window for the chunk closes, the buffer contains only `READ` events for which no related transaction log events exist.
{prodname} emits these remaining `READ` events to the {data-collection}'s Kafka topic.

The connector repeats the process for each snapshot chunk.

:leveloffset: 1

[WARNING]
====
The {prodname} connector for SQL Server does not support schema changes while an incremental snapshot is running.
====

// Type: procedure
// ModuleID: debezium-sqlserver-triggering-an-incremental-snapshot
[id="sqlserver-triggering-an-incremental-snapshot"]
==== Triggering an incremental snapshot

:leveloffset: +1

Currently, the only way to initiate an incremental snapshot is to send an {link-prefix}:{link-signalling}#debezium-signaling-ad-hoc-snapshots[ad hoc snapshot signal] to the signaling {data-collection} on the source database.

You submit a signal to the signaling {data-collection} as SQL `INSERT` queries.

After {prodname} detects the change in the signaling {data-collection}, it reads the signal, and runs the requested snapshot operation.

The query that you submit specifies the {data-collection}s to include in the snapshot, and, optionally, specifies the type of snapshot operation.
Currently supports the `incremental` and `blocking` types.

To specify the {data-collection}s to include in the snapshot, provide a `data-collections` array that lists the {data-collection}s or an array of regular expressions used to match {data-collection}s, for example, +

`{"data-collections": ["public.MyFirstTable", "public.MySecondTable"]}` +

The `data-collections` array for an incremental snapshot signal has no default value.
If the `data-collections` array is empty, {prodname} detects that no action is required and does not perform a snapshot.

[NOTE]
====
If the name of a {data-collection} that you want to include in a snapshot contains a dot (`.`) in the name of the database, schema, or table, to add the {data-collection} to the `data-collections` array, you must escape each part of the name in double quotes. +
 +
For example, to include a table that exists in the `*public*` schema and that has the name `*My.Table*`, use the following format: `*"public"."My.Table"*`.
====

.Prerequisites

* {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[Signaling is enabled]. +
** A signaling data collection exists on the source database.
** The signaling data collection is specified in the xref:{context}-property-signal-data-collection[`signal.data.collection`] property.

.Using a source signaling channel to trigger an incremental snapshot

. Send a SQL query to add the ad hoc incremental snapshot request to the signaling {data-collection}:
+
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) VALUES (_'<id>'_, _'<snapshotType>'_, '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"_<snapshotType>_","additional-conditions":[{"data-collection": "_<tableName>_", "filter": "_<additional-condition>_"}]}');
----
+
For example,
+
[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) // <1>
values ('ad-hoc-1',   // <2>
    'execute-snapshot',  // <3>
    '{"data-collections": ["schema1.table1", "schema2.table2"], // <4>
    "type":"incremental", // <5>
    "additional-conditions":[{"data-collection": "schema1.table1" ,"filter":"color=\'blue\'"}]}'); // <6>
----
+
The values of the `id`,`type`, and `data` parameters in the command correspond to the {link-prefix}:{link-signalling}#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection[fields of the signaling {data-collection}].
+
The following table describes the parameters in the example:
+
.Descriptions of fields in a SQL command for sending an incremental snapshot signal to the signaling {data-collection}
[cols="1,2,6",options="header"]
|===
|Item |Value |Description

|1
|`myschema.debezium_signal`
|Specifies the fully-qualified name of the signaling {data-collection} on the source database.

|2
|`ad-hoc-1`
|The `id` parameter specifies an arbitrary string that is assigned as the `id` identifier for the signal request. +
Use this string to identify logging messages to entries in the signaling {data-collection}.
{prodname} does not use this string.
Rather, during the snapshot, {prodname} generates its own `id` string as a watermarking signal.

|3
|`execute-snapshot`
|The `type` parameter specifies the operation that the signal is intended to trigger. +

|4
|`data-collections`
|A required component of the `data` field of a signal that specifies an array of {data-collection} names or regular expressions to match {data-collection} names to include in the snapshot. +
The array lists regular expressions which match {data-collection}s by their fully-qualified names, using the same format as you use to specify the name of the connector's signaling {data-collection} in the xref:{context}-property-signal-data-collection[`signal.data.collection`] configuration property.

|5
|`incremental`
|An optional `type` component of the `data` field of a signal that specifies the type of snapshot operation to run. +
Currently supports the `incremental` and `blocking` types. +
If you do not specify a value, the connector runs an incremental snapshot.

|6
|`additional-conditions`
| An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot. +
Each additional condition is an object with `data-collection` and `filter` properties.
You can specify different filters for each data collection. +
* The `data-collection` property is the fully-qualified name of the data collection for which the filter will be applied.
For more information about the `additional-conditions` parameter, see xref:{context}-incremental-snapshots-additional-conditions[].
|===

[id="{context}-incremental-snapshots-additional-conditions"]
.Ad hoc incremental snapshots with `additional-conditions`

If you want a snapshot to include only a subset of the content in a {data-collection}, you can modify the signal request by appending an `additional-conditions` parameter to the snapshot signal.

The SQL query for a typical snapshot takes the following form:

[source,sql,subs="+attributes,+quotes"]
----
SELECT * FROM _<tableName>_ ....
----

By adding an `additional-conditions` parameter, you append a `WHERE` condition to the SQL query, as in the following example:

[source,sql,subs="+attributes,+quotes"]
----
SELECT * FROM _<data-collection>_ WHERE _<filter>_ ....
----

The following example shows a SQL query to send an ad hoc incremental snapshot request with an additional condition to the signaling {data-collection}:
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) VALUES (_'<id>'_, _'<snapshotType>'_, '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"_<snapshotType>_","additional-conditions":[{"data-collection": "_<tableName>_", "filter": "_<additional-condition>_"}]}');
----

For example, suppose you have a `products` {data-collection} that contains the following columns:

* `id` (primary key)
* `color`
* `quantity`

If you want an incremental snapshot of the `products` {data-collection} to include only the data items where `color=blue`, you can use the following SQL statement to trigger the snapshot:

[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) VALUES('ad-hoc-1', 'execute-snapshot', '{"data-collections": ["schema1.products"],"type":"incremental", "additional-conditions":[{"data-collection": "schema1.products", "filter": "color=blue"}]}');
----

The `additional-conditions` parameter also enables you to pass conditions that are based on more than one column.
For example, using the `products` {data-collection} from the previous example, you can submit a query that triggers an incremental snapshot that includes the data of only those items for which `color=blue` and `quantity>10`:

[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) VALUES('ad-hoc-1', 'execute-snapshot', '{"data-collections": ["schema1.products"],"type":"incremental", "additional-conditions":[{"data-collection": "schema1.products", "filter": "color=blue AND quantity>10"}]}');
----

The following example, shows the JSON for an incremental snapshot event that is captured by a connector.

.Example: Incremental snapshot event message
[source,json,index=0]
----
{
    "before":null,
    "after": {
        "pk":"1",
        "value":"New data"
    },
    "source": {
        ...
        "snapshot":"incremental" <1>
    },
    "op":"r", <2>
    "ts_ms":"1620393591654",
    "ts_us":"1620393591654547",
    "ts_ns":"1620393591654547920",
    "transaction":null
}
----
[cols="1,1,4",options="header"]
|===
|Item |Field name |Description
|1
|`snapshot`
|Specifies the type of snapshot operation to run. +
Currently, the only valid options are `blocking` and `incremental`. +
Specifying a `type` value in the SQL query that you submit to the signaling {data-collection} is optional. +
If you do not specify a value, the connector runs an incremental snapshot.

|2
|`op`
|Specifies the event type. +
The value for snapshot events is `r`, signifying a `READ` operation.

|===

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-sqlserver-using-the-kafka-signaling-channel-to-trigger-an-incremental-snapshot
[id="sqlserver-triggering-an-incremental-snapshot-kafka"]
==== Using the Kafka signaling channel to trigger an incremental snapshot

:leveloffset: +1

You can send a message to the {link-prefix}:{link-signalling}#debezium-signaling-enabling-kafka-signaling-channel[configured Kafka topic] to request the connector to run an ad hoc incremental snapshot.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value of the message is a JSON object with `type` and `data` fields.

The signal type is `execute-snapshot`, and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6a",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed.
Currently {prodname} supports the `incremental` and `blocking` types. +
See the next section for more details.

|`data-collections`
|_N/A_
| An array of comma-separated regular expressions that match the fully-qualified names of tables to include in the snapshot. +
Specify the names by using the same format as is required for the xref:{context}-property-signal-data-collection[signal.data.collection] configuration option.

|`[.line-through]#additional-condition#`
|_N/A_
| An optional string that specifies a condition that the connector evaluates to designate a subset of records to include in a snapshot. +

[NOTE]
====
This property is deprecated and should be replaced by the `additional-conditions` property.
====

|`additional-conditions`
|_N/A_
| An optional array of additional conditions that specifies criteria that the connector evaluates to designate a subset of records to include in a snapshot. +
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:
`data-collection`:: The fully-qualified name of the {data-collection} that the filter applies to.
You can apply different filters to each {data-collection}.
`filter`:: Specifies column values that must be present in a database record for the snapshot to include it, for example,  `"color='blue'"`. +
 +
The values that you assign to the `filter` parameter are the same types of values that you might specify in the `WHERE` clause of `SELECT` statements when you set the `snapshot.select.statement.overrides` property for a blocking snapshot.
In earlier {prodname} releases, an explicit `filter` parameter was not defined for snapshot signals; instead, filter criteria were implied by the values that were specified for the now deprecated `additional-condition` parameter.
|===

An example of the execute-snapshot Kafka message:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

.Ad hoc incremental snapshots with additional-conditions

{prodname} uses the `additional-conditions` field to select a subset of a {data-collection}'s content.

Typically, when {prodname} runs a snapshot, it runs a SQL query such as:

`SELECT * FROM _<tableName>_ ....`

When the snapshot request includes an `additional-conditions` property, the `data-collection` and `filter` parameters of the  property are appended to the SQL query, for example:

`SELECT * FROM _<data-collection>_ WHERE _<filter>_ ....`

For example, given a `products` {data-collection} with the columns `id` (primary key), `color`, and `brand`, if you want a snapshot to include only content for which `color='blue'`, when you request the snapshot, you could add the `additional-conditions` property to filter the content:
----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "schema1.products" ,"filter":"color='blue'"}]}}`
----

You can use the `additional-conditions` property to pass conditions based on multiple columns.
For example, using the same `products` {data-collection} as in the previous example, if you want a snapshot to include only the content from the `products` {data-collection} for which `color='blue'`, and `brand='MyBrand'`, you could send the following request:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "schema1.products" ,"filter":"color='blue' AND brand='MyBrand'"}]}}`
----

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-sqlserver-stopping-an-incremental-snapshot
[id="sqlserver-stopping-an-incremental-snapshot"]
==== Stopping an incremental snapshot

:leveloffset: +1

You can also stop an incremental snapshot by sending a signal to the {data-collection} on the source database.
You submit a stop snapshot signal to the {data-collection} by sending a SQL `INSERT` query.

After {prodname} detects the change in the signaling {data-collection}, it reads the signal, and stops the incremental snapshot operation if it's in progress.

The query that you submit specifies the snapshot operation of `incremental`, and, optionally, the {data-collection}s of the current running snapshot to be removed.

.Prerequisites

* {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[Signaling is enabled]. +
** A signaling data collection exists on the source database.
** The signaling data collection is specified in the xref:{context}-property-signal-data-collection[`signal.data.collection`] property.

.Using a source signaling channel to stop an incremental snapshot

. Send a SQL query to stop the ad hoc incremental snapshot to the signaling {data-collection}:
+
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) values (_'<id>'_, 'stop-snapshot', '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"incremental"}');
----
+
For example,
+
[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) // <1>
values ('ad-hoc-1',   // <2>
    'stop-snapshot',  // <3>
    '{"data-collections": ["schema1.table1", "schema2.table2"], // <4>
    "type":"incremental"}'); // <5>
----
+
The values of the `id`, `type`, and `data` parameters in the signal command correspond to the {link-prefix}:{link-signalling}#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection[fields of the signaling {data-collection}].
+
The following table describes the parameters in the example:
+
.Descriptions of fields in a SQL command for sending a stop incremental snapshot signal to the signaling {data-collection}
[cols="1,2,6",options="header"]
|===
|Item|Value |Description

|1
|`myschema.debezium_signal`
|Specifies the fully-qualified name of the signaling {data-collection} on the source database.

|2
|`ad-hoc-1`
| The `id` parameter specifies an arbitrary string that is assigned as the `id` identifier for the signal request. +
Use this string to identify logging messages to entries in the signaling {data-collection}.
{prodname} does not use this string.

|3
|`stop-snapshot`
| Specifies `type` parameter specifies the operation that the signal is intended to trigger. +

|4
|`data-collections`
|An optional component of the `data` field of a signal that specifies an array of {data-collection} names or regular expressions to match {data-collection} names to remove from the snapshot. +
The array lists regular expressions which match {data-collection}s by their fully-qualified names, using the same format as you use to specify the name of the connector's signaling {data-collection} in the xref:{context}-property-signal-data-collection[`signal.data.collection`] configuration property.
If this component of the `data` field is omitted, the signal stops the entire incremental snapshot that is in progress.

|5
|`incremental`
|A required component of the `data` field of a signal that specifies the type of snapshot operation that is to be stopped. +
Currently, the only valid option is `incremental`. +
If you do not specify a `type` value, the signal fails to stop the incremental snapshot.
|===

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-sqlserver-using-the-kafka-signaling-channel-to-stop-an-incremental-snapshot
[id="sqlserver-stopping-an-incremental-snapshot-kafka"]
==== Using the Kafka signaling channel to stop an incremental snapshot

:leveloffset: +1

You can send a signal message to the {link-prefix}:{link-signalling}#debezium-signaling-enabling-kafka-signaling-channel[configured Kafka signaling topic] to stop an ad hoc incremental snapshot.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value of the message is a JSON object with `type` and `data` fields.

The signal type is `stop-snapshot`, and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed.
Currently {prodname} supports only the `incremental` type.  +
See the next section for more details.

|`data-collections`
|_N/A_
| An optional array of comma-separated regular expressions that match the fully-qualified names of the tables to include in the snapshot. +
Specify the names by using the same format as is required for the xref:{context}-property-signal-data-collection[signal.data.collection] configuration option.

|===

The following example shows a typical `stop-snapshot` Kafka message:

----
Key = `test_connector`

Value = `{"type":"stop-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

:leveloffset: 1

[[connector-custom-snapshot]]
=== Custom snapshotter SPI
:leveloffset: +3

For more advanced uses, you can fine-tune control of the snapshot by implementing one of the following interfaces:

`io.debezium.snapshot.spi.Snapshotter`:: Controls whether the connector takes a snapshot.
`io.debezium.snapshot.spi.SnapshotQuery`:: Controls how data is queried during a snapshot.
`io.debezium.snapshot.spi.SnapshotLock`:: Controls whether the connector locks tables when taking a snapshot.


[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.Snapshotter interface. All built-in snapshot modes implement this interface.
----
/**
 * {@link Snapshotter} is used to determine the following details about the snapshot process:
 * <p>
 * - Whether a snapshot occurs. <br>
 * - Whether streaming continues during the snapshot. <br>
 * - Whether the snapshot includes schema (if supported). <br>
 * - Whether to snapshot data or schema following an error.
 * <p>
 * Although Debezium provides many default snapshot modes,
 * to provide more advanced functionality, such as partial snapshots,
 * you can customize implementation of the interface.
 * For more information, see the documentation.
 *
 *
 *
 */
@Incubating
public interface Snapshotter extends Configurable {

    /**
     * @return the name of the snapshotter.
     *
     *
     */
    String name();

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a data snapshot
     */
    boolean shouldSnapshotData(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a schema snapshot
     */
    boolean shouldSnapshotSchema(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @return {@code true} if the snapshotter should stream after taking a snapshot
     */
    boolean shouldStream();

    /**
     * @return {@code true} whether the schema can be recovered if database schema history is corrupted.
     */
    boolean shouldSnapshotOnSchemaError();

    /**
     * @return {@code true} whether the snapshot should be re-executed when there is a gap in data stream.
     */
    boolean shouldSnapshotOnDataError();

    /**
     *
     * @return {@code true} if streaming should resume from the start of the snapshot
     * transaction, or {@code false} for when a connector resumes and takes a snapshot,
     * streaming should resume from where streaming previously left off.
     */
    default boolean shouldStreamEventsStartingFromSnapshot() {
        return true;
    }

    /**
     * Lifecycle hook called after the snapshot phase is successful.
     */
    default void snapshotCompleted() {
        // no operation
    }

    /**
     * Lifecycle hook called after the snapshot phase is aborted.
     */
    default void snapshotAborted() {
        // no operation
    }
}
----

[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.SnapshotQuery interface. All built-in snapshot query modes implement this interface.
----
/**
 * {@link SnapshotQuery} is used to determine the query used during a data snapshot
 *
 *
 */
public interface SnapshotQuery extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Generate a valid query string for the specified table, or an empty {@link Optional}
     * to skip snapshotting this table (but that table will still be streamed from)
     *
     * @param tableId the table to generate a query for
     * @param snapshotSelectColumns the columns to be used in the snapshot select based on the column
     *                              include/exclude filters
     * @return a valid query string, or none to skip snapshotting this table
     */
    Optional<String> snapshotQuery(String tableId, List<String> snapshotSelectColumns);

}
----

[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.SnapshotLock interface. All built-in snapshot lock modes implement this interface.
----
/**
 * {@link SnapshotLock} is used to determine the table lock mode used during schema snapshot
 *
 *
 */
public interface SnapshotLock extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Returns a SQL statement for locking the given table during snapshotting, if required by the specific snapshotter
     * implementation.
     */
    Optional<String> tableLockingStatement(Duration lockTimeout, String tableId);

}
----

:leveloffset: 1

// Type: concept
[id="sqlserver-blocking-snapshots"]
=== Blocking snapshots

:leveloffset: +3

To provide more flexibility in managing snapshots, {prodname} includes a supplementary ad hoc snapshot mechanism, known as a _blocking snapshot_.
Blocking snapshots rely on the {prodname} mechanism for {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[sending signals to a {prodname} connector].

A blocking snapshot behaves just like an _initial snapshot_, except that you can trigger it at run time.

You might want to run a blocking snapshot rather than use the standard initial snapshot process in the following situations:

* You add a new {data-collection} and you want to complete the snapshot while the connector is running.
* You add a large {data-collection}, and you want the snapshot to complete in less time than is possible with an incremental snapshot.

.Blocking snapshot process
When you run a blocking snapshot, {prodname} stops streaming, and then initiates a snapshot of the specified {data-collection}, following the same process that it uses during an initial snapshot.
After the snapshot completes, the streaming is resumed.

.Configure snapshot

You can set the following properties in the `data` component of a signal:

 * data-collections: to specify which {data-collection}s must be snapshot
 * additional-conditions: You can specify different filters for different {data-collection}. +
 ** The `data-collection` property is the fully-qualified name of the {data-collection} for which the filter will be applied.
 ** The `filter` property will have the same value used in the  `snapshot.select.statement.overrides`

For example:
[source,json]
----
  {"type": "blocking", "data-collections": ["schema1.table1", "schema1.table2"], "additional-conditions": [{"data-collection": "schema1.table1", "filter": "SELECT * FROM [schema1].[table1] WHERE column1 = 0 ORDER BY column2 DESC"}, {"data-collection": "schema1.table2", "filter": "SELECT * FROM [schema1].[table2] WHERE column2 > 0"}]}
----

.Possible duplicates
A delay might exist between the time that you send the signal to trigger the snapshot, and the time when streaming stops and the snapshot starts.
As a result of this delay, after the snapshot completes, the connector might emit some event records that duplicate records captured by the snapshot.

:leveloffset: 1

// Type: concept
// ModuleID: how-the-debezium-sql-server-connector-reads-change-data-tables
// Title: How {prodname} SQL Server connectors read change data tables
=== Reading the change data tables

When the connector first starts, it takes a structural snapshot of the structure of the captured tables
and persists this information to its internal database schema history topic.
The connector then identifies a change table for each source table, and completes the following steps.

1. For each change table, the connector read all of the changes that were created between the last stored maximum LSN and the current maximum LSN.
2. The connector sorts the changes that it reads in ascending order, based on the values of their commit LSN and change LSN.
This sorting order ensures that the changes are replayed by {prodname} in the same order in which they occurred in the database.
3. The connector passes the commit and change LSNs as offsets to Kafka Connect.
4. The connector stores the maximum LSN and restarts the process from Step 1.

After a restart, the connector resumes processing from the last offset (commit and change LSNs) that it read.

The connector is able to detect whether CDC is enabled or disabled for included source tables and adjust its behavior.

// Type: concept
// ModuleID: no-maximum-lsn-recorded-in-the-database
// Title: No maximum LSN recorded in the database
=== No maximum LSN recorded in the database

There may be situations when no maximum LSN is recorded in the database because:

1. SQL Server Agent is not running
2. No changes are recorded in the change table yet
3. Database has low activity and the cdc clean up job periodically clears entries from the cdc tables

Out of these possibilities, since a running SQL Server Agent is a prerequisite, No 1. is a real problem (while No 2. and 3. are normal).

In order to mitigate this issue and differentiate between No 1. and the others, a check for the status of the SQL Server Agent is done through the following query `"SELECT CASE WHEN dss.[status]=4 THEN 1 ELSE 0 END AS isRunning FROM [#db].sys.dm_server_services dss WHERE dss.[servicename] LIKE N'SQL Server Agent (%';"`.
If the SQL Server Agent is not running, an ERROR is written in the log: "No maximum LSN recorded in the database; SQL Server Agent is not running".

[IMPORTANT]
====
The SQL Server Agent running status query requires `VIEW SERVER STATE` server permission.
If you don't want to grant this permission to the configured user, you can choose to configure your own query through the `database.sqlserver.agent.status.query` property.
You can define a function which returns true or 1 if SQL Server Agent is running (false or 0 otherwise) and safely use High-Level permissions without granting them as explained
here link:https://dba.stackexchange.com/questions/62230/what-minimum-permissions-do-i-need-to-provide-to-a-user-so-that-it-can-check-the/103275#103275[What minimum permissions do I need to provide to a user so that it can check the status of SQL Server Agent Service?]
or here link:https://sqlquantumleap.com/2018/02/15/safely-and-easily-use-high-level-permissions-without-granting-them-to-anyone-server-level/[Safely and Easily Use High-Level Permissions Without Granting Them to Anyone: Server-level].
The configuration of the query property would look like: `database.sqlserver.agent.status.query=SELECT [#db].func_is_sql_server_agent_running()` - you need to use `[#db]` as placeholder for the database name.
====

// Type: concept
// ModuleID: limitations-sql-server-connector
// Title: Limitations of {prodname} SQL Server connector
=== Limitations

SQL Server specifically requires the base object to be a table in order to create a change capture instance.
As consequence, capturing changes from indexed views (aka. materialized views) is not supported by SQL Server and hence {prodname} SQL Server connector.

// Type: concept
// ModuleID: default-names-of-kafka-topics-that-receive-debezium-sql-server-change-event-records
// Title: Default names of Kafka topics that receive {prodname} SQL Server change event records
[[sqlserver-topic-names]]
=== Topic names

By default, the SQL Server connector writes events for all `INSERT`, `UPDATE`, and `DELETE` operations that occur in a table to a single Apache Kafka topic that is specific to that table.
The connector uses the following convention to name change event topics:
`_<topicPrefix>_._<schemaName>_._<tableName>_`

The following list provides definitions for the components of the default name:

_topicPrefix_:: The logical name of the server, as specified by the xref:sqlserver-property-topic-prefix[`topic.prefix`] configuration property.
_schemaName_:: The name of the database schema in which the change event occurred.
_tableName_:: The name of the database table in which the change event occurred.

For example, if `fulfillment` is the logical server name, and `dbo` is the schema name, and the database contains tables with the names `products`, `products_on_hand`, `customers`, and `orders`,
the connector would stream change event records to the following Kafka topics:

* `fulfillment.testDB.dbo.products`
* `fulfillment.testDB.dbo.products_on_hand`
* `fulfillment.testDB.dbo.customers`
* `fulfillment.testDB.dbo.orders`

The connector applies similar naming conventions to label its internal database schema history topics, xref:about-the-debezium-sqlserver-connector-schema-change-topic[schema change topics], and xref:sqlserver-transaction-metadata[transaction metadata topics].

If the default topic name do not meet your requirements, you can configure custom topic names.
To configure custom topic names, you specify regular expressions in the logical topic routing SMT.
For more information about using the logical topic routing SMT to customize topic naming, see {link-prefix}:{link-topic-routing}#topic-routing[Topic routing].

// Type: concept
// ModuleID: how-debezium-sql-server-connectors-handle-database-schema-changes
// Title: How {prodname} SQL Server connectors handle database schema changes
[[sqlserver-schema-history-topic]]
=== Schema history topic

When a database client queries a database, the client uses the database’s current schema.
However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded.
Also, a connector cannot necessarily apply the current schema to every event.
If an event is relatively old, it's possible that it was recorded before the current schema was applied.

To ensure correct processing of change events that occur after a schema change, the {prodname} SQL Server connector stores a snapshot of the new schema based on the structure in the SQL Server change tables, which mirror the structure of their associated data tables.
The connector stores the table schema information, together with the LSN of operations the result in schema changes, in the database schema history Kafka topic.
The connector uses the stored schema representation to produce change events that correctly mirror the structure of tables at the time of each insert, update, or delete operation.

When the connector restarts after either a crash or a graceful stop, it resumes reading entries in the SQL Server CDC tables from the last position that it read.
Based on the schema information that the connector reads from the database schema history topic, the connector applies the table structures that existed at the position where the connector restarts.

If you update the schema of a Db2 table that is in capture mode, it's important that you also update the schema of the corresponding change table.
You must be a SQL Server database administrator with elevated privileges to update database schema.
For more information about updating SQL Server database schema in {prodname} environmenbts, see xref:sqlserver-schema-evolution[Database schema evolution].

The database schema history topic is for internal connector use only.
Optionally, the connector can also xref:about-the-debezium-sqlserver-connector-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].

.Additional resources

* xref:sqlserver-topic-names[Default names for topics] that receive {prodname} event records.

// Type: concept
// ModuleID: how-the-debezium-sql-server-connector-uses-the-schema-change-topic
// Title: How the {prodname} SQL Server connector uses the schema change topic
[[about-the-debezium-sqlserver-connector-schema-change-topic]]
=== Schema change topic

For each table for which CDC is enabled, the {prodname} SQL Server connector stores a history of the schema change events that are applied to tables in the database.
The connector writes schema change events to a Kafka topic named `_<topicPrefix>_`, where `_topicPrefix_` is the logical server name that is specified in the xref:sqlserver-property-topic-prefix[`topic.prefix`] configuration property.

Messages that the connector sends to the schema change topic contain a payload, and, optionally, also contain the schema of the change event message.

The schema for the schema change event has the following elements:

`name`:: The name of the schema change event message.
`type`:: The type of the change event message.
`version`:: The version of the schema. The version is an integer that is incremented each time the schema is changed.
`fields`:: The fields that are included in the change event message.

.Example: Schema of the SQL Server connector schema change topic
The following example shows a typical schema in JSON format.

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {
    "type": "struct",
    "fields": [
      {
        "type": "string",
        "optional": false,
        "field": "databaseName"
      }
    ],
    "optional": false,
    "name": "io.debezium.connector.sqlserver.SchemaChangeKey",
    "version": 1
  },
  "payload": {
    "databaseName": "inventory"
  }
}
----

The payload of a schema change event message includes the following elements:

`databaseName`:: The name of the database to which the statements are applied.
The value of `databaseName` serves as the message key.
`tableChanges`::  A structured representation of the entire table schema after the schema change.
The `tableChanges` field contains an array that includes entries for each column of the table.
Because the structured representation presents data in JSON or Avro format, consumers can easily read messages without first processing them through a DDL parser.

[IMPORTANT]
====
When the connector is configured to capture a table, it stores the history of the table's schema changes not only in the schema change topic, but also in an internal database schema history topic.
The internal database schema history topic is for connector use only and it is not intended for direct use by consuming applications.
Ensure that applications that require notifications about schema changes consume that information only from the schema change topic.
====

[WARNING]
====
The format of the messages that a connector emits to its schema change topic is in an incubating state and can change without notice.
====

{prodname} emits a message to the schema change topic when the following events occur:

* You enable CDC for a table.
* You disable CDC for a table.
* You alter the structure of a table for which CDC is enabled by following the xref:sqlserver-schema-evolution[schema evolution procedure].

.Example: Message emitted to the SQL Server connector schema change topic
The following example shows a message in the schema change topic.
The message contains a logical representation of the table schema.

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {
  ...
  },
  "payload": {
    "source": {
      "version": "{debezium-version}",
      "connector": "sqlserver",
      "name": "server1",
      "ts_ms": 0,
      "snapshot": "true",
      "db": "testDB",
      "schema": "dbo",
      "table": "customers",
      "change_lsn": null,
      "commit_lsn": "00000025:00000d98:00a2",
      "event_serial_no": null
    },
    "ts_ms": 1588252618953, // <1>
    "databaseName": "testDB", // <2>
    "schemaName": "dbo",
    "ddl": null, // <3>
    "tableChanges": [ // <4>
      {
        "type": "CREATE", // <5>
        "id": "\"testDB\".\"dbo\".\"customers\"", // <6>
        "table": { // <7>
          "defaultCharsetName": null,
          "primaryKeyColumnNames": [ // <8>
            "id"
          ],
          "columns": [ // <9>
            {
              "name": "id",
              "jdbcType": 4,
              "nativeType": null,
              "typeName": "int identity",
              "typeExpression": "int identity",
              "charsetName": null,
              "length": 10,
              "scale": 0,
              "position": 1,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "first_name",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 2,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "last_name",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 3,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "email",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 4,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            }
          ],
          "attributes": [ // <10>
            {
              "customAttribute": "attributeValue"
            }
          ]
        }
      }
    ]
  }
}
----

.Descriptions of fields in messages emitted to the schema change topic
[cols="1,4,5",options="header"]
|===
|Item |Field name |Description

|1
|`ts_ms`
|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.

In the source object, ts_ms indicates the time that the change was made in the database. By comparing the value for payload.source.ts_ms with the value for payload.ts_ms, you can determine the lag between the source database update and Debezium.

|2
|`databaseName` +
`schemaName`
|Identifies the database and the schema that contain the change.

|3
|`ddl`
|Always `null` for the SQL Server connector.
For other connectors, this field contains the DDL responsible for the schema change.
This DDL is not available to SQL Server connectors.

|4
|`tableChanges`
|An array of one or more items that contain the schema changes generated by a DDL command.

|5
|`type`
a|Describes the kind of change. The value is one of the following:

* `CREATE` - table created
* `ALTER` - table modified
* `DROP` - table deleted

|6
|`id`
|Full identifier of the table that was created, altered, or dropped.

|7
|`table`
|Represents table metadata after the applied change.

|8
|`primaryKeyColumnNames`
|List of columns that compose the table's primary key.

|9
|`columns`
|Metadata for each column in the changed table.

|10
|`attributes`
|Custom attribute metadata for each table change.

|===

In messages that the connector sends to the schema change topic, the key is the name of the database that contains the schema change.
In the following example, the `payload` field contains the key:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {
    "type": "struct",
    "fields": [
      {
        "type": "string",
        "optional": false,
        "field": "databaseName"
      }
    ],
    "optional": false,
    "name": "io.debezium.connector.sqlserver.SchemaChangeKey",
    "version": 1
  },
  "payload": {
    "databaseName": "testDB"
  }
}
----

// Type: assembly
// ModuleID: descriptions-of-debezium-sql-server-connector-data-change-events
// Title: Descriptions of {prodname} SQL Server connector data change events
=== Data change events

The {prodname} SQL Server connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed.

{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained.

The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converter and you configure it to produce all four basic change event parts, change events have this structure:

[source,json,index=0]
----
{
 "schema": { // <1>
   ...
  },
 "payload": { // <2>
   ...
 },
 "schema": { // <3>
   ...
 },
 "payload": { // <4>
   ...
 },
}
----

.Overview of change event basic content
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +
 +
It is possible to override the table's primary key by setting the xref:sqlserver-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.

|2
|`payload`
|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed.

|3
|`schema`
|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas.

|4
|`payload`
|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.

|===

By default, the connector streams change event records to topics with names that are the same as the event's originating table.
For more information, see xref:sqlserver-topic-names[topic names].

[WARNING]
====
The SQL Server connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or \_. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or \_. If there is an invalid character it is replaced with an underscore character.

This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.
====


// Type: concept
// ModuleID: about-keys-in-debezium-sql-server-change-events
// Title: About keys in {prodname} SQL Server change events
[[sqlserver-change-event-keys]]
==== Change event keys

A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's primary key (or unique key constraint) at the time the connector created the event.

Consider the following `customers` table, which is followed by an example of a change event key for this table.

.Example table
[source,sql,indent=0]
----
CREATE TABLE customers (
  id INTEGER IDENTITY(1001,1) NOT NULL PRIMARY KEY,
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE
);
----

.Example change event key
Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure, which in JSON, looks like this:

[source,json,indent=0]
----
{
    "schema": { // <1>
        "type": "struct",
        "fields": [ // <2>
            {
                "type": "int32",
                "optional": false,
                "field": "id"
            }
        ],
        "optional": false, // <3>
        "name": "server1.testDB.dbo.customers.Key" // <4>
    },
    "payload": { // <5>
        "id": 1004
    }
}
----

.Description of change event key
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion.

|2
|`fields`
|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required. In this example, there is one required field named `id` of type `int32`.

|3
|`optional`
|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.

|4
|`server1.dbo.testDB.customers.Key`
a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-schema-name_._table-name_.`Key`. In this example: +

* `server1` is the name of the connector that generated this event. +
* `dbo` is the database schema for the table that was changed. +
* `customers` is the table that was updated.

|5
|`payload`
|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1004`.

|===

[NOTE]
====
When {prodname} emits a change event record, it sets the message key for each record to the name of the primary key or unique key column of the source table.
{prodname} must be able to read these columns to function properly.
If you set the xref:sqlserver-property-column-include-list[`column.include.list`] or xref:sqlserver-property-column-exclude-list[`column.exclude.list`] properties in the connector configuration,
be sure that your settings permit the connector to capture the required primary key or unique key columns.
====

[WARNING]
====
If the table does not have a primary or unique key, then the change event's key is null. This makes sense since the rows in a table without a primary or unique key constraint cannot be uniquely identified.
====


// Type: concept
// ModuleID: about-values-in-debezium-sql-server-change-events
// Title: About values in {prodname} SQL Server change events
[[sqlserver-change-event-values]]
==== Change event values

The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure.

Consider the same sample table that was used to show an example of a change event key:

[source,sql,indent=0]
----
CREATE TABLE customers (
  id INTEGER IDENTITY(1001,1) NOT NULL PRIMARY KEY,
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE
);
----

The value portion of a change event for a change to this table is described for each event type.


[[sqlserver-create-events]]
===== _create_ events

The following example shows the value portion of a change event that the connector generates for an operation that creates data in the `customers` table:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": { // <1>
    "type": "struct",
    "fields": [
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "id"
          },
          {
            "type": "string",
            "optional": false,
            "field": "first_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "last_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "email"
          }
        ],
        "optional": true,
        "name": "server1.dbo.testDB.customers.Value", // <2>
        "field": "before"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "id"
          },
          {
            "type": "string",
            "optional": false,
            "field": "first_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "last_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "email"
          }
        ],
        "optional": true,
        "name": "server1.dbo.testDB.customers.Value",
        "field": "after"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "string",
            "optional": false,
            "field": "version"
          },
          {
            "type": "string",
            "optional": false,
            "field": "connector"
          },
          {
            "type": "string",
            "optional": false,
            "field": "name"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ms"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_us"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ns"
          },
          {
            "type": "boolean",
            "optional": true,
            "default": false,
            "field": "snapshot"
          },
          {
            "type": "string",
            "optional": false,
            "field": "db"
          },
          {
            "type": "string",
            "optional": false,
            "field": "schema"
          },
          {
            "type": "string",
            "optional": false,
            "field": "table"
          },
          {
            "type": "string",
            "optional": true,
            "field": "change_lsn"
          },
          {
            "type": "string",
            "optional": true,
            "field": "commit_lsn"
          },
          {
            "type": "int64",
            "optional": true,
            "field": "event_serial_no"
          }
        ],
        "optional": false,
        "name": "io.debezium.connector.sqlserver.Source", // <3>
        "field": "source"
      },
      {
        "type": "string",
        "optional": false,
        "field": "op"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ms"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_us"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ns"
      }
    ],
    "optional": false,
    "name": "server1.dbo.testDB.customers.Envelope" // <4>
  },
  "payload": { // <5>
    "before": null, // <6>
    "after": { // <7>
      "id": 1005,
      "first_name": "john",
      "last_name": "doe",
      "email": "john.doe@example.org"
    },
    "source": { // <8>
      "version": "{debezium-version}",
      "connector": "sqlserver",
      "name": "server1",
      "ts_ms": 1559729468470,
      "ts_us": 1559729468470000,
      "ts_ns": 1559729468470000000,
      "snapshot": false,
      "db": "testDB",
      "schema": "dbo",
      "table": "customers",
      "change_lsn": "00000027:00000758:0003",
      "commit_lsn": "00000027:00000758:0005",
      "event_serial_no": "1"
    },
    "op": "c", // <9>
    "ts_ms": 1559729471739, // <10>
    "ts_ms": 1559729471739876, // <10>
    "ts_ms": 1559729471739876149 // <10>
  }
}
----


.Descriptions of _create_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The value's schema, which describes the structure of the value's payload. A change event's value schema is the same in every change event that the connector generates for a particular table.

|2
|`name`
a|In the `schema` section, each `name` field specifies the schema for a field in the value's payload. +
 +
`server1.dbo.testDB.customers.Value` is the schema for the payload's `before` and `after` fields. This schema is specific to the `customers` table. +
 +
 Names of schemas for `before` and `after` fields are of the form `_logicalName_._database-schemaName_._tableName_.Value`, which ensures that the schema name is unique in the database.
 This means that when using the {link-prefix}:{link-avro-serialization}#avro-serialization[Avro converter], the resulting Avro schema for each table in each logical source has its own evolution and history.

|3
|`name`
a|`io.debezium.connector.sqlserver.Source` is the schema for the payload's `source` field. This schema is specific to the SQL Server connector. The connector uses it for all events that it generates.

|4
|`name`
a|`server1.dbo.testDB.customers.Envelope` is the schema for the overall structure of the payload, where `server1` is the connector name, `dbo` is the database schema name, and `customers` is the table.

|5
|`payload`
|The value's actual data. This is the information that the change event is providing. +
 +
It may appear that the JSON representations of the events are much larger than the rows they describe. This is because the JSON representation must include the schema and the payload portions of the message.
However, by using the {link-prefix}:{link-avro-serialization}#avro-serialization[Avro converter], you can significantly decrease the size of the messages that the connector streams to Kafka topics.

|6
|`before`
|An optional field that specifies the state of the row before the event occurred. When the `op` field is `c` for create, as it is in this example, the `before` field is `null` since this change event is for new content.

|7
|`after`
|An optional field that specifies the state of the row after the event occurred. In this example, the `after` field contains the values of the new row's `id`, `first_name`, `last_name`, and `email` columns.

|8
|`source`
a|Mandatory field that describes the source metadata for the event. This field contains information that you can use to compare this event with other events, with regard to the origin of the events, the order in which the events occurred, and whether events were part of the same transaction. The source metadata includes:

* {prodname} version
* Connector type and name
* Database and schema names
* Timestamp for when the change was made in the database
* If the event was part of a snapshot
* Name of the table that contains the new row
* Server log offsets

|9
|`op`
a|Mandatory string that describes the type of operation that caused the connector to generate the event. In this example, `c` indicates that the operation created a row. Valid values are:

* `c` = create
* `u` = update
* `d` = delete
* `r` = read (applies to only snapshots)

|10
|`ts_ms`, `ts_us`, `ts_ns`
a| Optional field that displays the time at which the connector processed the event.
In the event message envelope, the time is based on the system clock in the JVM running the Kafka Connect task. +
 +
In the `source` object, `ts_ms` indicates the time when a change was committed in the database.
By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

[[sqlserver-update-events]]
===== _update_ events

The value of a change event for an update in the sample `customers` table has the same schema as a _create_ event for that table. Likewise, the event value's payload has the same structure. However, the event value payload contains different values in an _update_ event. Here is an example of a change event value in an event that the connector generates for an update in the `customers` table:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": { ... },
  "payload": {
    "before": { // <1>
      "id": 1005,
      "first_name": "john",
      "last_name": "doe",
      "email": "john.doe@example.org"
    },
    "after": { // <2>
      "id": 1005,
      "first_name": "john",
      "last_name": "doe",
      "email": "noreply@example.org"
    },
    "source": { // <3>
      "version": "{debezium-version}",
      "connector": "sqlserver",
      "name": "server1",
      "ts_ms": 1559729995937,
      "ts_us": 1559729995937000,
      "ts_ns": 1559729995937000000,
      "snapshot": false,
      "db": "testDB",
      "schema": "dbo",
      "table": "customers",
      "change_lsn": "00000027:00000ac0:0002",
      "commit_lsn": "00000027:00000ac0:0007",
      "event_serial_no": "2"
    },
    "op": "u", // <4>
    "ts_ms": 1559729998706,  // <5>
    "ts_us": 1559729998706318,  // <5>
    "ts_ns": 1559729998706318547  // <5>
  }
}
----


.Descriptions of _update_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|An optional field that specifies the state of the row before the event occurred. In an _update_ event value, the `before` field contains a field for each table column and the value that was in that column before the database commit. In this example, the `email` value is `john.doe@example.org.`

|2
|`after`
| An optional field that specifies the state of the row after the event occurred. You can compare the `before` and `after` structures to determine what the update to this row was. In the example, the `email` value is now `noreply@example.org`.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. The `source` field structure has the same fields as in a _create_ event, but some values are different, for example, the sample _update_ event has a different offset. The source metadata includes:

* {prodname} version
* Connector type and name
* Database and schema names
* Timestamp for when the change was made in the database
* If the event was part of a snapshot
* Name of the table that contains the new row
* Server log offsets

The `event_serial_no` field differentiates events that have the same commit and change LSN. Typical situations for when this field has a value other than `1`:

* _update_ events have the value set to `2` because the update generates two events in the CDC change table of SQL Server (link:https://docs.microsoft.com/en-us/sql/relational-databases/system-tables/cdc-capture-instance-ct-transact-sql?view=sql-server-2017[see the source documentation for details]). The first event contains the old values and the second contains contains new values. The connector uses values in the first event to create the second event. The connector drops the first event.

* When a primary key is updated SQL Server emits two events. A _delete_ event for the removal of the record with the old primary key value and a _create_ event for the addition of the record with the new primary key.
Both operations share the same commit and change LSN and their event numbers are `1` and `2`, respectively.

|4
|`op`
a|Mandatory string that describes the type of operation. In an _update_ event value, the `op` field value is `u`, signifying that this row changed because of an update.

|5
|`ts_ms`, `ts_us`, `ts_ns`
a| Optional field that displays the time at which the connector processed the event.
In the event message envelope, the time is based on the system clock in the JVM running the Kafka Connect task. +
 +
In the `source` object, `ts_ms` indicates the time when the change was committed to the database.
By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

[NOTE]
====
Updating the columns for a row's primary/unique key changes the value of the row's key. When a key changes, {prodname} outputs _three_ events: a _delete_ event and a xref:sqlserver-tombstone-events[tombstone event] with the old key for the row, followed by a _create_ event with the new key for the row.
====

[[sqlserver-delete-events]]
===== _delete_ events

The value in a _delete_ change event has the same `schema` portion as _create_ and _update_ events for the same table. The `payload` portion in a _delete_ event for the sample `customers` table looks like this:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": { ... },
  },
  "payload": {
    "before": { <>
      "id": 1005,
      "first_name": "john",
      "last_name": "doe",
      "email": "noreply@example.org"
    },
    "after": null, <2>
    "source": { <3>
      "version": "{debezium-version}",
      "connector": "sqlserver",
      "name": "server1",
      "ts_ms": 1559730445243,
      "ts_us": 1559730445243000,
      "ts_ns": 1559730445243000000,
      "snapshot": false,
      "db": "testDB",
      "schema": "dbo",
      "table": "customers",
      "change_lsn": "00000027:00000db0:0005",
      "commit_lsn": "00000027:00000db0:0007",
      "event_serial_no": "1"
    },
    "op": "d", <4>
    "ts_ms": 1559730450205, <5>
    "ts_us": 1559730450205387, <5>
    "ts_ns": 1559730450205387492  <5>
  }
}
----

.Descriptions of _delete_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|Optional field that specifies the state of the row before the event occurred. In a _delete_ event value, the `before` field contains the values that were in the row before it was deleted with the database commit.

|2
|`after`
| Optional field that specifies the state of the row after the event occurred. In a _delete_ event value, the `after` field is `null`, signifying that the row no longer exists.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. In a _delete_ event value, the `source` field structure is the same as for _create_ and _update_ events for the same table. Many `source` field values are also the same. In a _delete_ event value, the `ts_ms` and `pos` field values, as well as other values, might have changed. But the `source` field in a _delete_ event value provides the same metadata:

* {prodname} version
* Connector type and name
* Database and schema names
* Timestamp for when the change was made in the database
* If the event was part of a snapshot
* Name of the table that contains the new row
* Server log offsets

|4
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `d`, signifying that this row was deleted.

|5
|`ts_ms`, `ts_us`, `ts_ns`
a| Optional field that displays the time at which the connector processed the event.
In the event message envelope, the time is based on the system clock in the JVM running the Kafka Connect task. +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database.
By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

SQL Server connector events are designed to work with link:{link-kafka-docs}/#compaction[Kafka log compaction]. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.

[[sqlserver-tombstone-events]]
.Tombstone events
When a row is deleted, the _delete_ event value still works with log compaction, because Kafka can remove all earlier messages that have that same key. However, for Kafka to remove all messages that have that same key, the message value must be `null`. To make this possible, after {prodname}’s SQL Server connector emits a _delete_ event, the connector emits a special tombstone event that has the same key but a `null` value.

// Type: assembly
// ModuleID: debezium-sql-server-connector-generated-events-that-represent-transaction-boundaries
// Title: {prodname} SQL Server connector-generated events that represent transaction boundaries
[[sqlserver-transaction-metadata]]
=== Transaction metadata

{prodname} can generate events that represent transaction boundaries and that enrich data change event messages.

[NOTE]
.Limits on when {prodname} receives transaction metadata
====
{prodname} registers and receives metadata only for transactions that occur after you deploy the connector.
Metadata for transactions that occur before you deploy the connector is not available.
====

Database transactions are represented by a statement block that is enclosed between the `BEGIN` and `END` keywords.
{prodname} generates transaction boundary events for the `BEGIN` and `END` delimiters in every transaction.
Transaction boundary events contain the following fields:

`status`:: `BEGIN` or `END`.
`id`:: String representation of the unique transaction identifier.
`ts_ms`:: The time of a transaction boundary event (`BEGIN` or `END` event) at the data source.
If the data source does not provide {prodname} with the event time, then the field instead represents the time at which {prodname} processes the event.
`event_count` (for `END` events):: Total number of events emmitted by the transaction.
`data_collections` (for `END` events):: An array of pairs of `data_collection` and `event_count` elements that indicates the number of events that the connector emits for changes that originate from a data collection.

[WARNING]
====
There is no way for {prodname} to reliably identify when a transaction has ended.
The transaction `END` marker is thus emitted only after the first event of another transaction arrives.
This can lead to the delayed delivery of `END` marker in case of a low-traffic system.
====

The following example shows a typical transaction boundary message:

.Example: SQL Server connector transaction boundary event
[source,json,indent=0,subs="+attributes"]
----
{
  "status": "BEGIN",
  "id": "00000025:00000d08:0025",
  "ts_ms": 1486500577125,
  "event_count": null,
  "data_collections": null
}

{
  "status": "END",
  "id": "00000025:00000d08:0025",
  "ts_ms": 1486500577691,
  "event_count": 2,
  "data_collections": [
    {
      "data_collection": "testDB.dbo.testDB.tablea",
      "event_count": 1
    },
    {
      "data_collection": "testDB.dbo.testDB.tableb",
      "event_count": 1
    }
  ]
}
----

Unless overridden via the xref:sqlserver-property-topic-transaction[`topic.transaction`] option,
transaction events are written to the topic named xref:sqlserver-property-topic-prefix[`_<topic.prefix>_`]`.transaction`.

//Type: concept
//ModuleID: change-data-event-enrichment
==== Change data event enrichment

When transaction metadata is enabled, the data message `Envelope` is enriched with a new `transaction` field.
This field provides information about every event in the form of a composite of fields:

`id`:: String representation of unique transaction identifier
`total_order`:: The absolute position of the event among all events generated by the transaction
`data_collection_order`:: The per-data collection position of the event among all events that were emitted by the transaction

The following example shows what a typical message looks like:

[source,json,indent=0,subs="+attributes"]
----
{
  "before": null,
  "after": {
    "pk": "2",
    "aa": "1"
  },
  "source": {
...
  },
  "op": "c",
  "ts_ms": "1580390884335",
  "ts_us": "1580390884335172",
  "ts_ns": "1580390884335172574",
  "transaction": {
    "id": "00000025:00000d08:0025",
    "total_order": "1",
    "data_collection_order": "1"
  }
}
----

// Type: reference
// ModuleID: how-debezium-sql-server-connectors-map-data-types
// Title: How {prodname} SQL Server connectors map data types
[[sqlserver-data-types]]
=== Data type mappings

The {prodname} SQL Server connector represents changes to table row data by producing events that are structured like the table in which the row exists.
Each event contains fields to represent the column values for the row.
The way in which an event represents the column values for an operation depends on the SQL data type of the column.
In the event, the connector maps the fields for each SQL Server data type to both a _literal type_ and a _semantic type_.

The connector can map SQL Server data types to both _literal_ and _semantic_ types.

Literal type:: Describes how the value is literally represented by using Kafka Connect schema types, namely `INT8`, `INT16`, `INT32`, `INT64`, `FLOAT32`, `FLOAT64`, `BOOLEAN`, `STRING`, `BYTES`, `ARRAY`, `MAP`, and `STRUCT`.
Semantic type:: Describes how the Kafka Connect schema captures the _meaning_ of the field using the name of the Kafka Connect schema for the field.

If the default data type conversions do not meet your needs, you can {link-prefix}:{link-custom-converters}#custom-converters[create a custom converter] for the connector.


[id="sql-server-basic-values"]
==== Basic types

The following table shows how the connector maps basic SQL Server data types.

.Data type mappings used by the SQL Server connector
[cols="30%a,25%a,45%a",options="header"]
|===
|SQL Server data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`BIT`
|`BOOLEAN`
|n/a

|`TINYINT`
|`INT16`
|n/a

|`SMALLINT`
|`INT16`
|n/a

|`INT`
|`INT32`
|n/a

|`BIGINT`
|`INT64`
|n/a

|`REAL`
|`FLOAT32`
|n/a

|`FLOAT[(N)]`
|`FLOAT64`
|n/a

|`CHAR[(N)]`
|`STRING`
|n/a

|`VARCHAR[(N)]`
|`STRING`
|n/a

|`TEXT`
|`STRING`
|n/a

|`NCHAR[(N)]`
|`STRING`
|n/a

|`NVARCHAR[(N)]`
|`STRING`
|n/a

|`NTEXT`
|`STRING`
|n/a

|`XML`
|`STRING`
|`io.debezium.data.Xml` +
 +
Contains the string representation of an XML document

|`DATETIMEOFFSET[(P)]`
|`STRING`
|`io.debezium.time.ZonedTimestamp` +
 +
A string representation of a timestamp with timezone information, where the timezone is GMT

|===

Other data type mappings are described in the following sections.

If present, a column's default value is propagated to the corresponding field's Kafka Connect schema.
Change messages will contain the field's default value
(unless an explicit column value had been given), so there should rarely be the need to obtain the default value from the schema.
Passing the default value helps though with satisfying the compatibility rules when {link-prefix}:{link-avro-serialization}[using Avro] as serialization format together with the Confluent schema registry.

[[sql-server-temporal-values]]
==== Temporal values

Other than SQL Server's `DATETIMEOFFSET` data type (which contain time zone information), the other temporal types depend on the value of the `time.precision.mode` configuration property.  When the `time.precision.mode` configuration property is set to `adaptive` (the default), then the connector will determine the literal type and semantic type for the temporal types based on the column's data type definition so that events _exactly_ represent the values in the database:

[cols="30%a,25%a,45%a",options="header"]
|===
|SQL Server data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`DATE`
|`INT32`
|`io.debezium.time.Date` +
 +
Represents the number of days since the epoch.

|`TIME(0)`, `TIME(1)`, `TIME(2)`, `TIME(3)`
|`INT32`
|`io.debezium.time.Time` +
 +
Represents the number of milliseconds past midnight, and does not include timezone information.

|`TIME(4)`, `TIME(5)`, `TIME(6)`
|`INT64`
|`io.debezium.time.MicroTime` +
 +
Represents the number of microseconds past midnight, and does not include timezone information.

|`TIME(7)`
|`INT64`
|`io.debezium.time.NanoTime` +
 +
Represents the number of nanoseconds past midnight, and does not include timezone information.

|`DATETIME`
|`INT64`
|`io.debezium.time.Timestamp` +
 +
Represents the number of milliseconds past the epoch, and does not include timezone information.

|`SMALLDATETIME`
|`INT64`
|`io.debezium.time.Timestamp` +
 +
Represents the number of milliseconds past the epoch, and does not include timezone information.

|`DATETIME2(0)`, `DATETIME2(1)`, `DATETIME2(2)`, `DATETIME2(3)`
|`INT64`
|`io.debezium.time.Timestamp` +
 +
Represents the number of milliseconds past the epoch, and does not include timezone information.

|`DATETIME2(4)`, `DATETIME2(5)`, `DATETIME2(6)`
|`INT64`
|`io.debezium.time.MicroTimestamp` +
 +
Represents the number of microseconds past the epoch, and does not include timezone information.

|`DATETIME2(7)`
|`INT64`
|`io.debezium.time.NanoTimestamp` +
 +
Represents the number of nanoseconds past the epoch, and does not include timezone information.

|===

When the `time.precision.mode` configuration property is set to `connect`, then the connector will use the predefined Kafka Connect logical types. This may be useful when consumers only know about the built-in Kafka Connect logical types and are unable to handle variable-precision time values. On the other hand, since SQL Server supports tenth of microsecond precision, the events generated by a connector with the `connect` time precision mode will *result in a loss of precision* when the database column has a _fractional second precision_ value greater than 3:

[cols="25%a,20%a,55%a",options="header"]
|===
|SQL Server data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`DATE`
|`INT32`
|`org.apache.kafka.connect.data.Date` +
 +
Represents the number of days since the epoch.

|`TIME([P])`
|`INT64`
|`org.apache.kafka.connect.data.Time` +
 +
Represents the number of milliseconds since midnight, and does not include timezone information. SQL Server allows `P` to be in the range 0-7 to store up to tenth of a microsecond precision, though this mode results in a loss of precision when `P` > 3.

|`DATETIME`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp` +
 +
Represents the number of milliseconds since the epoch, and does not include timezone information.

|`SMALLDATETIME`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp` +
 +
Represents the number of milliseconds past the epoch, and does not include timezone information.

|`DATETIME2`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp` +
 +
Represents the number of milliseconds since the epoch, and does not include timezone information. SQL Server allows `P` to be in the range 0-7 to store up to tenth of a microsecond precision, though this mode results in a loss of precision when `P` > 3.

|===

[[sql-server-timestamp-values]]
===== Timestamp values

The `DATETIME`, `SMALLDATETIME` and `DATETIME2` types represent a timestamp without time zone information.
Such columns are converted into an equivalent Kafka Connect value based on UTC.
So for instance the `DATETIME2` value "2018-06-20 15:13:16.945104" is represented by a `io.debezium.time.MicroTimestamp` with the value "1529507596945104".

Note that the timezone of the JVM running Kafka Connect and {prodname} does not affect this conversion.

[id="sql-server-decimal-values"]
==== Decimal values

{prodname} connectors handle decimals according to the setting of the xref:sqlserver-property-decimal-handling-mode[`decimal.handling.mode` connector configuration property].

decimal.handling.mode=precise::
+
.Mappings when `decimal.handling.mode=precise`
[cols="30%a,15%a,55%a",options="header",subs="+attributes"]
|===
|SQL Server type
|Literal type (schema type)
|Semantic type (schema name)

|`NUMERIC[(P[,S])]`
|`BYTES`
a|`org.apache.kafka.connect.data.Decimal` +
The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.

|`DECIMAL[(P[,S])]`
|`BYTES`
a|`org.apache.kafka.connect.data.Decimal` +
The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.

|`SMALLMONEY`
|`BYTES`
a|`org.apache.kafka.connect.data.Decimal` +
The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.

|`MONEY`
|`BYTES`
a|`org.apache.kafka.connect.data.Decimal` +
The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.

|===

decimal.handling.mode=double::
+
.Mappings when `decimal.handling.mode=double`
[cols="30%a,30%a,40%a",options="header",subs="+attributes"]
|===
|SQL Server type |Literal type |Semantic type

|`NUMERIC[(M[,D])]`
|`FLOAT64`
a|_n/a_

|`DECIMAL[(M[,D])]`
|`FLOAT64`
a|_n/a_

|`SMALLMONEY[(M[,D])]`
|`FLOAT64`
a|_n/a_

|`MONEY[(M[,D])]`
|`FLOAT64`
a|_n/a_

|===

decimal.handling.mode=string::
+
.Mappings when `decimal.handling.mode=string`
[cols="30%a,30%a,40%a",options="header",subs="+attributes"]
|===
|SQL Server type |Literal type |Semantic type

|`NUMERIC[(M[,D])]`
|`STRING`
a|_n/a_

|`DECIMAL[(M[,D])]`
|`STRING`
a|_n/a_

|`SMALLMONEY[(M[,D])]`
|`STRING`
a|_n/a_

|`MONEY[(M[,D])]`
|`STRING`
a|_n/a_

|===

// Type: assembly
// ModuleID: setting-up-sql-server-for-use-with-the-debezium-sql-server-connector
//Title: Setting up SQL Server to run a {prodname} connector
[[setting-up-sqlserver]]
== Setting up SQL Server

For {prodname} to capture change events from SQL Server tables, a SQL Server administrator with the necessary privileges must first run a query to enable CDC on the database.
The administrator must then enable CDC for each table that you want Debezium to capture.

[NOTE]
====
By default, JDBC connections to Microsoft SQL Server are protected by SSL encryption.
If SSL is not enabled for a SQL Server database, or if you want to connect to the database without using SSL, you can disable SSL by setting the value of  the `database.encrypt` property in connector configuration to `false`.
====


After CDC is applied, it captures all of the `INSERT`, `UPDATE`, and `DELETE` operations that are committed to the tables for which CDC is enabled.
The {prodname} connector can then capture these events and emit them to Kafka topics.

// Type: procedure
// ModuleID: enabling-cdc-on-the-sql-server-database
=== Enabling CDC on the SQL Server database

Before you can enable CDC for a table, you must enable it for the SQL Server database.
A SQL Server administrator enables CDC by running a system stored procedure.
System stored procedures can be run by using SQL Server Management Studio, or by using Transact-SQL.

.Prerequisites
* You are a member of the _sysadmin_ fixed server role for the SQL Server.
* You are a db_owner of the database.
* The SQL Server Agent is running.

NOTE: The SQL Server CDC feature processes changes that occur in user-created tables only. You cannot enable CDC on the SQL Server `master` database.

.Procedure

. From the *View* menu in SQL Server Management Studio, click *Template Explorer*.
. In the *Template Browser*, expand *SQL Server Templates*.
. Expand *Change Data Capture > Configuration* and then click *Enable Database for CDC*.
. In the template, replace the database name in the `USE` statement with the name of the database that you want to enable for CDC.
. Run the stored procedure `sys.sp_cdc_enable_db` to enable the database for CDC.
+
After the database is enabled for CDC, a schema with the name `cdc` is created, along with a CDC user, metadata tables, and other system objects.
+
The following example shows how to enable CDC for the database `MyDB`:
+
.Example: Enabling a SQL Server database for the CDC template
[source,sql]
----
USE MyDB
GO
EXEC sys.sp_cdc_enable_db
GO
----

// Type: procedure
// ModuleID: enabling-cdc-on-a-sql-server-table
=== Enabling CDC on a SQL Server table

A SQL Server administrator must enable change data capture on the source tables that you want to Debezium to capture.
The database must already be enabled for CDC.
To enable CDC on a table, a SQL Server administrator runs the stored procedure `sys.sp_cdc_enable_table` for the table.
The stored procedures can be run by using SQL Server Management Studio, or by using Transact-SQL.
SQL Server CDC must be enabled for every table that you want to capture.

.Prerequisites
* CDC is enabled on the SQL Server database.
* The SQL Server Agent is running.
* You are a member of the `db_owner` fixed database role for the database.

.Procedure
. From the *View* menu in SQL Server Management Studio, click *Template Explorer*.
. In the *Template Browser*, expand *SQL Server Templates*.
. Expand *Change Data Capture > Configuration*, and then click *Enable Table Specifying Filegroup Option*.
. In the template, replace the table name in the `USE` statement with the name of the table that you want to capture.
. Run the stored procedure `sys.sp_cdc_enable_table`.
+
The following example shows how to enable CDC for the table `MyTable`:
+
.Example: Enabling CDC for a SQL Server table
[source,sql]
----
USE MyDB
GO

EXEC sys.sp_cdc_enable_table
@source_schema = N'dbo',
@source_name   = N'MyTable', //<.>
@role_name     = N'MyRole',  //<.>
@filegroup_name = N'MyDB_CT',//<.>
@supports_net_changes = 0
GO
----
<.> Specifies the name of the table that you want to capture.
<.> Specifies a role `MyRole` to which you can add users to whom you want to grant `SELECT` permission on the captured columns of the source table.
Users in the `sysadmin` or `db_owner` role also have access to the specified change tables. Set the value of `@role_name` to `NULL`, to allow only members in the `sysadmin` or `db_owner` to have full access to captured information.
<.> Specifies the `filegroup` where SQL Server places the change table for the captured table.
The named `filegroup` must already exist.
It is best not to locate change tables in the same `filegroup` that you use for source tables.


// Type: procedure
// ModuleID: verifying-debezium-connector-access-to-the-cdc-table
=== Verifying that the user has access to the CDC table

A SQL Server administrator can run a system stored procedure to query a database or table to retrieve its CDC configuration information.
The stored procedures can be run by using SQL Server Management Studio, or by using Transact-SQL.

.Prerequisites
* You have `SELECT` permission on all of the captured columns of the capture instance.
Members of the `db_owner` database role can view information for all of the defined capture instances.
* You have membership in any gating roles that are defined for the table information that the query includes.

.Procedure

. From the *View* menu in SQL Server Management Studio, click *Object Explorer*.
. From the Object Explorer, expand *Databases*, and then expand your database object, for example, *MyDB*.
. Expand *Programmability > Stored Procedures > System Stored Procedures*.
. Run the `sys.sp_cdc_help_change_data_capture` stored procedure to query the table.
+
Queries should not return empty results.
+
The following example runs the stored procedure `sys.sp_cdc_help_change_data_capture` on the database `MyDB`:
+
.Example: Querying a table for CDC configuration information
[source, sql]
----
USE MyDB;
GO
EXEC sys.sp_cdc_help_change_data_capture
GO
----
+
The query returns configuration information for each table in the database that is enabled for CDC and that contains change data that the caller is authorized to access.
If the result is empty, verify that the user has privileges to access both the capture instance and the CDC tables.

// Type: concept
// ModuleID: debezium-sql-server-connector-on-azure
[[sqlserver-on-azure]]
=== SQL Server on Azure

The {prodname} SQL Server connector can be used with SQL Server on Azure.
Refer to https://learn.microsoft.com/en-us/samples/azure-samples/azure-sql-db-change-stream-debezium/azure-sql%2D%2Dsql-server-change-stream-with-debezium/[this example] for configuring CDC for SQL Server on Azure and using it with {prodname}.


[[sqlserver-always-on-replica]]
=== SQL Server Always On

The SQL Server connector can capture changes from an Always On read-only replica.

.Prerequisites
* Change data capture is configured and enabled on the primary node.
SQL Server does not support CDC directly on replicas.
* The configuration option `database.applicationIntent` is set to `ReadOnly`.
This is required by SQL Server.
When {prodname} detects this configuration option, it responds by taking the following actions:

** Sets `snapshot.isolation.mode` to `snapshot`, which is the only one transaction isolation mode supported for read-only replicas.
** Commits the (read-only) transaction in every execution of the streaming query loop, which is necessary to get the latest view of CDC data.


// Type: concept
// ModuleID: effect-of-sql-server-capture-job-agent-configuration-on-server-load-and-latency
=== Effect of SQL Server capture job agent configuration on server load and latency

When a database administrator enables change data capture for a source table, the capture job agent begins to run.
The agent reads new change event records from the transaction log and replicates the event records to a change data table.
Between the time that a change is committed in the source table, and the time that the change appears in the corresponding change table, there is always a small latency interval.
This latency interval represents a gap between when changes occur in the source table and when they become available for {prodname} to stream to Apache Kafka.

Ideally, for applications that must respond quickly to changes in data, you want to maintain close synchronization between the source and change tables.
You might imagine that running the capture agent to continuously process change events as rapidly as possible might result in increased throughput and reduced latency --
populating change tables with new event records as soon as possible after the events occur, in near real time.
However, this is not necessarily the case.
There is a performance penalty to pay in the pursuit of more immediate synchronization.
Each time that the capture job agent queries the database for new event records, it increases the CPU load on the database host.
The additional load on the server can have a negative effect on overall database performance, and potentially reduce transaction efficiency, especially during times of peak database use.

It's important to monitor database metrics so that you know if the database reaches the point where the server can no longer support the capture agent's level of activity.
If you notice performance problems, there are SQL Server capture agent settings that you can modify to help balance the overall CPU load on the database host with a tolerable degree of latency.

// Type: reference
// ModuleID: sql-server-capture-job-agent-configuration-parameters
=== SQL Server capture job agent configuration parameters

On SQL Server, parameters that control the behavior of the capture job agent are defined in the SQL Server table link:https://docs.microsoft.com/en-us/sql/relational-databases/system-tables/dbo-cdc-jobs-transact-sql?view=latest[`msdb.dbo.cdc_jobs`].
If you experience performance issues while running the capture job agent, adjust capture jobs settings to reduce CPU load by running the link:https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sys-sp-cdc-change-job-transact-sql?view=latest[`sys.sp_cdc_change_job`] stored procedure and supplying new values.

[NOTE]
====
Specific guidance about how to configure SQL Server capture job agent parameters is beyond the scope of this documentation.
====

The following parameters are the most significant for modifying capture agent behavior for use with the {prodname} SQL Server connector:

`pollinginterval`::
* Specifies the number of seconds that the capture agent waits between log scan cycles.
* A higher value reduces the load on the database host and increases latency.
* A value of `0` specifies no wait between scans.
* The default value is `5`.

`maxtrans`::
* Specifies the maximum number of transactions to process during each log scan cycle.
After the capture job processes the specified number of transactions, it pauses for the length of time that the `pollinginterval` specifies before the next scan begins.
* A lower value reduces the load on the database host and increases latency.
* The default value is `500`.

`maxscans`::
* Specifies a limit on the number of scan cycles that the capture job can attempt in capturing the full contents of the database transaction log.
If the `continuous` parameter is set to `1`, the job pauses for the length of time that the `pollinginterval` specifies before it resumes scanning.
* A lower values reduces the load on the database host and increases latency.
* The default value is `10`.

.Additional resources
* For more information about capture agent parameters, see the SQL Server documentation.

// Type: assembly
// ModuleID: deployment-of-debezium-sql-server-connectors
// Title: Deployment of {prodname} SQL Server connectors
[[sqlserver-deploying-a-connector]]
== Deployment

To deploy a {prodname} SQL Server connector, you install the {prodname} SQL Server connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect.

.Prerequisites
* link:https://zookeeper.apache.org/[Apache ZooKeeper], link:http://kafka.apache.org/[Apache Kafka], and link:{link-kafka-docs}.html#connect[Kafka Connect] are installed.
* SQL Server is installed, is xref:setting-up-sqlserver[configured for CDC], and is ready to be used with the {prodname} connector.

.Procedure
. Download the {prodname} https://repo1.maven.org/maven2/io/debezium/debezium-connector-sqlserver/{debezium-version}/debezium-connector-sqlserver-{debezium-version}-plugin.tar.gz[SQL Server connector plug-in archive]
. Extract the files into your Kafka Connect environment.
. Add the directory with the JAR files to {link-kafka-docs}/#connectconfigs[Kafka Connect's `plugin.path`].
. xref:sqlserver-example-configuration[Configure the connector] and xref:sqlserver-adding-connector-configuration[add the configuration to your Kafka Connect cluster.]
. Restart your Kafka Connect process to pick up the new JAR files.

If you are working with immutable containers, see link:https://quay.io/organization/debezium[{prodname}'s container images] for Åpache ZooKeeper, Apache Kafka, and Kafka Connect.
You can pull the official link:https://hub.docker.com/_/microsoft-mssql-server[container images for Microsoft SQL Server on Linux] from Docker Hub.

You can also xref:operations/openshift.adoc[run {prodname} on Kubernetes and OpenShift].


[[sqlserver-example-configuration]]
=== SQL Server connector configuration example

Following is an example of the configuration for a connector instance that captures data from a SQL Server server at port 1433 on 192.168.99.100, which we logically name `fullfillment`.
Typically, you configure the {prodname} SQL Server connector in a JSON file by setting the configuration properties that are available for the connector.

You can choose to produce events for a subset of the schemas and tables in a database.
Optionally, you can ignore, mask, or truncate columns that contain sensitive data, that are larger than a specified size, or that you do not need.

[source,json]
----
{
    "name": "inventory-connector", // <1>
    "config": {
        "connector.class": "io.debezium.connector.sqlserver.SqlServerConnector", // <2>
        "database.hostname": "192.168.99.100", // <3>
        "database.port": "1433", // <4>
        "database.user": "sa", // <5>
        "database.password": "Password!", // <6>
        "database.names": "testDB1,testDB2", // <7>
        "topic.prefix": "fullfillment", // <8>
        "table.include.list": "dbo.customers", // <9>
        "schema.history.internal.kafka.bootstrap.servers": "kafka:9092", // <10>
        "schema.history.internal.kafka.topic": "schemahistory.fullfillment", // <11>
        "database.ssl.truststore": "path/to/trust-store", // <12>
        "database.ssl.truststore.password": "password-for-trust-store" // <13>
    }
}
----
<1> The name of our connector when we register it with a Kafka Connect service.
<2> The name of this SQL Server connector class.
<3> The address of the SQL Server instance.
<4> The port number of the SQL Server instance.
<5> The name of the SQL Server user
<6> The password for the SQL Server user
<7> The name of the database to capture changes from.
<8> The topic prefix for the SQL Server instance/cluster, which forms a namespace and is used in all the names of the Kafka topics to which the connector writes, the Kafka Connect schema names, and the namespaces of the corresponding Avro schema when the {link-prefix}:{link-avro-serialization}#avro-serialization[Avro converter] is used.
<9> A list of all tables whose changes {prodname} should capture.
<10> The list of Kafka brokers that this connector will use to write and recover DDL statements to the database schema history topic.
<11> The name of the database schema history topic where the connector will write and recover DDL statements. This topic is for internal use only and should not be used by consumers.
<12> The path to the SSL truststore that stores the server's signer certificates.
This property is required unless database encryption is disabled (`database.encrypt=false`).
<13> The SSL truststore password.
This property is required unless database encryption is disabled (`database.encrypt=false`).

For the complete list of the configuration properties that you can set for the {prodname} SQL Server connector, see xref:sqlserver-connector-properties[SQL Server connector properties].

You can send this configuration with a `POST` command to a running Kafka Connect service.
The service records the configuration and start up the one connector task that performs the following tasks:

* Connects to the SQL Server database.
* Reads the transaction log.
* Records change events to Kafka topics.

[[sqlserver-adding-connector-configuration]]
=== Adding connector configuration

To start running a {prodname} SQL Server connector, create a connector configuration, and add the configuration to your Kafka Connect cluster.

.Prerequisites

* xref:setting-up-sqlserver[CDC is enabled on SQL Server].
* The {prodname} SQL Server connector is installed.

.Procedure

. Create a configuration for the SQL Server connector.

. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster.

.Results

When the connector starts, it xref:sqlserver-snapshots[performs a consistent snapshot] of the SQL Server databases that the connector is configured for.
The connector then starts generating data change events for row-level operations and streaming the change event records to Kafka topics.

// Type: reference
// Title: Descriptions of {prodname} SQL Server connector configuration properties
// ModuleID: descriptions-of-debezium-sqlserver-connector-configuration-properties
[[sqlserver-connector-properties]]
=== Connector properties

The {prodname} SQL Server connector has numerous configuration properties that you can use to achieve the right connector behavior for your application.
Many properties have default values.

Information about the properties is organized as follows:

* xref:sqlserver-required-connector-configuration-properties[Required connector configuration properties]
* xref:sqlserver-advanced-connector-configuration-properties[Advanced connector configuration properties]
* xref:debezium-sqlserver-connector-database-history-configuration-properties[Database schema history connector configuration properties] that control how {prodname} processes events that it reads from the database schema history topic.
** xref:sqlserver-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[Pass-through database schema history properties]
* xref:debezium-sqlserver-connector-pass-through-database-driver-configuration-properties[Pass-through database driver properties] that control the behavior of the database driver.

[id="sqlserver-required-connector-configuration-properties"]
==== Required {prodname} SQL Server connector configuration properties

The following configuration properties are _required_ unless a default value is available.

[cols="30%a,25%a,45%a",options="header"]
|===
|Property
|Default
|Description

|[[sqlserver-property-name]]<<sqlserver-property-name, `+name+`>>
|No default
|Unique name for the connector. Attempting to register again with the same name will fail. (This property is required by all Kafka Connect connectors.)

|[[sqlserver-property-connector-class]]<<sqlserver-property-connector-class, `+connector.class+`>>
|No default
|The name of the Java class for the connector. Always use a value of `io.debezium.connector.sqlserver.SqlServerConnector` for the SQL Server connector.

|[[sqlserver-property-tasks-max]]<<sqlserver-property-tasks-max, `+tasks.max+`>>
|`1`
|Specifies the maximum number of tasks that the connector can use to capture data from the database instance.
If the xref:sqlserver-property-database-names[`database.names`] list contains more than one element, you can increase the value of this property to a number less than or equal to the number of elements in the list.
|[[sqlserver-property-database-hostname]]<<sqlserver-property-database-hostname, `+database.hostname+`>>
|No default
|IP address or hostname of the SQL Server database server.

|[[sqlserver-property-database-port]]<<sqlserver-property-database-port, `+database.port+`>>
|`1433`
|Integer port number of the SQL Server database server.
If both `database.port` and `database.instance` are specified, `database.instance` is ignored.
See https://learn.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url[JDBC driver for SQL server documentation] for more details.

|[[sqlserver-property-database-user]]<<sqlserver-property-database-user, `+database.user+`>>
|No default
|Username to use when connecting to the SQL Server database server.
Can be omitted when using Kerberos authentication, which can be configured using xref:debezium-{context}-connector-pass-through-database-driver-configuration-properties[pass-through properties].

|[[sqlserver-property-database-password]]<<sqlserver-property-database-password, `+database.password+`>>
|No default
|Password to use when connecting to the SQL Server database server.

|[[sqlserver-property-database-instance]] <<sqlserver-property-database-instance, `+database.instance+`>>
|No default
|Specifies the instance name of the link:https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/database-engine-instances-sql-server?view=sql-server-latest#instances[SQL Server named instance].
If both `database.port` and `database.instance` are specified, `database.instance` is ignored.
See https://learn.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url[JDBC driver for SQL server documentation] for more details.

|[[sqlserver-property-database-names]]<<sqlserver-property-database-names, `+database.names+`>>
|No default
|The comma-separated list of the SQL Server database names from which to stream the changes.
|[[sqlserver-property-topic-prefix]]<<sqlserver-property-topic-prefix, `+topic.prefix+`>>
|No default
|Topic prefix that provides a namespace for the SQL Server database server that you want {prodname} to capture.
The prefix should be unique across all other connectors, since it is used as the prefix for all Kafka topic names that receive records from this connector.
Only alphanumeric characters, hyphens, dots and underscores must be used in the database server logical name. +
 +
[WARNING]
====
Do not change the value of this property.
If you change the name value, after a restart, instead of continuing to emit events to the original topics, the connector emits subsequent events to topics whose names are based on the new value.
The connector is also unable to recover its database schema history topic.
====

|[[sqlserver-property-schema-include-list]]<<sqlserver-property-schema-include-list, `+schema.include.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match names of schemas for which you *want* to capture changes.
Any schema name not included in `schema.include.list` is excluded from having its changes captured.
By default, the connector captures changes for all non-system schemas. +

To match the name of a schema, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the schema; it does not match substrings that might be present in a schema name. +
If you include this property in the configuration, do not also set the `schema.exclude.list` property.

|[[sqlserver-property-schema-exclude-list]]<<sqlserver-property-schema-exclude-list, `+schema.exclude.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match names of schemas for which you *do not* want to capture changes.
Any schema whose name is not included in `schema.exclude.list` has its changes captured, with the exception of system schemas. +

To match the name of a schema, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the schema; it does not match substrings that might be present in a schema name. +
If you include this property in the configuration, do not set the `schema.include.list` property.

|[[sqlserver-property-table-include-list]]<<sqlserver-property-table-include-list, `+table.include.list+`>>
|No default
|An optional comma-separated list of regular expressions that match fully-qualified table identifiers for tables that you want {prodname} to capture.
By default, the connector captures all non-system tables for the designated schemas.
When this property is set, the connector captures changes only from the specified tables.
Each identifier is of the form _schemaName_._tableName_. +

To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name. +
If you include this property in the configuration, do not also set the `table.exclude.list` property.

|[[sqlserver-property-table-exclude-list]]<<sqlserver-property-table-exclude-list, `+table.exclude.list+`>>
|No default
|An optional comma-separated list of regular expressions that match fully-qualified table identifiers for the tables that you want to exclude from being captured.
{prodname} captures all tables that are not included in `table.exclude.list`.
Each identifier is of the form _schemaName_._tableName_. +

To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name. +
If you include this property in the configuration, do not also set the `table.include.list` property.

|[[sqlserver-property-column-include-list]]<<sqlserver-property-column-include-list, `+column.include.list+`>>
|_empty string_
|An optional comma-separated list of regular expressions that match the fully-qualified names of columns that should be included in the change event message values.
Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_. +

[NOTE]
====
Each change event record that {prodname} emits for a table includes an event key that contains fields for each column in the table's primary key or unique key.
To ensure that event keys are generated correctly, if you set this property, be sure to explicitly list the primary key columns of any captured tables.
====

To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; it does not match substrings that might be present in a column name. +
If you include this property in the configuration, do not also set the `column.exclude.list` property.

|[[sqlserver-property-column-exclude-list]]<<sqlserver-property-column-exclude-list, `+column.exclude.list+`>>
|_empty string_
|An optional comma-separated list of regular expressions that match the fully-qualified names of columns that should be excluded from change event message values.
Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_.
Note that primary key columns are always included in the event's key, also if excluded from the value. +

To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; it does not match substrings that might be present in a column name. +
If you include this property in the configuration, do not also set the `column.include.list` property.

|[[sqlserver-property-skip-messages-without-change]]<<sqlserver-property-skip-messages-without-change, `+skip.messages.without.change+`>>
|`false`
| Specifies whether to skip publishing messages when there is no change in included columns. This would essentially filter messages if there is no change in columns included as per `column.include.list` or `column.exclude.list` properties.

|[[sqlserver-property-column-mask-hash]]<<sqlserver-property-column-mask-hash, `column.mask.hash._hashAlgorithm_.with.salt._salt_`>>;
[[sqlserver-property-column-mask-hash-v2]]<<sqlserver-property-column-mask-hash-v2, `column.mask.hash.v2._hashAlgorithm_.with.salt._salt_`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Fully-qualified names for columns are of the form _`<schemaName>_._<tableName>_._<columnName>`. +
To match the name of a column {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.
In the resulting change event record, the values for the specified columns are replaced with pseudonyms. +

A pseudonym consists of the hashed value that results from applying the specified _hashAlgorithm_ and _salt_.
Based on the hash function that is used, referential integrity is maintained, while column values are replaced with pseudonyms.
Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation. +
 +
In the following example, `CzQMA0cB5K` is a randomly selected salt. +

----
column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName
----

If necessary, the pseudonym is automatically shortened to the length of the column.
The connector configuration can include multiple properties that specify different hash algorithms and salts. +
 +
Depending on the _hashAlgorithm_ used, the _salt_ selected, and the actual data set, the resulting data set might not be completely masked. +
 +
Hashing strategy version 2 should be used to ensure fidelity if the value is being hashed in different places or systems.

|[[sqlserver-property-time-precision-mode]]<<sqlserver-property-time-precision-mode, `+time.precision.mode+`>>
|`adaptive`
| Time, date, and timestamps can be represented with different kinds of precision, including: `adaptive` (the default) captures the time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type; or `connect` always represents time and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which uses millisecond precision regardless of the database columns' precision.
For more information, see xref:sql-server-temporal-values[temporal values].

|[[sqlserver-property-decimal-handling-mode]]<<sqlserver-property-decimal-handling-mode,`+decimal.handling.mode+`>>
|`precise`
|Specifies how the connector should handle values for `DECIMAL` and `NUMERIC` columns: +
 +
`precise` (the default) represents them precisely using `java.math.BigDecimal` values represented in change events in a binary form. +
 +
`double` represents them using `double` values, which may result in a loss of precision but is easier to use. +
 +
`string` encodes values as formatted strings, which is easy to consume but  semantic information about the real type is lost.

|[[sqlserver-property-include-schema-changes]]<<sqlserver-property-include-schema-changes, `+include.schema.changes+`>>
|`true`
|Boolean value that specifies whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change is recorded with a key that contains the database name and a value that is a JSON structure that describes the schema update. This is independent of how the connector internally records database schema history. The default is `true`.

|[[sqlserver-property-tombstones-on-delete]]<<sqlserver-property-tombstones-on-delete, `+tombstones.on.delete+`>>
|`true`
|Controls whether a _delete_ event is followed by a tombstone event. +
 +
`true` - a delete operation is represented by a _delete_ event and a subsequent tombstone event.  +
 +
`false` - only a _delete_ event is emitted. +
 +
After a source record is deleted, emitting a tombstone event (the default behavior) allows Kafka to completely delete all events that pertain to the key of the deleted row in case {link-kafka-docs}/#compaction[log compaction] is enabled for the topic.

|[[sqlserver-property-column-truncate-to-length-chars]]<<sqlserver-property-column-truncate-to-length-chars, `column.truncate.to._length_.chars`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want to truncate the data in a set of columns when it exceeds the number of characters specified by the _length_ in the property name.
Set `length` to a positive integer value, for example, `column.truncate.to.20.chars`.

The fully-qualified name of a column observes the following format: `_<schemaName>_._<tableName>_._<columnName>_`.
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.

You can specify multiple properties with different lengths in a single configuration.

|[[sqlserver-property-column-mask-with-length-chars]]<<sqlserver-property-column-mask-with-length-chars, `column.mask.with._length_.chars`>>
|_n/a_
Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_.
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want the connector to mask the values for a set of columns, for example, if they contain sensitive data.
Set `_length_` to a positive integer to replace data in the specified columns with the number of asterisk (`*`) characters specified by the _length_ in the property name.
Set _length_ to `0` (zero) to replace data in the specified columns with an empty string.

The fully-qualified name of a column observes the following format: _schemaName_._tableName_._columnName_.
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.

You can specify multiple properties with different lengths in a single configuration.

|[[sqlserver-property-column-propagate-source-type]]<<sqlserver-property-column-propagate-source-type, `+column.propagate.source.type+`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns for which you want the connector to emit extra parameters that represent column metadata.
When this property is set, the connector adds the following fields to the schema of event records:

* `pass:[_]pass:[_]debezium.source.column.type` +
* `pass:[_]pass:[_]debezium.source.column.length` +
* `pass:[_]pass:[_]debezium.source.column.scale` +

These parameters propagate a column's original type name and length (for variable-width types), respectively. +
Enabling the connector to emit this extra data can assist in properly sizing specific numeric or character-based columns in sink databases.

The fully-qualified name of a column observes the following format: _schemaName_._tableName_._columnName_. +
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.

|[[sqlserver-property-datatype-propagate-source-type]]<<sqlserver-property-datatype-propagate-source-type,`+datatype.propagate.source.type+`>>
|_n/a_
|An optional, comma-separated list of regular expressions that specify the fully-qualified names of data types that are defined for columns in a database.
When this property is set, for columns with matching data types, the connector emits event records that include the following extra fields in their schema:

* `pass:[_]pass:[_]debezium.source.column.type` +
* `pass:[_]pass:[_]debezium.source.column.length` +
* `pass:[_]pass:[_]debezium.source.column.scale` +

These parameters propagate a column's original type name and length (for variable-width types), respectively. +
Enabling the connector to emit this extra data can assist in properly sizing specific numeric or character-based columns in sink databases.

The fully-qualified name of a column observes the following format: _schemaName_._tableName_._typeName_. +
To match the name of a data type, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the data type; the expression does not match substrings that might be present in a type name.

For the list of SQL Server-specific data type names, see the xref:sqlserver-data-types[SQL Server data type mappings].

|[[sqlserver-property-message-key-columns]]<<sqlserver-property-message-key-columns, `+message.key.columns+`>>
|_n/a_
|A list of expressions that specify the columns that the connector uses to form custom message keys for change event records that it publishes to the Kafka topics for specified tables.

By default, {prodname} uses the primary key column of a table as the message key for records that it emits.
In place of the default, or to specify a key for tables that lack a primary key, you can configure custom message keys based on one or more columns. +
 +
To establish a custom message key for a table, list the table, followed by the columns to use as the message key.
Each list entry takes the following format: +
 +
`_<fully-qualified_tableName>_:__<keyColumn>__,_<keyColumn>_` +
 +
To base a table key on multiple column names, insert commas between the column names.

Each fully-qualified table name is a regular expression in the following format: +
 +
`_<schemaName>_._<tableName>_` +
 +
The property can include entries for multiple tables.
Use a semicolon to separate table entries in the list. +
 +
The following example sets the message key for the tables `inventory.customers` and `purchase.orders`: +
 +
`inventory.customers:pk1,pk2;(.*).purchaseorders:pk3,pk4` +
 +
For the table `inventory.customer`, the columns `pk1` and `pk2` are specified as the message key.
For the `purchaseorders` tables in any schema, the columns `pk3` and `pk4` server as the message key.

There is no limit to the number of columns that you use to create custom message keys.
However, it's best to use the minimum number that are required to specify a unique key.

|[[sqlserver-property-binary-handling-mode]]<<sqlserver-property-binary-handling-mode, `+binary.handling.mode+`>>
|bytes
|Specifies how binary (`binary`, `varbinary`) columns should be represented in change events, including: `bytes` represents binary data as byte array (default), `base64` represents binary data as base64-encoded String, `base64-url-safe` represents binary data as base64-url-safe-encoded String, `hex` represents binary data as hex-encoded (base16) String

|[[sqlserver-property-schema-name-adjustment-mode]]<<sqlserver-property-schema-name-adjustment-mode,`+schema.name.adjustment.mode+`>>
|none
|Specifies how schema names should be adjusted for compatibility with the message converter used by the connector. Possible settings:  +

* `none` does not apply any adjustment. +
* `avro` replaces the characters that cannot be used in the Avro type name with underscore. +
* `avro_unicode` replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java +

|[[sqlserver-property-field-name-adjustment-mode]]<<sqlserver-property-field-name-adjustment-mode,`+field.name.adjustment.mode+`>>
|none
|Specifies how field names should be adjusted for compatibility with the message converter used by the connector. Possible settings:  +

* `none` does not apply any adjustment. +
* `avro` replaces the characters that cannot be used in the Avro type name with underscore. +
* `avro_unicode` replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java +

For more information, see {link-prefix}:{link-avro-serialization}#avro-naming[Avro naming].

|===

// Title: Advanced {prodname} SQL Server connector configuration properties
[id="sqlserver-advanced-connector-configuration-properties"]
==== Advanced SQL Server connector configuration properties

The following _advanced_ configuration properties have good defaults that will work in most situations and therefore rarely need to be specified in the connector's configuration.

[cols="30%a,25%a,45%a",options="header"]
|===
|Property
|Default
|Description

|[[sqlserver-property-converters]]<<sqlserver-property-converters, `converters`>>
|No default
|Enumerates a comma-separated list of the symbolic names of the {link-prefix}:{link-custom-converters}#custom-converters[custom converter] instances that the connector can use.
For example, +

`isbn`

You must set the `converters` property to enable the connector to use a custom converter.

For each converter that you configure for a connector, you must also add a `.type` property, which specifies the fully-qualified name of the class that implements the converter interface.
The `.type` property uses the following format: +

`_<converterSymbolicName>_.type` +

For example, +

 isbn.type: io.debezium.test.IsbnConverter

If you want to further control the behavior of a configured converter, you can add one or more configuration parameters to pass values to the converter.
To associate any additional configuration parameter with a converter, prefix the parameter names with the symbolic name of the converter.
For example, +

 isbn.schema.name: io.debezium.sqlserver.type.Isbn

|[[sqlserver-property-snapshot-mode]]<<sqlserver-property-snapshot-mode, `+snapshot.mode+`>>
|_initial_
|A mode for taking an initial snapshot of the structure and optionally data of captured tables.
Once the snapshot is complete, the connector will continue reading change events from the database's redo logs.
The following values are supported:

`always`:: Perform snapshot on each connector start.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

`initial`:: The connector performs a database snapshot as described in the xref:sqlserver-default-workflow-for-performing-an-initial-snapshot[default workflow for creating an initial snapshot].
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

`initial_only`:: The connector performs a database snapshot and stops before streaming any change event records, not allowing any subsequent change events to be captured.

`schema_only`:: Deprecated, see `no_data`.

`no_data`:: The connector captures the structure of all relevant tables, performing all the steps described in the xref:sqlserver-default-workflow-for-performing-an-initial-snapshot[default snapshot workflow], except that it does not create `READ` events to represent the data set at the point of the connector's start-up (Step 7.b).

`recovery`:: Set this option to restore a database schema history topic that is lost or corrupted.
After a restart, the connector runs a snapshot that rebuilds the topic from the source tables.
You can also set the property to periodically prune a database schema history topic that experiences unexpected growth. +
+
WARNING: Do not use this mode to perform a snapshot if schema changes were committed to the database after the last connector shutdown.

`when_needed`:: After the connector starts, it performs a snapshot only if it detects one of the following circumstances:

* It cannot detect any topic offsets.
* A previously recorded offset specifies a log position that is not available on the server.

`configuration_based`:: With this option, you control snapshot behavior through a set of connector properties that have the prefix 'snapshot.mode.configuration.based'.

`custom`:: The `custom` snapshot mode lets you inject your own implementation of the `io.debezium.spi.snapshot.Snapshotter` interface.
Set the `snapshot.mode.custom.name` configuration property to the name provided by the `name()` method of your implementation.

For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[sqlserver-property-snapshot-mode-configuration-based-snapshot-data]]<<sqlserver-property-configuration-based-snapshot-data, `+snapshot.mode.configuration.based.snapshot.data+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table data when it performs a snapshot.

|[[sqlserver-property-snapshot-mode-configuration-based-snapshot-schema]]<<sqlserver-property-configuration-based-snapshot-schema, `+snapshot.mode.configuration.based.snapshot.schema+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes the table schema when it performs a snapshot.

|[[sqlserver-property-snapshot-mode-configuration-based-start-stream]]<<sqlserver-property-configuration-based-start-stream, `+snapshot.mode.configuration.based.start.stream+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector begins to stream change events after a snapshot completes.

|[[sqlserver-property-snapshot-mode-configuration-based-snapshot-on-schema-error]]<<sqlserver-property-configuration-based-snapshot-on-schema-error, `+snapshot.mode.configuration.based.snapshot.on.schema.error+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table schema in a snapshot if the schema history topic is not available.

|[[sqlserver-property-snapshot-mode-configuration-based-snapshot-on-data-error]]<<sqlserver-property-configuration-based-snapshot-on-data-error, `+snapshot.mode.configuration.based.snapshot.on.data.error+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, this property specifies whether the connector attempts to snapshot table data if it does not find the last committed offset in the transaction log. +
Set the value to `true` to instruct the connector to perform a new snapshot.

|[[sqlserver-property-snapshot-mode-custom-name]]<<sqlserver-property-snapshot-mode-custom-name, `+snapshot.mode.custom.name+`>>
|No default
|If `snapshot.mode` is set to `custom`, use this setting to specify the name of the custom implementation that is provided in the `name()` method that is defined in the 'io.debezium.spi.snapshot.Snapshotter' interface.
After a connector restart, {prodname} calls the specified custom implementation to determine whether to perform a snapshot.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[sqlserver-property-snapshot-locking-mode]]<<sqlserver-property-snapshot-locking-mode, `+snapshot.locking.mode+`>>
|_exclusive_
a|Controls whether and for how long the connector holds a table lock. Table locks prevent certain types of changes table operations from occurring while the connector performs a snapshot.
You can set the following values:

`exclusive`:: Controls how the connector holds locks on tables while performing the schema snapshot when `snapshot.isolation.mode` is `REPEATABLE_READ` or `EXCLUSIVE`. +
The connector will hold a table lock for exclusive table access for just the initial portion of the snapshot
while the database schemas and other metadata are being read. The remaining work in a snapshot involves selecting all rows from
each table, and this is done using a flashback query that requires no locks. However, in some cases it may be desirable to avoid
locks entirely which can be done by specifying `none`. This mode is only safe to use if no schema changes are happening while the
snapshot is taken.

`none`:: Prevents the connector from acquiring any table locks during the snapshot.
Use this setting only if no schema changes might occur during the creation of the snapshot.

`custom`:: The connector performs a snapshot according to the implementation specified by the xref:sqlserver-property-snapshot-locking-mode-custom-name[`snapshot.locking.mode.custom.name`] property, which is a custom implementation of the `io.debezium.spi.snapshot.SnapshotLock` interface.

|[[sqlserver-property-snapshot-locking-mode-custom-name]]<<sqlserver-property-snapshot-locking-mode-custom-name, `+snapshot.locking.mode.custom.name+`>>
|No default
| When `snapshot.locking.mode` is set as `custom`, use this setting to specify the name of the custom implementation provided in the `name()` method that is defined by the 'io.debezium.spi.snapshot.SnapshotLock' interface.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[sqlserver-property-snapshot-query-mode]]<<sqlserver-property-snapshot-query-mode, `+snapshot.query.mode+`>>
|`select_all`
|Specifies how the connector queries data while performing a snapshot. +
Set one of the following options:

`select_all`:: The connector performs a `select all` query by default, optionally adjusting the columns selected based on the column include and exclude list configurations.

`custom`:: The connector performs a snapshot query according to the implementation specified by the xref:sqlserver-property-snapshot-snapshot-query-mode-custom-name[`snapshot.query.mode.custom.name`] property, which defines a custom implementation of the `io.debezium.spi.snapshot.SnapshotQuery` interface. +

This setting enables you to manage snapshot content in a more flexible manner compared to using the xref:sqlserver-property-snapshot-select-statement-overrides[`snapshot.select.statement.overrides`] property.

|[[sqlserver-property-snapshot-snapshot-query-mode-custom-name]]<<sqlserver-property-snapshot-query-mode-custom-name, `+snapshot.query.mode.custom.name+`>>
|No default
| When xref:sqlserver-property-snapshot-query-mode[`snapshot.query.mode`] is set to `custom`, use this setting to specify the name of the custom implementation provided in the `name()` method that is defined by the 'io.debezium.spi.snapshot.SnapshotQuery' interface.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[sqlserver-property-snapshot-include-collection-list]]<<sqlserver-property-snapshot-include-collection-list, `+snapshot.include.collection.list+`>>
| All tables specified in `table.include.list`
|An optional, comma-separated list of regular expressions that match the fully-qualified names (`_<dbName>_._<schemaName>_._<tableName>_`) of the tables to include in a snapshot.
The specified items must be named in the connector's xref:{context}-property-table-include-list[`table.include.list`] property.
This property takes effect only if the connector's xref:sqlserver-property-snapshot-mode[`snapshot.mode`] property is set to a value other than `never`. +
This property does not affect the behavior of incremental snapshots. +

To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name.

|[[sqlserver-property-snapshot-isolation-mode]]<<sqlserver-property-snapshot-isolation-mode, `+snapshot.isolation.mode+`>>
|_repeatable_read_
|Mode to control which transaction isolation level is used and how long the connector locks tables that are designated for capture.
The following values are supported:

* `read_uncommitted`
* `read_committed`
* `repeatable_read`
* `snapshot`
* `exclusive` (`exclusive` mode uses repeatable read isolation level, however, it takes the exclusive lock on all tables
to be read). +

The `snapshot`, `read_committed` and `read_uncommitted` modes do not prevent other
transactions from updating table rows during initial snapshot.
The `exclusive` and `repeatable_read` modes do prevent concurrent updates. +

Mode choice also affects data consistency. Only `exclusive` and `snapshot` modes guarantee full consistency, that is, initial
snapshot and streaming logs constitute a linear history.
In case of `repeatable_read` and `read_committed` modes, it might happen that, for instance, a record added appears
twice - once in initial snapshot and once in streaming phase. Nonetheless, that consistency level should do for
data mirroring.
For `read_uncommitted` there are no data consistency guarantees at all (some data might be lost or corrupted).

|[[sqlserver-property-event-processing-failure-handling-mode]]<<sqlserver-property-event-processing-failure-handling-mode, `+event.processing.failure.handling.mode+`>>
|`fail`
| Specifies how the connector should react to exceptions during processing of events.
`fail` will propagate the exception (indicating the offset of the problematic event), causing the connector to stop. +
`warn` will cause the problematic event to be skipped and the offset of the problematic event to be logged. +
`skip` will cause the problematic event to be skipped.

|[[sqlserver-property-poll-interval-ms]]<<sqlserver-property-poll-interval-ms, `+poll.interval.ms+`>>
|`500`
|Positive integer value that specifies the number of milliseconds the connector should wait during each iteration for new change events to appear. Defaults to 500 milliseconds, or 0.5 second.

|[[sqlserver-property-max-queue-size]]<<sqlserver-property-max-queue-size, `+max.queue.size+`>>
|`8192`
|Positive integer value that specifies the maximum number of records that the blocking queue can hold.
When {prodname} reads events streamed from the database, it places the events in the blocking queue before it writes them to Kafka.
The blocking queue can provide backpressure for reading change events from the database
in cases where the connector ingests messages faster than it can write them to Kafka, or when Kafka becomes unavailable.
Events that are held in the queue are disregarded when the connector periodically records offsets.
Always set the value of `max.queue.size` to be larger than the value of xref:{context}-property-max-batch-size[`max.batch.size`].

|[[sqlserver-property-max-queue-size-in-bytes]]<<sqlserver-property-max-queue-size-in-bytes, `+max.queue.size.in.bytes+`>>
|`0`
|A long integer value that specifies the maximum volume of the blocking queue in bytes.
By default, volume limits are not specified for the blocking queue.
To specify the number of bytes that the queue can consume, set this property to a positive long value. +
If xref:sqlserver-property-max-queue-size[`max.queue.size`] is also set, writing to the queue is blocked when the size of the queue reaches the limit specified by either property.
For example, if you set `max.queue.size=1000`, and `max.queue.size.in.bytes=5000`, writing to the queue is blocked after the queue contains 1000 records, or after the volume of the records in the queue reaches 5000 bytes.

|[[sqlserver-property-max-batch-size]]<<sqlserver-property-max-batch-size, `+max.batch.size+`>>
|`2048`
|Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector.

|[[sqlserver-property-heartbeat-interval-ms]]<<sqlserver-property-heartbeat-interval-ms, `+heartbeat.interval.ms+`>>
|`0`
|Controls how frequently heartbeat messages are sent. +
This property contains an interval in milliseconds that defines how frequently the connector sends messages to a heartbeat topic.
The property can be used to confirm whether the connector is still receiving change events from the database.
You also should leverage heartbeat messages in cases where only records in non-captured tables are changed for a longer period of time.
In such situation the connector would proceed to read the log from the database but never emit any change messages into Kafka,
which in turn means that no offset updates are committed to Kafka.
This may result in more change events to be re-sent after a connector restart.
Set this parameter to `0` to not send heartbeat messages at all. +
Disabled by default.

|[[sqlserver-property-heartbeat-action-query]]<<sqlserver-property-heartbeat-action-query, `+heartbeat.action.query+`>>
|No default
|Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. +
+
This is useful for keeping offsets from becoming stale when capturing changes from a low-traffic database. Create a heartbeat table in the low-traffic database, and set this property to a statement that inserts records into that table, for example:  +
+
`INSERT INTO test_heartbeat_table (text) VALUES ('test_heartbeat')` +
+
This allows the connector to receive changes from the low-traffic database and acknowledge their LSNs, which prevents offsets from become stale.

|[[sqlserver-property-snapshot-delay-ms]]<<sqlserver-property-snapshot-delay-ms, `+snapshot.delay.ms+`>>
|No default
|An interval in milli-seconds that the connector should wait before taking a snapshot after starting up; +
Can be used to avoid snapshot interruptions when starting multiple connectors in a cluster, which may cause re-balancing of connectors.

|[[sqlserver-property-streaming-delay-ms]]<<sqlserver-property-streaming-delay-ms, `+streaming.delay.ms+`>>
|0
|Specifies the time, in milliseconds, that the connector delays the start of the streaming process after it completes a snapshot.
Setting a delay interval helps to prevent the connector from restarting snapshots in the event that a failure occurs immediately after the snapshot completes, but before the streaming process begins.
Set a delay value that is higher than the value of the {link-kafka-docs}/#connectconfigs_offset.flush.interval.ms[`offset.flush.interval.ms`] property that is set for the Kafka Connect worker.

|[[sqlserver-property-snapshot-fetch-size]]<<sqlserver-property-snapshot-fetch-size, `+snapshot.fetch.size+`>>
|`2000`
|Specifies the maximum number of rows that should be read in one go from each table while taking a snapshot.
The connector will read the table contents in multiple batches of this size. Defaults to 2000.

|[[sqlserver-property-query-fetch-size]]<<sqlserver-property-query-fetch-size, `+query.fetch.size+`>>
|No default
|Specifies the number of rows that will be fetched for each database round-trip of a given query.
Defaults to the JDBC driver's default fetch size.

|[[sqlserver-property-snapshot-lock-timeout-ms]]<<sqlserver-property-snapshot-lock-timeout-ms, `+snapshot.lock.timeout.ms+`>>
|`10000`
|An integer value that specifies the maximum amount of time (in milliseconds) to wait to obtain table locks when performing a snapshot. If table locks cannot be acquired in this time interval, the snapshot will fail (also see xref:sqlserver-snapshots[snapshots]). +
When set to `0` the connector will fail immediately when it cannot obtain the lock. Value `-1` indicates infinite waiting.

|[[sqlserver-property-snapshot-select-statement-overrides]]<<sqlserver-property-snapshot-select-statement-overrides, `+snapshot.select.statement.overrides+`>>
|No default
|Specifies the table rows to include in a snapshot.
Use the property if you want a snapshot to include only a subset of the rows in a table.
This property affects snapshots only.
It does not apply to events that the connector reads from the log.

The property contains a comma-separated list of fully-qualified table names in the form `_<schemaName>.<tableName>_`. For example, +
 +
`+"snapshot.select.statement.overrides": "inventory.products,customers.orders"+` +
 +
For each table in the list, add a further configuration property that specifies the `SELECT` statement for the connector to run on the table when it takes a snapshot.
The specified `SELECT` statement determines the subset of table rows to include in the snapshot.
Use the following format to specify the name of this `SELECT` statement property: +
 +
`snapshot.select.statement.overrides._<schemaName>_._<tableName>_`.
For example,
`snapshot.select.statement.overrides.customers.orders`. +
 +
Example:

From a `customers.orders` table that includes the soft-delete column, `delete_flag`, add the following properties if you want a snapshot to include only those records that are not soft-deleted:

----
"snapshot.select.statement.overrides": "customer.orders",
"snapshot.select.statement.overrides.customer.orders": "SELECT * FROM [customers].[orders] WHERE delete_flag = 0 ORDER BY id DESC"
----

In the resulting snapshot, the connector includes only the records for which `delete_flag = 0`.
|[[sqlserver-property-source-struct-version]]<<sqlserver-property-source-struct-version, `+source.struct.version+`>>
|v2
|Schema version for the `source` block in CDC events; {prodname} 0.10 introduced a few breaking +
changes to the structure of the `source` block in order to unify the exposed structure across
all the connectors. +
By setting this option to `v1` the structure used in earlier versions can be produced.
Note that this setting is not recommended and is planned for removal in a future {prodname} version.

|[[sqlserver-property-provide-transaction-metadata]]<<sqlserver-property-provide-transaction-metadata, `+provide.transaction.metadata+`>>
|`false`
|When set to `true` {prodname} generates events with transaction boundaries and enriches data events envelope with transaction metadata.

|[[sqlserver-property-retriable-restart-connector-wait-ms]]<<sqlserver-property-retriable-restart-connector-wait-ms, `+retriable.restart.connector.wait.ms+`>> +
|10000 (10 seconds)
|The number of milli-seconds to wait before restarting a connector after a retriable error occurs.

|[[sqlserver-property-skipped-operations]]<<sqlserver-property-skipped-operations, `+skipped.operations+`>>
|`t`
|A comma-separated list of operation types that will be skipped during streaming.
The operations include: `c` for inserts/create, `u` for updates, `d` for deletes, `t` for truncates, and `none` to not skip any operations.
By default, truncate operations are skipped (not emitted by this connector).

|[[sqlserver-property-signal-data-collection]]<<sqlserver-property-signal-data-collection,`+signal.data.collection+`>>
|No default value
| Fully-qualified name of the data collection that is used to send {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[signals] to the connector. +
Use the following format to specify the collection name: +
`_<databaseName>_._<schemaName>_._<tableName>_`

|[[sqlserver-property-signal-enabled-channels]]<<sqlserver-property-signal-enabled-channels, `+signal.enabled.channels+`>>
|source
|  List of the signaling channel names that are enabled for the connector.
By default, the following channels are available:

* `source`
* `kafka`
* `file`
* `jmx`
Optionally, you can also implement a {link-prefix}:{link-signalling}#debezium-signaling-enabling-custom-signaling-channel[custom signaling channel].

|[[sqlserver-property-notification-enabled-channels]]<<sqlserver-property-notification-enabled-channels, `+notification.enabled.channels+`>>
|No default
|List of notification channel names that are enabled for the connector.
By default, the following channels are available:

* `sink`
* `log`
* `jmx`
Optionally, you can also implement a {link-prefix}:{link-notification}#debezium-notification-custom-channel[custom notification channel].
|[[sqlserver-property-incremental-snapshot-allow-schema-changes]]<<sqlserver-property-incremental-snapshot-allow-schema-changes, `+incremental.snapshot.allow.schema.changes+`>>
|`false`
| Allow schema changes during an incremental snapshot. When enabled the connector will detect schema change during an incremental snapshot and re-select a current chunk to avoid locking DDLs. +
 +
Note that changes to a primary key are not supported and can cause incorrect results if performed during an incremental snapshot. Another limitation is that if a schema change affects only columns' default values, then the change won't be detected until the DDL is processed from the transaction log stream. This doesn't affect the snapshot events' values, but the schema of snapshot events may have outdated defaults.

|[[sqlserver-property-incremental-snapshot-chunk-size]]<<sqlserver-property-incremental-snapshot-chunk-size, `+incremental.snapshot.chunk.size+`>>
|`1024`
|The maximum number of rows that the connector fetches and reads into memory during an incremental snapshot chunk.
Increasing the chunk size provides greater efficiency, because the snapshot runs fewer snapshot queries of a greater size.
However, larger chunk sizes also require more memory to buffer the snapshot data.
Adjust the chunk size to a value that provides the best performance in your environment.

|[[sqlserver-property-incremental-snapshot-watermarking-strategy]]<<sqlserver-property-incremental-snapshot-watermarking-strategy, `+incremental.snapshot.watermarking.strategy+`>>
|`insert_insert`
|Specifies the watermarking mechanism that the connector uses during an incremental snapshot to deduplicate events that might be captured by an incremental snapshot and then recaptured after streaming resumes. +
You can specify one of the following options:

`insert_insert`:: When you send a signal to initiate an incremental snapshot, for every chunk that {prodname} reads during the snapshot, it writes an entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, {prodname} inserts a second entry that records the signal to close the window.
`insert_delete`:: When you send a signal to initiate an incremental snapshot, for every chunk that {prodname} reads, it writes a single entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, this entry is removed.
No entry is created for the signal to close the snapshot window.
Set this option to prevent rapid growth of the signaling data collection.

|[[sqlserver-property-max-iteration-transactions]]<<sqlserver-property-max-iteration-transactions, `+max.iteration.transactions+`>>
|500
|Specifies the maximum number of transactions per iteration to be used to reduce the memory footprint when streaming changes from multiple tables in a database.
When set to `0`, the connector uses the current maximum LSN as the range to fetch changes from.
When set to a value greater than zero, the connector uses the n-th LSN specified by this setting as the range to fetch changes from. Defaults to 500.

|[[sqlserver-property-incremental-snapshot-option-recompile]]<<sqlserver-property-incremental-snapshot-option-recompile, `+incremental.snapshot.option.recompile+`>>
|`false`
|Uses OPTION(RECOMPILE) query option to all SELECT statements used during an incremental snapshot. This can help to solve parameter sniffing issues that may occur but can cause increased CPU load on the source database, depending on the frequency of query execution.

|[[sqlserver-property-topic-naming-strategy]]<<sqlserver-property-topic-naming-strategy, `topic.naming.strategy`>>
|`io.debezium.schema.SchemaTopicNamingStrategy`
|The name of the TopicNamingStrategy class that should be used to determine the topic name for data change, schema change, transaction, heartbeat event etc., defaults to `SchemaTopicNamingStrategy`.

|[[sqlserver-property-topic-delimiter]]<<sqlserver-property-topic-delimiter, `topic.delimiter`>>
|`.`
|Specify the delimiter for topic name, defaults to `.`.

|[[sqlserver-property-topic-cache-size]]<<sqlserver-property-topic-cache-size, `topic.cache.size`>>
|`10000`
|The size used for holding the topic names in bounded concurrent hash map. This cache will help to determine the topic name corresponding to a given data collection.

|[[sqlserver-property-topic-heartbeat-prefix]]<<sqlserver-property-topic-heartbeat-prefix, `+topic.heartbeat.prefix+`>>
|`__debezium-heartbeat`
|Controls the name of the topic to which the connector sends heartbeat messages. The topic name has this pattern: +
 +
_topic.heartbeat.prefix_._topic.prefix_ +
 +
For example, if the topic prefix is `fulfillment`, the default topic name is `__debezium-heartbeat.fulfillment`.

|[[sqlserver-property-topic-transaction]]<<sqlserver-property-topic-transaction, `topic.transaction`>>
|`transaction`
|Controls the name of the topic to which the connector sends transaction metadata messages. The topic name has this pattern: +
 +
_topic.prefix_._topic.transaction_ +
 +
For example, if the topic prefix is `fulfillment`, the default topic name is `fulfillment.transaction`.

For more information, see xref:sqlserver-transaction-metadata[Transaction Metadata].

|[[sqlserver-property-snapshot-max-threads]]<<sqlserver-property-snapshot-max-threads, `snapshot.max.threads`>>
|`1`
|Specifies the number of threads that the connector uses when performing an initial snapshot.
To enable parallel initial snapshots, set the property to a value greater than 1.
In a parallel initial snapshot, the connector processes multiple tables concurrently.
This feature is incubating.

|[[sqlserver-property-custom-metric-tags]]<<sqlserver-property-custom-metric-tags, `custom.metric.tags`>>
|`No default`
|Defines tags that customize MBean object names by adding metadata that provides contextual information.
Specify a comma-separated list of key-value pairs.
Each key represents a tag for the MBean object name, and the corresponding value represents a value for the key, for example,  +
`k1=v1,k2=v2`

The connector appends the specified tags to the base MBean object name.
Tags can help you to organize and categorize metrics data.
You can define tags to identify particular application instances, environments, regions, versions, and so forth.
For more information, see xref:customized-mbean-names[Customized MBean names].

|[[sqlserver-property-errors-max-retires]]<<sqlserver-property-errors-max-retires, `errors.max.retries`>>
|`-1`
|Specifies how the connector responds after an operation that results in a retriable error, such as a connection error. +
Set one of the following options:

`-1`:: No limit. The connector always restarts automatically, and retries the operation, regardless of the number of previous failures.

`0`:: Disabled. The connector fails immediately, and never retries the operation.
User intervention is required to restart the connector.

`> 0`:: The connector restarts automatically until it reaches the specified maximum number of retries.
After the next failure, the connector stops, and user intervention is required to restart it.

|[[sqlserver-property-data-query-mode]]<<sqlserver-property-data-query-mode, `data.query.mode`>>
|`function`
|Controls how the connector queries CDC data. The following modes are supported:

* `function`: The data is queried by calling `cdc.[fn_cdc_get_all_changes_#]` function. This is the default mode.
* `direct`: Makes the connector to query change tables directly. Switching to `direct` mode and creating an index on `(\\__$start_lsn ASC, __$seqval ASC, __$operation ASC)` columns for each change table significantly speeds up querying CDC data.

|[[sqlserver-property-database-query-timeout-ms]]<<sqlserver-property-database-query-timeout-ms, `database.query.timeout.ms`>>
|`600000` (10 minutes)
|Specifies the time, in milliseconds, that the connector waits for a query to complete.
Set the value to `0` (zero) to remove the timeout limit.
|===

[id="debezium-sqlserver-connector-database-history-configuration-properties"]
==== {prodname} SQL Server connector database schema history configuration properties

:leveloffset: +1

{prodname} provides a set of `schema.history.internal.*` properties that control how the connector interacts with the schema history topic.

The following table describes the `schema.history.internal` properties for configuring the {prodname} connector.

.Connector database schema history configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-database-history-kafka-topic]]<<{context}-property-database-history-kafka-topic, `+schema.history.internal.kafka.topic+`>>
|No default
|The full name of the Kafka topic where the connector stores the database schema history.

|[[{context}-property-database-history-kafka-bootstrap-servers]]<<{context}-property-database-history-kafka-bootstrap-servers, `+schema.history.internal.kafka.bootstrap.servers+`>>
|No default
|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster. This connection is used for retrieving the database schema history previously stored by the connector, and for writing each DDL statement read from the source database. Each pair should point to the same Kafka cluster used by the Kafka Connect process.

|[[{context}-property-database-history-kafka-recovery-poll-interval-ms]]<<{context}-property-database-history-kafka-recovery-poll-interval-ms, `+schema.history.internal.kafka.recovery.poll.interval.ms+`>>
|`100`
|An integer value that specifies the maximum number of milliseconds the connector should wait during startup/recovery while polling for persisted data. The default is 100ms.

|[[{context}-property-database-history-kafka-query-timeout-ms]]<<{context}-property-database-history-kafka-query-timeout-ms, `+schema.history.internal.kafka.query.timeout.ms+`>>
|`3000`
|An integer value that specifies the maximum number of milliseconds the connector should wait while fetching cluster information using Kafka admin client.

|[[{context}-property-database-history-kafka-create-timeout-ms]]<<{context}-property-database-history-kafka-create-timeout-ms, `+schema.history.internal.kafka.create.timeout.ms+`>>
|`30000`
|An integer value that specifies the maximum number of milliseconds the connector should wait while create kafka history topic using Kafka admin client.

|[[{context}-property-database-history-kafka-recovery-attempts]]<<{context}-property-database-history-kafka-recovery-attempts, `+schema.history.internal.kafka.recovery.attempts+`>>
|`100`
|The maximum number of times that the connector should try to read persisted history data before the connector recovery fails with an error. The maximum amount of time to wait after receiving no data is `recovery.attempts` × `recovery.poll.interval.ms`.

|[[{context}-property-database-history-skip-unparseable-ddl]]<<{context}-property-database-history-skip-unparseable-ddl, `+schema.history.internal.skip.unparseable.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector should ignore malformed or unknown database statements or stop processing so a human can fix the issue.
The safe default is `false`.
Skipping should be used only with care as it can lead to data loss or mangling when the binlog is being processed.

|[[{context}-property-database-history-store-only-captured-tables-ddl]]<<{context}-property-database-history-store-only-captured-tables-ddl, `+schema.history.internal.store.only.captured.tables.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector records schema structures from all tables in a schema or database, or only from tables that are designated for capture. +
Specify one of the following values:

`false` (default):: During a database snapshot, the connector records the schema data for all non-system tables in the database, including tables that are not designated for capture.
It's best to retain the default setting.
If you later decide to capture changes from tables that you did not originally designate for capture, the connector can easily begin to capture data from those tables, because their schema structure is already stored in the schema history topic.
{prodname} requires the schema history of a table so that it can identify the structure that was present at the time that a change event occurred.

`true`:: During a database snapshot, the connector records the table schemas only for the tables from which {prodname} captures change events.
If you change the default value, and you later configure the connector to capture data from other tables in the database, the connector lacks the schema information that it requires to capture change events from the tables. +

|[[{context}-property-database-history-store-only-captured-databases-ddl]]<<{context}-property-database-history-store-only-captured-databases-ddl, `+schema.history.internal.store.only.captured.databases.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector records schema structures from all logical databases in the database instance. +
Specify one of the following values:

`true`:: The connector records schema structures only for tables in the logical database and schema from which {prodname} captures change events.
`false`:: The connector records schema structures for all logical databases. +

NOTE: The default value is `true` for MySQL Connector +

|===

[id="{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients"]
.Pass-through database schema history properties for configuring producer and consumer clients
{empty} +
{prodname} relies on a Kafka producer to write schema changes to database schema history topics.
Similarly, it relies on a Kafka consumer to read from database schema history topics when a connector starts.
You define the configuration for the Kafka producer and consumer clients by assigning values to a set of pass-through configuration properties that begin with the `schema.history.internal.producer.\*` and `schema.history.internal.consumer.*` prefixes.
The pass-through producer and consumer database schema history properties control a range of behaviors, such as how these clients secure connections with the Kafka broker, as shown in the following example:

[source,indent=0]
----
schema.history.internal.producer.security.protocol=SSL
schema.history.internal.producer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
schema.history.internal.producer.ssl.keystore.password=test1234
schema.history.internal.producer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
schema.history.internal.producer.ssl.truststore.password=test1234
schema.history.internal.producer.ssl.key.password=test1234

schema.history.internal.consumer.security.protocol=SSL
schema.history.internal.consumer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
schema.history.internal.consumer.ssl.keystore.password=test1234
schema.history.internal.consumer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
schema.history.internal.consumer.ssl.truststore.password=test1234
schema.history.internal.consumer.ssl.key.password=test1234
----

{prodname} strips the prefix from the property name before it passes the property to the Kafka client.

See the Kafka documentation for more details about link:https://kafka.apache.org/documentation.html#producerconfigs[Kafka producer configuration properties] and link:https://kafka.apache.org/documentation.html#consumerconfigs[Kafka consumer configuration properties].

:leveloffset: 1

[id="debezium-{context}-connector-kafka-signals-configuration-properties"]
==== {prodname} connector Kafka signals configuration properties

:leveloffset: +1

{prodname} provides a set of `signal.*` properties that control how the connector interacts with the Kafka signals topic.

The following table describes the Kafka `signal` properties.

.Kafka signals configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-signal-kafka-topic]]<<{context}-property-signal-kafka-topic, `+signal.kafka.topic+`>>
|<topic.prefix>-signal
|The name of the Kafka topic that the connector monitors for ad hoc signals.
[NOTE]
====
If {link-prefix}:{link-topic-auto-creation}#topic-auto-create-config[automatic topic creation] is disabled, you must manually create the required signaling topic.
A signaling topic is required to preserve signal ordering.
The signaling topic must have a single partition.
====

|[[{context}-property-signal-kafka-groupId]]<<{context}-property-signal-kafka-groupId, `+signal.kafka.groupId+`>>
|kafka-signal
|The name of the group ID  that is used by Kafka consumers.

|[[{context}-property-signal-kafka-bootstrap-servers]]<<{context}-property-signal-kafka-bootstrap-servers, `+signal.kafka.bootstrap.servers+`>>
|No default
|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster.
Each pair references the Kafka cluster that is used by the {prodname} Kafka Connect process.

|[[{context}-property-signal-kafka-poll-timeout-ms]]<<{context}-property-signal-kafka-poll-timeout-ms, `+signal.kafka.poll.timeout.ms+`>>
|`100`
|An integer value that specifies the maximum number of milliseconds that the connector waits when polling signals.

|[[{context}-kafka-consumer-offset-commit-enabled]]<<{context}-kafka-consumer-offset-commit-enabled, `+kafka.consumer.offset.commit.enabled+`>>
|`false`
|Enable the offset commit for the signal topic in order to guarantee At-Least-Once delivery. If disabled, only signals received when the consumer is up&running are processed. Any signals received when the consumer is down are lost.

|===

[id="debezium-{context}-connector-pass-through-signals-kafka-consumer-configuration-properties"]
=== {prodname} connector pass-through signals Kafka consumer client configuration properties

The {prodname} connector provides for pass-through configuration of the signals Kafka consumer.
Pass-through signals properties begin with the prefix `signals.consumer.*`.
For example, the connector passes properties such as `signal.consumer.security.protocol=SSL` to the Kafka consumer.

{prodname} strips the prefixes from the properties before it passes the properties to the Kafka signals consumer.

:leveloffset: 1

[id="debezium-{context}-connector-kafka-notifications-configuration-properties"]
==== {prodname} connector sink notifications configuration properties

:leveloffset: +1

The following table describes the `notification` properties.

.Sink notification configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-notification-sink-topic-name]]<<{context}-property-notification-sink-topic-name, `+notification.sink.topic.name+`>>
|No default
|The name of the topic that receives notifications from {prodname}.
This property is required when you configure the xref:{context}-property-notification-enabled-channels[`notification.enabled.channels`] property to include `sink` as one of the enabled notification channels.
|===

:leveloffset: 1

[id="debezium-sqlserver-connector-pass-through-database-driver-configuration-properties"]
==== {prodname} SQL Server connector pass-through database driver configuration properties

:leveloffset: +1

The {prodname} connector provides for pass-through configuration of the database driver.
Pass-through database properties begin with the prefix `driver.*`.
For example, the connector passes properties such as `driver.foobar=false` to the JDBC URL.

As is the case with the xref:{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[pass-through properties for database schema history clients], {prodname} strips the prefixes from the properties before it passes them to the database driver.

:leveloffset: 1


// Type: assembly
// ModuleID: refreshing-capture-tables-after-a-schema-change
// Title: Refreshing capture tables after a schema change
[[sqlserver-schema-evolution]]
== Database schema evolution

When change data capture is enabled for a SQL Server table, as changes occur in the table, event records are persisted to a capture table on the server.
If you introduce a change in the structure of the source table change, for example, by adding a new column, that change is not dynamically reflected in the change table.
For as long as the capture table continues to use the outdated schema, the {prodname} connector is unable to emit data change events for the table correctly.
You must intervene to refresh the capture table to enable the connector to resume processing change events.

Because of the way that CDC is implemented in SQL Server, you cannot use {prodname} to update capture tables.
To refresh capture tables, one must be a SQL Server database operator with elevated privileges.
As a {prodname} user, you must coordinate tasks with the SQL Server database operator to complete the schema refresh and restore streaming to Kafka topics.

You can use one of the following methods to update capture tables after a schema change:

* xref:offline-schema-updates[Offline schema updates] require you to stop the {prodname} connector before you can update capture tables.
* xref:online-schema-updates[Online schema updates] can update capture tables while the {prodname} connector is running.

There are advantages and disadvantages to using each type of procedure.

[WARNING]
====
Whether you use the online or offline update method, you must complete the entire schema update process before you apply subsequent schema updates on the same source table.
The best practice is to execute all DDLs in a single batch so the procedure can be run only once.
====

[NOTE]
====
Some schema changes are not supported on source tables that have CDC enabled.
For example, if CDC is enabled on a table, SQL Server does not allow you to change the schema of the table if you renamed one of its columns or changed the column type.
====

[NOTE]
====
After you change a column in a source table from `NULL` to `NOT NULL` or vice versa, the SQL Server connector cannot correctly capture the changed information until after you create a new capture instance.
If you do not create a new capture table after a change to the column designation, change event records that the connector emits do not correctly indicate whether the column is optional.
That is, columns that were previously defined as optional (or `NULL`) continue to be, despite now being defined as `NOT NULL`.
Similarly, columns that had been defined as required (`NOT NULL`), retain that designation, although they are now defined as `NULL`.
====

[NOTE]
====
After you rename a table using `sp_rename` function, it will continue to emit changes under the old source table name until the connector is restarted.
Upon restart of the connector, it will emit changes under the new source table name.
====

// Type: procedure
// ModuleID: debezium-sql-server-connector-running-an-offline-update-after-a-schema-change
// Title: Running an offline update after a schema change
[id="offline-schema-updates"]
=== Offline schema updates

Offline schema updates provide the safest method for updating capture tables.
However, offline updates might not be feasible for use with applications that require high-availability.

.Prerequisites
* An update was committed to the schema of a SQL Server table that has CDC enabled.
* You are a SQL Server database operator with elevated privileges.

.Procedure

1. Suspend the application that updates the database.
2. Wait for the {prodname} connector to stream all unstreamed change event records.
3. Stop the {prodname} connector.
4. Apply all changes to the source table schema.
5. Create a new capture table for the update source table using `sys.sp_cdc_enable_table` procedure with a unique value for parameter `@capture_instance`.
6. Resume the application that you suspended in Step 1.
7. Start the {prodname} connector.
8. After the {prodname} connector starts streaming from the new capture table, drop the old capture table by running the stored procedure `sys.sp_cdc_disable_table` with the parameter `@capture_instance` set to the old capture instance name.

// Type: procedure
// ModuleID: debezium-sql-server-connector-running-an-online-update-after-a-schema-change
// Title: Running an online update after a schema change
[id="online-schema-updates"]
=== Online schema updates

The procedure for completing an online schema updates is simpler than the procedure for running an offline schema update,
and you can complete it without requiring any downtime in application and data processing.
However, with online schema updates, a potential processing gap can occur after you update the schema in the source database,
but before you create the new capture instance.
During that interval, change events continue to be captured by the old instance of the change table,
and the change data that is saved to the old table retains the structure of the earlier schema.
So, for example, if you added a new column to a source table, change events that are produced before the new capture table is ready, do not contain a field for the new column.
If your application does not tolerate such a transition period, it is best to use the offline schema update procedure.

.Prerequisites
* An update was committed to the schema of a SQL Server table that has CDC enabled.
* You are a SQL Server database operator with elevated privileges.

.Procedure
1. Apply all changes to the source table schema.
2. Create a new capture table for the update source table by running the `sys.sp_cdc_enable_table` stored procedure with a unique value for the parameter `@capture_instance`.
3. When {prodname} starts streaming from the new capture table, you can drop the old capture table by running the `sys.sp_cdc_disable_table` stored procedure with the parameter `@capture_instance` set to the old capture instance name.


.Example: Running an online schema update after a database schema change
Let's deploy the SQL Server based https://github.com/debezium/debezium-examples/tree/main/tutorial#using-sql-server[{prodname} tutorial] to demonstrate the online schema update.

In the following example, a column `phone_number` is added to the `customers` table.

. Type the following command to start the database shell:
[source,shell]
----
docker-compose -f docker-compose-sqlserver.yaml exec sqlserver bash -c '/opt/mssql-tools/bin/sqlcmd -U sa -P $SA_PASSWORD -d testDB'
----


. Modify the schema of the `customers` source table by running the following query to add the `phone_number` field:
+
[source,sql]
----
ALTER TABLE customers ADD phone_number VARCHAR(32);
----

. Create the new capture instance by running the `sys.sp_cdc_enable_table` stored procedure.
+
[source,sql]
----
EXEC sys.sp_cdc_enable_table @source_schema = 'dbo', @source_name = 'customers', @role_name = NULL, @supports_net_changes = 0, @capture_instance = 'dbo_customers_v2';
GO
----

. Insert new data into the `customers` table by running the following query:
[source,sql]
+
----
INSERT INTO customers(first_name,last_name,email,phone_number) VALUES ('John','Doe','john.doe@example.com', '+1-555-123456');
GO
----
+
The Kafka Connect log reports on configuration updates through entries similar to the following message:
+
[source,shell]
----
connect_1    | 2019-01-17 10:11:14,924 INFO   ||  Multiple capture instances present for the same table: Capture instance "dbo_customers" [sourceTableId=testDB.dbo.customers, changeTableId=testDB.cdc.dbo_customers_CT, startLsn=00000024:00000d98:0036, changeTableObjectId=1525580473, stopLsn=00000025:00000ef8:0048] and Capture instance "dbo_customers_v2" [sourceTableId=testDB.dbo.customers, changeTableId=testDB.cdc.dbo_customers_v2_CT, startLsn=00000025:00000ef8:0048, changeTableObjectId=1749581271, stopLsn=NULL]   [io.debezium.connector.sqlserver.SqlServerStreamingChangeEventSource]
connect_1    | 2019-01-17 10:11:14,924 INFO   ||  Schema will be changed for ChangeTable [captureInstance=dbo_customers_v2, sourceTableId=testDB.dbo.customers, changeTableId=testDB.cdc.dbo_customers_v2_CT, startLsn=00000025:00000ef8:0048, changeTableObjectId=1749581271, stopLsn=NULL]   [io.debezium.connector.sqlserver.SqlServerStreamingChangeEventSource]
...
connect_1    | 2019-01-17 10:11:33,719 INFO   ||  Migrating schema to ChangeTable [captureInstance=dbo_customers_v2, sourceTableId=testDB.dbo.customers, changeTableId=testDB.cdc.dbo_customers_v2_CT, startLsn=00000025:00000ef8:0048, changeTableObjectId=1749581271, stopLsn=NULL]   [io.debezium.connector.sqlserver.SqlServerStreamingChangeEventSource]
----
+
Eventually, the `phone_number` field is added to the schema and its value appears in messages written to the Kafka topic.
+
[source,json]
----
...
     {
        "type": "string",
        "optional": true,
        "field": "phone_number"
     }
...
    "after": {
      "id": 1005,
      "first_name": "John",
      "last_name": "Doe",
      "email": "john.doe@example.com",
      "phone_number": "+1-555-123456"
    },
----

. Drop the old capture instance by running the `sys.sp_cdc_disable_table` stored procedure.
+
[source,sql]
----
EXEC sys.sp_cdc_disable_table @source_schema = 'dbo', @source_name = 'dbo_customers', @capture_instance = 'dbo_customers';
GO
----

// Type: assembly
// ModuleID: monitoring-debezium-sql-server-connector-performance
// Title: Monitoring {prodname} SQL Server connector performance
[[sqlserver-monitoring]]
== Monitoring

The {prodname} SQL Server connector provides three types of metrics that are in addition to the built-in support for JMX metrics that Zookeeper, Kafka, and Kafka Connect provide.
The connector provides the following metrics:

* xref:sqlserver-snapshot-metrics[Snapshot metrics] for monitoring the connector when performing snapshots.
* xref:sqlserver-streaming-metrics[Streaming metrics] for monitoring the connector when reading CDC table data.
* xref:sqlserver-schema-history-metrics[Schema history metrics] for monitoring the status of the connector's schema history.

For information about how to expose the preceding metrics through JMX, see the {link-prefix}:{link-debezium-monitoring}#monitoring-debezium[{prodname} monitoring documentation].

// Type: concept
// ModuleID: monitoring-debezium-sqlserver-connectors-customized-mbean-names
// Title: Customized names for SQL Server connector snapshot and streaming MBean objects
[id="customized-mbean-names"]
=== Customized MBean names

:leveloffset: +1

{prodname} connectors expose metrics via the MBean name for the connector.
These metrics, which are specific to each connector instance, provide data about the behavior of the connector's snapshot, streaming, and schema history processes.

By default, when you deploy a correctly configured connector, {prodname} generates a unique MBean name for each of the different connector metrics.
To view the metrics for a connector process, you configure your observability stack to monitor its MBean.
But these default MBean names depend on the connector configuration; configuration changes can result in changes to the MBean names.
A change to the MBean name breaks the linkage between the connector instance and the MBean, disrupting monitoring activity.
In this scenario, you must reconfigure the observability stack to use the new MBean name if you want to resume monitoring.

To prevent monitoring disruptions that result from MBean name changes, you can configure custom metrics tags.
You configure custom metrics by adding the `custom.metric.tags` property to the connector configuration.
The property accepts key-value pairs in which each key represents a tag for the MBean object name, and the corresponding value represents the value of that tag.
For example: `k1=v1,k2=v2`.
{prodname} appends the specified tags to the MBean name of the connector.

After you configure the `custom.metric.tags` property for a connector, you can configure the observability stack to retrieve metrics associated with the specified tags.
The observability stack then uses the specified tags, rather than the mutable MBean names to uniquely identify connectors.
Later, if {prodname} redefines how it constructs MBean names, or if the `topic.prefix` in the connector configuration changes, metrics collection is uninterrupted,
because the metrics scrape task uses the specified tag patterns to identify the connector.

A further benefit of using custom tags, is that you can use tags that reflect the architecture of your data pipeline, so that metrics are organized in a way that suits you operational needs.
For example, you might specify tags with values that declare the type of connector activity, the application context, or the data source, for example, `db1-streaming-for-application-abc`.
If you specify multiple key-value pairs, all of the specified pairs are appended to the connector's MBean name.

The following example illustrates how tags modify the default MBean name.

.How custom tags modify the connector MBean name
=======
By default, the {connector-name} connector uses the following MBean name for streaming metrics:
 +
[source,subs="attributes+,quotes"]
----
debezium.{context}:type=connector-metrics,context=streaming,server=_<topic.prefix>_
----

If you set the value of `custom.metric.tags` to `database=salesdb-streaming,table=inventory`, {prodname} generates the following custom MBean name:

[source,subs="attributes+,quotes"]
----
debezium.{context}:type=connector-metrics,context=streaming,server=_<topic.prefix>_,database=salesdb-streaming,table=inventory
----
=======


:leveloffset: 1

// Type: reference
// ModuleID: debezium-sqlserver-connector-snapshot-metrics
// Title: {prodname} SQL Server connector snapshot metrics
[[sqlserver-snapshot-metrics]]
=== Snapshot metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,server=_<topic.prefix>_,task=_<task.id>_,context=snapshot`.

:leveloffset: 1

:leveloffset: +1

Snapshot metrics are not exposed unless a snapshot operation is active, or if a snapshot has occurred since the last connector start.

The following table lists the snapshot metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-snaps-metric-lastevent_{context}]]<<connectors-snaps-metric-lastevent_{context}, `LastEvent`>>
|`string`
|The last snapshot event that the connector has read.

|[[connectors-snaps-metric-millisecondssincelastevent_{context}]]<<connectors-snaps-metric-millisecondssincelastevent_{context}, `MilliSecondsSinceLastEvent`>>
|`long`
|The number of milliseconds since the connector has read and processed the most recent event.

|[[connectors-snaps-metric-totalnumberofeventsseen_{context}]]<<connectors-snaps-metric-totalnumberofeventsseen_{context}, `TotalNumberOfEventsSeen`>>
|`long`
|The total number of events that this connector has seen since last started or reset.

|[[connectors-snaps-metric-numberofeventsfiltered_{context}]]<<connectors-snaps-metric-numberofeventsfiltered_{context}, `NumberOfEventsFiltered`>>
|`long`
| The number of events that have been filtered by include/exclude list filtering rules configured on the connector.

|[[connectors-snaps-metric-capturedtables_{context}]]<<connectors-snaps-metric-capturedtables_{context}, `CapturedTables`>>
|`string[]`
|The list of tables that are captured by the connector.

|[[connectors-snaps-metric-queuetotalcapacity_{context}]]<<connectors-snaps-metric-queuetotalcapacity_{context}, `QueueTotalCapacity`>>
|`int`
|The length the queue used to pass events between the snapshotter and the main Kafka Connect loop.

|[[connectors-snaps-metric-queueremainingcapacity_{context}]]<<connectors-snaps-metric-queueremainingcapacity_{context}, `QueueRemainingCapacity`>>
|`int`
|The free capacity of the queue used to pass events between the snapshotter and the main Kafka Connect loop.

|[[connectors-snaps-metric-totaltablecount_{context}]]<<connectors-snaps-metric-totaltablecount_{context}, `TotalTableCount`>>
|`int`
|The total number of tables that are being included in the snapshot.

|[[connectors-snaps-metric-remainingtablecount_{context}]]<<connectors-snaps-metric-remainingtablecount_{context}, `RemainingTableCount`>>
|`int`
|The number of tables that the snapshot has yet to copy.

|[[connectors-snaps-metric-snapshotrunning_{context}]]<<connectors-snaps-metric-snapshotrunning_{context}, `SnapshotRunning`>>
|`boolean`
|Whether the snapshot was started.

|[[connectors-snaps-metric-snapshotpaused_{context}]]<<connectors-snaps-metric-snapshotpaused_{context}, `SnapshotPaused`>>
|`boolean`
|Whether the snapshot was paused.

|[[connectors-snaps-metric-snapshotaborted_{context}]]<<connectors-snaps-metric-snapshotaborted_{context}, `SnapshotAborted`>>
|`boolean`
|Whether the snapshot was aborted.

|[[connectors-snaps-metric-snapshotcompleted_{context}]]<<connectors-snaps-metric-snapshotcompleted_{context}, `SnapshotCompleted`>>
|`boolean`
|Whether the snapshot completed.

|[[connectors-snaps-metric-snapshotdurationinseconds_{context}]]<<connectors-snaps-metric-snapshotdurationinseconds_{context}, `SnapshotDurationInSeconds`>>
|`long`
|The total number of seconds that the snapshot has taken so far, even if not complete. Includes also time when snapshot was paused.

|[[connectors-snaps-metric-snapshotpauseddurationinseconds_{context}]]<<connectors-snaps-metric-snapshotpauseddurationinseconds_{context}, `SnapshotPausedDurationInSeconds`>>
|`long`
|The total number of seconds that the snapshot was paused. If the snapshot was paused several times, the paused time adds up.

|[[connectors-snaps-metric-rowsscanned_{context}]]<<connectors-snaps-metric-rowsscanned_{context}, `RowsScanned`>>
|`Map<String, Long>`
|Map containing the number of rows scanned for each table in the snapshot.
Tables are incrementally added to the Map during processing.
Updates every 10,000 rows scanned and upon completing a table.

|[[connectors-snaps-metric-maxqueuesizeinbytes_{context}]]<<connectors-snaps-metric-maxqueuesizeinbytes_{context}, `MaxQueueSizeInBytes`>>
|`long`
|The maximum buffer of the queue in bytes. This metric is available if xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`] is set to a positive long value.

|[[connectors-snaps-metric-currentqueuesizeinbytes_{context}]]<<connectors-snaps-metric-currentqueuesizeinbytes_{context}, `CurrentQueueSizeInBytes`>>
|`long`
|The current volume, in bytes, of records in the queue.

|===

:leveloffset: 1

:leveloffset: +1

The connector also provides the following additional snapshot metrics when an incremental snapshot is executed:

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-insnap-metric-chunkid_{context}]]<<connectors-insnap-metric-chunkid_{context}, `ChunkId`>>
|`string`
|The identifier of the current snapshot chunk.

|[[connectors-insnap-metric-chunkfrom_{context}]]<<connectors-insnap-metric-chunkfrom_{context}, `ChunkFrom`>>
|`string`
|The lower bound of the primary key set defining the current chunk.

|[[connectors-insnap-metric-chunkto_{context}]]<<connectors-insnap-metric-chunkto_{context}, `ChunkTo`>>
|`string`
|The upper bound of the primary key set defining the current chunk.

|[[connectors-insnap-metric-tablefrom_{context}]]<<connectors-insnap-metric-tablefrom_{context}, `TableFrom`>>
|`string`
|The lower bound of the primary key set of the currently snapshotted table.

|[[connectors-insnap-metric-tableto_{context}]]<<connectors-insnap-metric-tableto_{context}, `TableTo`>>
|`string`
|The upper bound of the primary key set of the currently snapshotted table.

|===

The {prodname} {connector-name} connector also provides the `HoldingGlobalLock` custom snapshot metric.
This metric is set to a Boolean value that indicates whether the connector currently holds a global or table write lock.

:leveloffset: 1

// Type: reference
// ModuleID: debezium-sqlserver-connector-streaming-metrics
// Title: {prodname} SQL Server connector streaming metrics
[[sqlserver-streaming-metrics]]
=== Streaming metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,server=_<topic.prefix>_,task=_<task.id>_,context=streaming`.

:leveloffset: 1

:leveloffset: +1

The following table lists the streaming metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-strm-metric-lastevent_{context}]]<<connectors-strm-metric-lastevent_{context}, `LastEvent`>>
|`string`
|The last streaming event that the connector has read.

|[[connectors-strm-metric-millisecondssincelastevent_{context}]]<<connectors-strm-metric-millisecondssincelastevent_{context}, `MilliSecondsSinceLastEvent`>>
|`long`
|The number of milliseconds since the connector has read and processed the most recent event.

|[[connectors-strm-metric-totalnumberofeventsseen_{context}]]<<connectors-strm-metric-totalnumberofeventsseen_{context}, `TotalNumberOfEventsSeen`>>
|`long`
|The total number of data change events reported by the source database since the last connector start, or since a metrics reset.
Represents the data change workload for {prodname} to process.

|[[connectors-strm-metric-totalnumberofcreateeventsseen_{context}]]<<connectors-strm-metric-totalnumberofcreateeventsseen_{context}, `TotalNumberOfCreateEventsSeen`>>
|`long`
|The total number of create events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-totalnumberofupdateeventsseen_{context}]]<<connectors-strm-metric-totalnumberofupdateeventsseen_{context}, `TotalNumberOfUpdateEventsSeen`>>
|`long`
|The total number of update events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-totalnumberofdeleteeventsseen_{context}]]<<connectors-strm-metric-totalnumberofdeleteeventsseen_{context}, `TotalNumberOfDeleteEventsSeen`>>
|`long`
|The total number of delete events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-numberofeventsfiltered_{context}]]<<connectors-strm-metric-numberofeventsfiltered_{context}, `NumberOfEventsFiltered`>>
|`long`
|The number of events that have been filtered by include/exclude list filtering rules configured on the connector.

|[[connectors-strm-metric-capturedtables_{context}]]<<connectors-strm-metric-capturedtables_{context}, `CapturedTables`>>
|`string[]`
|The list of tables that are captured by the connector.

|[[connectors-strm-metric-queuetotalcapacity_{context}]]<<connectors-strm-metric-queuetotalcapacity_{context}, `QueueTotalCapacity`>>
|`int`
|The length the queue used to pass events between the streamer and the main Kafka Connect loop.

|[[connectors-strm-metric-queueremainingcapacity_{context}]]<<connectors-strm-metric-queueremainingcapacity_{context}, `QueueRemainingCapacity`>>
|`int`
|The free capacity of the queue used to pass events between the streamer and the main Kafka Connect loop.

|[[connectors-strm-metric-connected_{context}]]<<connectors-strm-metric-connected_{context}, `Connected`>>
|`boolean`
|Flag that denotes whether the connector is currently connected to the database server.

|[[connectors-strm-metric-millisecondsbehindsource_{context}]]<<connectors-strm-metric-millisecondsbehindsource_{context}, `MilliSecondsBehindSource`>>
|`long`
|The number of milliseconds between the last change event's timestamp and the connector processing it.
The values will incorporate any differences between the clocks on the machines where the database server and the connector are running.

|[[connectors-strm-metric-numberofcommittedtransactions_{context}]]<<connectors-strm-metric-numberofcommittedtransactions_{context}, `NumberOfCommittedTransactions`>>
|`long`
|The number of processed transactions that were committed.

|[[connectors-strm-metric-sourceeventposition_{context}]]<<connectors-strm-metric-sourceeventposition_{context}, `SourceEventPosition`>>
|`Map<String, String>`
|The coordinates of the last received event.

|[[connectors-strm-metric-lasttransactionid_{context}]]<<connectors-strm-metric-lasttransactionid_{context}, `LastTransactionId`>>
|`string`
|Transaction identifier of the last processed transaction.

|[[connectors-strm-metric-maxqueuesizeinbytes_{context}]]<<connectors-strm-metric-maxqueuesizeinbytes_{context}, `MaxQueueSizeInBytes`>>
|`long`
|The maximum buffer of the queue in bytes. This metric is available if xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`] is set to a positive long value.

|[[connectors-strm-metric-currentqueuesizeinbytes_{context}]]<<connectors-strm-metric-currentqueuesizeinbytes_{context}, `CurrentQueueSizeInBytes`>>
|`long`
|The current volume, in bytes, of records in the queue.

|===

The {prodname} {connector-name} connector also provides the following additional streaming metrics:

.Descriptions of additional {connector-name} streaming metrics
[cols="3,2,5",options="header"]
|===
|Attribute |Type |Description

|[[binlog-filename]]<<binlog-filename,`+BinlogFilename+`>>
|`string`
|The name of the binlog file that the connector has most recently read.

|[[binlog-position]]<<binlog-position,`+BinlogPosition+`>>
|`long`
|The most recent position (in bytes) within the binlog that the connector has read.

|[[is-gtid-mode-enabled]]<<is-gtid-mode-enabled,`+IsGtidModeEnabled+`>>
|`boolean`
|Flag that denotes whether the connector is currently tracking GTIDs from {connector-name} server.

|[[gtid-set]]<<gtid-set,`+GtidSet+`>>
|`string`
|The string representation of the most recent GTID set processed by the connector when reading the binlog.

|[[number-of-skipped-events]]<<number-of-skipped-events,`+NumberOfSkippedEvents+`>>
|`long`
|The number of events that have been skipped by the {connector-name} connector. Typically events are skipped due to a malformed or unparseable event from {connector-name}'s binlog.

|[[number-of-disconnects]]<<number-of-disconnects,`+NumberOfDisconnects+`>>
|`long`
|The number of disconnects by the {connector-name} connector.

|[[number-of-rolled-back-transactions]]<<number-of-rolled-back-transactions,`+NumberOfRolledBackTransactions+`>>
|`long`
|The number of processed transactions that were rolled back and not streamed.

|[[number-of-not-well-formed-transactions]]<<number-of-not-well-formed-transactions,`+NumberOfNotWellFormedTransactions+`>>
|`long`
|The number of transactions that have not conformed to the expected protocol of `BEGIN` + `COMMIT`/`ROLLBACK`. This value should be `0` under normal conditions.

|[[number-of-large-transactions]]<<number-of-large-transactions,`+NumberOfLargeTransactions+`>>
|`long`
|The number of transactions that have not fit into the look-ahead buffer. For optimal performance, this value should be significantly smaller than `NumberOfCommittedTransactions` and `NumberOfRolledBackTransactions`.

|===

:leveloffset: 1

// Type: reference
// ModuleID: debezium-sqlserver-connector-schema-history-metrics
// Title: {prodname} SQL Server connector schema history metrics
[[sqlserver-schema-history-metrics]]
=== Schema history metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=schema-history,server=_<topic.prefix>_`.

The following table lists the schema history metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-shist-metric-status_{context}]]<<connectors-shist-metric-status_{context}, `Status`>>
|`string`
|One of `STOPPED`, `RECOVERING` (recovering history from the storage), `RUNNING` describing the state of the database schema history.

|[[connectors-shist-metric-recoverystarttime_{context}]]<<connectors-shist-metric-recoverystarttime_{context}, `RecoveryStartTime`>>
|`long`
|The time in epoch seconds at what recovery has started.

|[[connectors-shist-metric-changesrecovered_{context}]]<<connectors-shist-metric-changesrecovered_{context}, `ChangesRecovered`>>
|`long`
|The number of changes that were read during recovery phase.

|[[connectors-shist-metric-changesapplied_{context}]]<<connectors-shist-metric-changesapplied_{context}, `ChangesApplied`>>
|`long`
|the total number of schema changes applied during recovery and runtime.

|[[connectors-shist-metric-millisecondssincelastrecoveredchange_{context}]]<<connectors-shist-metric-millisecondssincelastrecoveredchange_{context}, `MilliSecondsSinceLast{zwsp}RecoveredChange`>>
|`long`
|The number of milliseconds that elapsed since the last change was recovered from the history store.

|[[connectors-shist-metric-millisecondssincelastappliedchange_{context}]]<<connectors-shist-metric-millisecondssincelastappliedchange_{context}, `MilliSecondsSinceLast{zwsp}AppliedChange`>>
|`long`
|The number of milliseconds that elapsed since the last change was applied.

|[[connectors-shist-metric-lastrecoveredchange_{context}]]<<connectors-shist-metric-lastrecoveredchange_{context}, `LastRecoveredChange`>>
|`string`
|The string representation of the last change recovered from the history store.

|[[connectors-shist-metric-lastappliedchange_{context}]]<<connectors-shist-metric-lastappliedchange_{context}, `LastAppliedChange`>>
|`string`
|The string representation of the last applied change.

|===

:leveloffset: 1

:leveloffset!:
:leveloffset: +1

// Category: debezium-using
// Type: assembly
[id="debezium-connector-for-db2"]
= {prodname} connector for Db2

:context: db2
:data-collection: table
:database-port: 50000
:mbean-name: {context}
:connector-file: {context}
:connector-class: Db2Connector
:connector-name: Db2
:include-list-example: public.inventory

:toc:
:toc-placement: macro
:linkattrs:
:icons: font
:source-highlighter: highlight.js

toc::[]

{prodname}'s Db2 connector can capture row-level changes in the tables of a Db2 database.
For information about the Db2 Database versions that are compatible with this connector, see the link:https://debezium.io/releases/[{prodname} release overview].

This connector is strongly inspired by the {prodname} implementation of SQL Server, which uses a SQL-based polling model that puts tables into "capture mode". When a table is in capture mode, the {prodname} Db2 connector generates and streams a change event for each row-level update to that table.

A table that is in capture mode has an associated change-data table, which Db2 creates. For each change to a table that is in capture mode, Db2 adds data about that change to the table's associated change-data table. A change-data table contains an entry for each state of a row. It also has special entries for deletions. The {prodname} Db2 connector reads change events from change-data tables and emits the events to Kafka topics.

The first time a {prodname} Db2 connector connects to a Db2 database, the connector reads a consistent snapshot of the tables for which the connector is configured to capture changes. By default, this is all non-system tables. There are connector configuration properties that let you specify which tables to put into capture mode, or which tables to exclude from capture mode.

When the snapshot is complete the connector begins emitting change events for committed updates to tables that are in capture mode. By default, change events for a particular table go to a Kafka topic that has the same name as the table. Applications and services consume change events from these topics.

[NOTE]
====
The connector requires the use of the abstract syntax notation (ASN) libraries, which are available as a standard part of Db2 for Linux.
To use the ASN libraries, you must have a license for IBM InfoSphere Data Replication (IIDR).
You do not have to install IIDR to use the ASN libraries.
====

The Db2 connector has been tested with Db2 for Linux.
It is expected that the connector would also work on other platforms such as Windows,
and we'd love to get your feedback if you can confirm this to be the case.

You can also use the Db2 connector with Db2 for z/OS.
This feature is currently  *incubating* and is subject to change in future releases.
For more information, see the xref:db2-property-db2-platform[`db2.platform`] configuration option.

[IMPORTANT]
====
You cannot use {prodname} with Db2 for z/OS versions that use 6-bytes LSNs.
====


// Type: concept
// Title: Overview of {prodname} Db2 connector
// ModuleID: overview-of-debezium-db2-connector
[[db2-overview]]
== Overview

The {prodname} Db2 connector is based on the link:https://www.ibm.com/support/pages/q-replication-and-sql-replication-product-documentation-pdf-format-version-101-linux-unix-and-windows[ASN Capture/Apply agents]
that enable SQL Replication in Db2. A capture agent:

* Generates change-data tables for tables that are in capture mode.
* Monitors tables in capture mode and stores change events for updates to those tables in their corresponding change-data tables.

The {prodname} connector uses a SQL interface to query change-data tables for change events.

The database administrator must put the tables for which you want to capture changes into capture mode.
For convenience and for automating testing, there are xref:db2-management[{prodname} management user-defined functions (UDFs)] in C that you can compile and then use to do the following management tasks:

* Start, stop, and reinitialize the ASN agent
* Put tables into capture mode
* Create the replication (ASN) schemas and change-data tables
* Remove tables from capture mode

Alternatively, you can use Db2 control commands to accomplish these tasks.

After the tables of interest are in capture mode, the connector reads their corresponding change-data tables to obtain change events for table updates.
The connector emits a change event for each row-level insert, update, and delete operation to a Kafka topic that has the same name as the changed table.
This is default behavior that you can modify.
Client applications read the Kafka topics that correspond to the database tables of interest and can react to each row-level change event.

Typically, the database administrator puts a table into capture mode in the middle of the life of a table.
This means that the connector does not have the complete history of all changes that have been made to the table.
Therefore, when the Db2 connector first connects to a particular Db2 database, it starts by performing a _consistent snapshot_ of each table that is in capture mode.
After the connector completes the snapshot, the connector streams change events from the point at which the snapshot was made.
In this way, the connector starts with a consistent view of the tables that are in capture mode, and does not drop any changes that were made while it was performing the snapshot.

{prodname} connectors are tolerant of failures. As the connector reads and produces change events, it records the log sequence number (LSN) of the change-data table entry. The LSN is the position of the change event in the database log. If the connector stops for any reason, including communication failures, network problems, or crashes, upon restarting it continues reading the change-data tables where it left off. This includes snapshots. That is, if the snapshot was not complete when the connector stopped, upon restart the connector begins a new snapshot.

// Type: assembly
// ModuleID: how-debezium-db2-connectors-work
// Title: How {prodname} Db2 connectors work
[[how-the-db2-connector-works]]
== How the connector works

To optimally configure and run a {prodname} Db2 connector, it is helpful to understand how the connector performs snapshots, streams change events, determines Kafka topic names, and handles schema changes.


// Type: concept
// ModuleID: how-debezium-db2-connectors-perform-database-snapshots
// Title: How {prodname} Db2 connectors perform database snapshots
[[db2-snapshots]]
=== Snapshots

Db2`s replication feature is not designed to store the complete history of database changes.
As a result, the {prodname} Db2 connector cannot retrieve the entire history of the database from the logs.
To enable the connector to establish a baseline for the current state of the database, the first time that the connector starts, it performs an initial _consistent snapshot_ of the tables that are in xref:putting-tables-in-capture-mode[capture mode].
For each change that the snapshot captures, the connector emits a `read` event to the Kafka topic for the captured table.


// Type: concept
// ModuleID: default-workflow-that-the-db2-connector-uses-to-perform-an-initial-snapshot
[[db2-default-workflow-for-performing-an-initial-snapshot]]
==== Default workflow that the {prodname} Db2 connector uses to perform an initial snapshot

The following workflow lists the steps that {prodname} takes to create a snapshot.
These steps describe the process for a snapshot when the xref:db2-property-snapshot-mode[`snapshot.mode`] configuration property is set to its default value, which is `initial`.
You can customize the way that the connector creates snapshots by changing the value of the `snapshot.mode` property.
If you configure a different snapshot mode, the connector completes the snapshot by using a modified version of this workflow.

1. Establish a connection to the database.

2. Determine which tables are in capture mode and should be included in the snapshot.
   By default, the connector captures the data for all non-system tables.
   After the snapshot completes, the connector continues to stream data for the specified tables.
   If you want the connector to capture data only from specific tables you can direct the connector to capture the data for only a subset of tables or table elements by setting properties such as xref:{context}-property-table-include-list[`table.include.list`] or xref:{context}-property-table-exclude-list[`table.exclude.list`].

3. Obtain a lock on each of the tables in capture mode.
  This lock ensures that no schema changes can occur in those tables until the snapshot completes.
  The level of the lock is determined by the `snapshot.isolation.mode` connector configuration property.

4. Read the highest (most recent) LSN position in the server's transaction log.

5. Capture the schema of all tables or all tables that are designated for capture.
The connector persists schema information in its internal database schema history topic.
The schema history provides information about the structure that is in effect when a change event occurs. +
+
[NOTE]
====
By default, the connector captures the schema of every table in the database that is in capture mode, including tables that are not configured for capture.
If tables are not configured for capture, the initial snapshot captures only their structure; it does not capture any table data.

For more information about why snapshots persist schema information for tables that you did not include in the initial snapshot, see xref:understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables[Understanding why initial snapshots capture the schema for all tables].
====

6. Release any locks obtained in Step 3.
  Other database clients can now write to any previously locked tables.

7. At the LSN position read in Step 4, the connector scans the tables that are designated for capture.
  During the scan, the connector completes the following tasks:

.. Confirms that the table was created before the snapshot began.
  If the table was created after the snapshot began, the connector skips the table.
  After the snapshot is complete, and the connector transitions to streaming, it emits change events for any tables that were created after the snapshot began.

.. Produces a `read` event for each row that is captured from a table.
  All `read` events contain the same LSN position, which is the LSN position that was obtained in step 4.

.. Emits each `read` event to the Kafka topic for the source table.

.. Releases data table locks, if applicable.

8. Record the successful completion of the snapshot in the connector offsets.

The resulting initial snapshot captures the current state of each row in the captured tables.
From this baseline state, the connector captures subsequent changes as they occur.

After the snapshot process begins, if the process is interrupted due to connector failure, rebalancing, or other reasons, the process restarts after the connector restarts.

After the connector completes the initial snapshot, it continues streaming from the position that it read in Step 4 so that it does not miss any updates.

If the connector stops again for any reason, after it restarts, it resumes streaming changes from where it previously left off.

[id="db2-connector-snapshot-mode-options"]
.Settings for `snapshot.mode` connector configuration property
[cols="30%a,70%a",options="header"]
|===
|Setting |Description

|`always`
|The connector performs a snapshot every time that it starts.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

|`initial`
|The connector performs a database snapshot as described in the xref:db2-default-workflow-for-performing-an-initial-snapshot[default workflow for creating an initial snapshot].
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

|`initial_only`
|The connector performs a database snapshot.
After the snapshot completes, the connector stops, and does not stream event records for subsequent database changes.

|`schema_only`
|Deprecated, see `no_data`.

|`no_data`
|The connector captures the structure of all relevant tables, performing all the steps described in the xref:db2-default-workflow-for-performing-an-initial-snapshot[default snapshot workflow], except that it does not create `READ` events to represent the data set at the point of the connector's start-up (Step 7.b).

|`recovery`
|Set this option to restore a database schema history topic that is lost or corrupted.
After a restart, the connector runs a snapshot that rebuilds the topic from the source tables.
You can also set the property to periodically prune a database schema history topic that experiences unexpected growth. +
+
WARNING: Do not use this mode to perform a snapshot if schema changes were committed to the database after the last connector shutdown.

|`when_needed`
|After the connector starts, it performs a snapshot only if it detects one of the following circumstances:

* It cannot detect any topic offsets.
* A previously recorded offset specifies a log position that is not available on the server.

|`configuration_based`
|Set the snapshot mode to `configuration_based` to control snapshot behavior through the set of connector properties that have the prefix 'snapshot.mode.configuration.based'.

|`custom`
|The `custom` snapshot mode lets you inject your own implementation of the `io.debezium.spi.snapshot.Snapshotter` interface.
Set the `snapshot.mode.custom.name` configuration property to the name provided by the `name()` method of your implementation.
The name is specified on the classpath of your Kafka Connect cluster.
If you use the {prodname} `EmbeddedEngine`, the name is included in the connector JAR file.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|===

For more information, see xref:db2-property-snapshot-mode[`snapshot.mode`] in the table of connector configuration properties.

// ModuleID: db2-description-of-why-initial-snapshots-capture-the-schema-history-for-all-tables
// Title: Description of why initial snapshots capture the schema history for all tables
// Type: concept
[id="understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables"]
==== Understanding why initial snapshots capture the schema history for all tables

The initial snapshot that a connector runs captures two types of information:

Table data::
Information about `INSERT`, `UPDATE`, and `DELETE` operations in tables that are named in the connector's xref:{context}-property-table-include-list[`table.include.list`] property.
Schema data::
DDL statements that describe the structural changes that are applied to tables.
Schema data is persisted to both the internal schema history topic, and to the connector's schema change topic, if one is configured.

After you run an initial snapshot, you might notice that the snapshot captures schema information for tables that are not designated for capture.
By default, initial snapshots are designed to capture schema information for every table that is present in the database, not only from tables that are designated for capture.
Connectors require that the table's schema is present in the schema history topic before they can capture a table.
By enabling the initial snapshot to capture schema data for tables that are not part of the original capture set, {prodname} prepares the connector to readily capture event data from these tables should that later become necessary.
If the initial snapshot does not capture a table's schema, you must add the schema to the history topic before the connector can capture data from the table.

In some cases, you might want to limit schema capture in the initial snapshot.
This can be useful when you want to reduce the time required to complete a snapshot.
Or when {prodname} connects to the database instance through a user account that has access to multiple logical databases, but you want the connector to capture changes only from tables in a specific logic database.

.Additional information
* xref:{context}-capturing-data-from-tables-not-captured-by-the-initial-snapshot[Capturing data from tables not captured by the initial snapshot (no schema change)]
* xref:{context}-capturing-data-from-new-tables-with-schema-changes[Capturing data from tables not captured by the initial snapshot (schema change)]
* Setting the xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.store.only.captured.tables.ddl`] property to specify the tables from which to capture schema information.
* Setting the xref:{context}-property-database-history-store-only-captured-databases-ddl[`schema.history.internal.store.only.captured.databases.ddl`] property to specify the logical databases from which to capture schema changes.

// Type: procedure
[id="db2-capturing-data-from-tables-not-captured-by-the-initial-snapshot"]
==== Capturing data from tables not captured by the initial snapshot (no schema change)

In some cases, you might want the connector to capture data from a table whose schema was not captured by the initial snapshot.
Depending on the connector configuration, the initial snapshot might capture the table schema only for specific tables in the database.
If the table schema is not present in the history topic, the connector fails to capture the table, and reports a missing schema error.

You might still be able to capture data from the table, but you must perform additional steps to add the table schema.

.Prerequisites

* You want to capture data from a table with a schema that the connector did not capture during the initial snapshot.
* No schema changes were applied to the table between the LSNs of the earliest and latest change table entry that the connector reads.
For information about capturing data from a new table that has undergone structural changes, see xref:db2-capturing-data-from-new-tables-with-schema-changes[].

.Procedure

1. Stop the connector.
2. Remove the internal database schema history topic that is specified by the xref:{context}-property-database-history-kafka-topic[`schema.history.internal.kafka.topic property`].
3. Clear the offsets in the configured Kafka Connect link:{link-kafka-docs}/#connectconfigs_offset.storage.topic[`offset.storage.topic`].
For more information about how to remove offsets, see the link:https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector[{prodname} community FAQ].
+
[WARNING]
====
Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.
====
4. Apply the following changes to the connector configuration:
.. (Optional) Set the value of xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.captured.tables.ddl`] to `false`.
This setting causes the snapshot to capture the schema for all tables, and guarantees that, in the future, the connector can reconstruct the schema history for all tables. +
+
[NOTE]
====
Snapshots that capture the schema for all tables require more time to complete.
====
.. Add the tables that you want the connector to capture to xref:{context}-property-table-include-list[`table.include.list`].
.. Set the xref:{context}-property-snapshot-mode[`snapshot.mode`] to one of the following values:
`initial`:: When you restart the connector, it takes a full snapshot of the database that captures the table data and table structures. +
If you select this option, consider setting the value of the xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.captured.tables.ddl`] property to `false` to enable the connector to capture the schema of all tables.
`schema_only`:: When you restart the connector, it takes a snapshot that captures only the table schema.
Unlike a full data snapshot, this option does not capture any table data.
Use this option if you want to restart the connector more quickly than with a full snapshot.

5. Restart the connector.
The connector completes the type of snapshot specified by the `snapshot.mode`.
6. (Optional) If the connector performed a `schema_only` snapshot, after the snapshot completes, initiate an xref:debezium-db2-incremental-snapshots[incremental snapshot] to capture data from the tables that you added.
The connector runs the snapshot while it continues to stream real-time changes from the tables.
Running an incremental snapshot captures the following data changes:
+
* For tables that the connector previously captured, the incremental snapsot captures changes that occur while the connector was down, that is, in the interval between the time that the connector was stopped, and the current restart.
* For newly added tables, the incremental snapshot captures all existing table rows.

// Type: procedure
[id="db2-capturing-data-from-new-tables-with-schema-changes"]
==== Capturing data from tables not captured by the initial snapshot (schema change)

If a schema change is applied to a table, records that are committed before the schema change have different structures than those that were committed after the change.
When {prodname} captures data from a table, it reads the schema history to ensure that it applies the correct schema to each event.
If the schema is not present in the schema history topic, the connector is unable to capture the table, and an error results.

If you want to capture data from a table that was not captured by the initial snapshot, and the schema of the table was modified, you must add the schema to the history topic, if it is not already available.
You can add the schema by running a new schema snapshot, or by running an initial snapshot for the table.

.Prerequisites
* You want to capture data from a table with a schema that the connector did not capture during the initial snapshot.
* A schema change was applied to the table so that the records to be captured do not have a uniform structure.

.Procedure

Initial snapshot captured the schema for all tables (`store.only.captured.tables.ddl` was set to `false`)::
1. Edit the xref:{context}-property-table-include-list[`table.include.list`] property to specify the tables that you want to capture.
2. Restart the connector.
3. Initiate an xref:debezium-db2-incremental-snapshots[incremental snapshot] if you want to capture existing data from the newly added tables.

Initial snapshot did not capture the schema for all tables (`store.only.captured.tables.ddl` was set to `true`)::
If the initial snapshot did not save the schema of the table that you want to capture, complete one of the following procedures:

Procedure 1: Schema snapshot, followed by incremental snapshot:::
In this procedure, the connector first performs a schema snapshot.
You can then initiate an incremental snapshot to enable the connector to synchronize data.
1. Stop the connector.
2. Remove the internal database schema history topic that is specified by the xref:{context}-property-database-history-kafka-topic[`schema.history.internal.kafka.topic property`].
3. Clear the offsets in the configured Kafka Connect link:{link-kafka-docs}/#connectconfigs_offset.storage.topic[`offset.storage.topic`].
For more information about how to remove offsets, see the link:https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector[{prodname} community FAQ].
+
[WARNING]
====
Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.
====
4. Set values for properties in the connector configuration as described in the following steps:
.. Set the value of the xref:{context}-property-snapshot-mode[`snapshot.mode`] property to `schema_only`.
.. Edit the xref:{context}-property-table-include-list[`table.include.list`] to add the tables that you want to capture.
5. Restart the connector.
6. Wait for {prodname} to capture the schema of the new and existing tables.
Data changes that occurred any tables after the connector stopped are not captured.
7. To ensure that no data is lost, initiate an xref:debezium-db2-incremental-snapshots[incremental snapshot].

Procedure 2: Initial snapshot, followed by optional incremental snapshot:::
In this procedure the connector performs a full initial snapshot of the database.
As with any initial snapshot, in a database with many large tables, running an initial snapshot can be a time-consuming operation.
After the snapshot completes, you can optionally trigger an incremental snapshot to capture any changes that occur while the connector is off-line.

1. Stop the connector.
2. Remove the internal database schema history topic that is specified by the xref:{context}-property-database-history-kafka-topic[`schema.history.internal.kafka.topic property`].
3. Clear the offsets in the configured Kafka Connect link:{link-kafka-docs}/#connectconfigs_offset.storage.topic[`offset.storage.topic`].
For more information about how to remove offsets, see the link:https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector[{prodname} community FAQ].
+
[WARNING]
====
Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.
====
4. Edit the xref:{context}-property-table-include-list[`table.include.list`] to add the tables that you want to capture.
5. Set values for properties in the connector configuration as described in the following steps:
.. Set the value of the xref:{context}-property-snapshot-mode[`snapshot.mode`] property to `initial`.
.. (Optional) Set xref:{context}-property-database-history-store-only-captured-tables-ddl[`schema.history.internal.store.only.captured.tables.ddl`] to `false`.
6. Restart the connector.
The connector takes a full database snapshot.
After the snapshot completes, the connector transitions to streaming.
7. (Optional) To capture any data that changed while the connector was off-line, initiate an xref:debezium-db2-incremental-snapshots[incremental snapshot].

// Type: concept
// ModuleID: debezium-db2-ad-hoc-snapshots
[id="db2-ad-hoc-snapshots"]
=== Ad hoc snapshots

:leveloffset: +1

By default, a connector runs an initial snapshot operation only after it starts for the first time.
Following this initial snapshot, under normal circumstances, the connector does not repeat the snapshot process.
Any future change event data that the connector captures comes in through the streaming process only.

However, in some situations the data that the connector obtained during the initial snapshot might become stale, lost, or incomplete.
To provide a mechanism for recapturing {data-collection} data, {prodname} includes an option to perform ad hoc snapshots.
You might want to perform an ad hoc snapshot after any of the following changes occur in your {prodname} environment:

* The connector configuration is modified to capture a different set of {data-collection}s.
* Kafka topics are deleted and must be rebuilt.
* Data corruption occurs due to a configuration error or some other problem.

You can re-run a snapshot for a {data-collection} for which you previously captured a snapshot by initiating a so-called _ad-hoc snapshot_.
Ad hoc snapshots require the use of {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[signaling {data-collection}s].
You initiate an ad hoc snapshot by sending a signal request to the {prodname} signaling {data-collection}.

When you initiate an ad hoc snapshot of an existing {data-collection}, the connector appends content to the topic that already exists for the {data-collection}.
If a previously existing topic was removed, {prodname} can create a topic automatically if {link-prefix}:{link-topic-auto-creation}#customizing-debezium-automatically-created-topics[automatic topic creation] is enabled.

Ad hoc snapshot signals specify the {data-collection}s to include in the snapshot.
The snapshot can capture the entire contents of the database, or capture only a subset of the {data-collection}s in the database.
Also, the snapshot can capture a subset of the contents of the {data-collection}(s) in the database.

You specify the {data-collection}s to capture by sending an `execute-snapshot` message to the signaling {data-collection}.
Set the type of the `execute-snapshot` signal to `incremental` or `blocking`, and provide the names of the {data-collection}s to include in the snapshot, as described in the following table:


.Example of an ad hoc `execute-snapshot` signal record
[cols="2,2,6a",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| Specifies the type of snapshot that you want to run. +
Currently, you can request `incremental` or `blocking` snapshots.


|`data-collections`
|_N/A_
| An array that contains regular expressions matching the fully-qualified names of the {data-collection} to be snapshotted. +
The format of the names is the same as for the `signal.data.collection` configuration option.

|`[.line-through]#additional-condition#`
|_N/A_
| An optional string, which specifies a condition based on the column(s) of the {data-collection}(s), to capture a
subset of the contents of the {data-collection}(s). +

[NOTE]
====
This property is deprecated.
To specify criteria for defining the subset of data that you want the snapshot to capture, use the `additional-conditions` parameter.
====

|`additional-conditions`
|_N/A_
|An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot. +
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:

`data-collection`:: The fully-qualified name of the {data-collection} that the filter applies to.
You can apply different filters to each {data-collection}.
`filter`:: Specifies column values that must be present in a database record for the snapshot to include it, for example,  `"color='blue'"`. +
 +
The values that you assign to the `filter` parameter are the same types of values that you might specify in the `WHERE` clause of `SELECT` statements when you set the `snapshot.select.statement.overrides` property for a blocking snapshot.
In earlier {prodname} releases, an explicit `filter` parameter was not defined for snapshot signals; instead, filter criteria were implied by the values that were specified for the now deprecated  `additional-condition` parameter.

|`surrogate-key`
|_N/A_
| An optional string that specifies the column name that the connector uses as the primary key of a {data-collection} during the snapshot process.

|===

.Triggering an ad hoc incremental snapshot

You initiate an ad hoc incremental snapshot by adding an entry with the `execute-snapshot` signal type to the signaling {data-collection}.
After the connector processes the message, it begins the snapshot operation.
The snapshot process reads the first and last primary key values and uses those values as the start and end point for each {data-collection}.
Based on the number of entries in the {data-collection}, and the configured chunk size, {prodname} divides the {data-collection} into chunks, and proceeds to snapshot each chunk, in succession, one at a time.

For more information, see xref:debezium-{context}-incremental-snapshots[Incremental snapshots].

.Triggering an ad hoc blocking snapshot

You initiate an ad hoc blocking snapshot by adding an entry with the `execute-snapshot` signal type to the signaling {data-collection}.
After the connector processes the message, it begins the snapshot operation.
The connector temporarily stops streaming, and then initiates a snapshot of the specified {data-collection}, following the same process that it uses during an initial snapshot.
After the snapshot completes, the connector resumes streaming.

For more information, see xref:{context}-blocking-snapshots[Blocking snapshots].

:leveloffset: 1

// Type: assembly
// ModuleID: debezium-db2-incremental-snapshots
[id="debezium-db2-incremental-snapshots"]
=== Incremental snapshots

:leveloffset: +1

To provide flexibility in managing snapshots, {prodname} includes a supplementary snapshot mechanism, known as _incremental snapshotting_.
Incremental snapshots rely on the {prodname} mechanism for {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[sending signals to a {prodname} connector].
Incremental snapshots are based on the link:https://github.com/debezium/debezium-design-documents/blob/main/DDD-3.md[DDD-3] design document.

In an incremental snapshot, instead of capturing the full state of a database all at once, as in an initial snapshot, {prodname} captures each {data-collection} in phases, in a series of configurable chunks.
You can specify the {data-collection}s that you want the snapshot to capture and the xref:{context}-property-incremental-snapshot-chunk-size[size of each chunk].
The chunk size determines the number of rows that the snapshot collects during each fetch operation on the database.
The default chunk size for incremental snapshots is 1024 rows.

As an incremental snapshot proceeds, {prodname} uses watermarks to track its progress, maintaining a record of each {data-collection} row that it captures.
This phased approach to capturing data provides the following advantages over the standard initial snapshot process:

* You can run incremental snapshots in parallel with streamed data capture, instead of postponing streaming until the snapshot completes.
  The connector continues to capture near real-time events from the change log throughout the snapshot process, and neither operation blocks the other.
* If the progress of an incremental snapshot is interrupted, you can resume it without losing any data.
  After the process resumes, the snapshot begins at the point where it stopped, rather than recapturing the {data-collection} from the beginning.
* You can run an incremental snapshot on demand at any time, and repeat the process as needed to adapt to database updates.
  For example, you might re-run a snapshot after you modify the connector configuration to add a {data-collection} to its xref:{context}-property-{data-collection}-include-list[`{data-collection}.include.list`] property.

.Incremental snapshot process
When you run an incremental snapshot, {prodname} sorts each {data-collection} by primary key and then splits the {data-collection} into chunks based on the xref:{context}-property-incremental-snapshot-chunk-size[configured chunk size].
Working chunk by chunk, it then captures each {data-collection} row in a chunk.
For each row that it captures, the snapshot emits a `READ` event.
That event represents the value of the row when the snapshot for the chunk began.

As a snapshot proceeds, it’s likely that other processes continue to access the database, potentially modifying {data-collection} records.
To reflect such changes, `INSERT`, `UPDATE`, or `DELETE` operations are committed to the transaction log as per usual.
Similarly, the ongoing {prodname} streaming process continues to detect these change events and emits corresponding change event records to Kafka.

.How {prodname} resolves collisions among records with the same primary key
In some cases, the `UPDATE` or `DELETE` events that the streaming process emits are received out of sequence.
That is, the streaming process might emit an event that modifies a {data-collection} row before the snapshot captures the chunk that contains the `READ` event for that row.
When the snapshot eventually emits the corresponding `READ` event for the row, its value is already superseded.
To ensure that incremental snapshot events that arrive out of sequence are processed in the correct logical order, {prodname} employs a buffering scheme for resolving collisions.
Only after collisions between the snapshot events and the streamed events are resolved does {prodname} emit an event record to Kafka.

.Snapshot window
To assist in resolving collisions between late-arriving `READ` events and streamed events that modify the same {data-collection} row, {prodname} employs a so-called _snapshot window_.
The snapshot windows demarcates the interval during which an incremental snapshot captures data for a specified {data-collection} chunk.
Before the snapshot window for a chunk opens, {prodname} follows its usual behavior and emits events from the transaction log directly downstream to the target Kafka topic.
But from the moment that the snapshot for a particular chunk opens, until it closes, {prodname} performs a de-duplication step to resolve collisions between events that have the same primary key..

For each data collection, the {prodname} emits two types of events, and stores the records for them both in a single destination Kafka topic.
The snapshot records that it  captures directly from a table are emitted as `READ` operations.
Meanwhile, as users continue to update records in the data collection, and the transaction log is updated to reflect each commit, {prodname} emits `UPDATE` or `DELETE` operations for each change.

As the snapshot window opens, and {prodname} begins processing a snapshot chunk, it delivers snapshot records to a memory buffer.
During the snapshot windows, the primary keys of the `READ` events in the buffer are compared to the primary keys of the incoming streamed events.
If no match is found, the streamed event record is sent directly to Kafka.
If {prodname} detects a match, it discards the buffered `READ` event, and writes the streamed record to the destination topic, because the streamed event logically supersede the static snapshot event.
After the snapshot window for the chunk closes, the buffer contains only `READ` events for which no related transaction log events exist.
{prodname} emits these remaining `READ` events to the {data-collection}'s Kafka topic.

The connector repeats the process for each snapshot chunk.

:leveloffset: 1

[WARNING]
====
The {prodname} connector for Db2 does not support schema changes while an incremental snapshot is running.
====

// Type: procedure
// ModuleID: debezium-db2-triggering-an-incremental-snapshot
[id="db2-triggering-an-incremental-snapshot"]
==== Triggering an incremental snapshot

:leveloffset: +1

Currently, the only way to initiate an incremental snapshot is to send an {link-prefix}:{link-signalling}#debezium-signaling-ad-hoc-snapshots[ad hoc snapshot signal] to the signaling {data-collection} on the source database.

You submit a signal to the signaling {data-collection} as SQL `INSERT` queries.

After {prodname} detects the change in the signaling {data-collection}, it reads the signal, and runs the requested snapshot operation.

The query that you submit specifies the {data-collection}s to include in the snapshot, and, optionally, specifies the type of snapshot operation.
Currently supports the `incremental` and `blocking` types.

To specify the {data-collection}s to include in the snapshot, provide a `data-collections` array that lists the {data-collection}s or an array of regular expressions used to match {data-collection}s, for example, +

`{"data-collections": ["public.MyFirstTable", "public.MySecondTable"]}` +

The `data-collections` array for an incremental snapshot signal has no default value.
If the `data-collections` array is empty, {prodname} detects that no action is required and does not perform a snapshot.

[NOTE]
====
If the name of a {data-collection} that you want to include in a snapshot contains a dot (`.`) in the name of the database, schema, or table, to add the {data-collection} to the `data-collections` array, you must escape each part of the name in double quotes. +
 +
For example, to include a table that exists in the `*public*` schema and that has the name `*My.Table*`, use the following format: `*"public"."My.Table"*`.
====

.Prerequisites

* {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[Signaling is enabled]. +
** A signaling data collection exists on the source database.
** The signaling data collection is specified in the xref:{context}-property-signal-data-collection[`signal.data.collection`] property.

.Using a source signaling channel to trigger an incremental snapshot

. Send a SQL query to add the ad hoc incremental snapshot request to the signaling {data-collection}:
+
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) VALUES (_'<id>'_, _'<snapshotType>'_, '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"_<snapshotType>_","additional-conditions":[{"data-collection": "_<tableName>_", "filter": "_<additional-condition>_"}]}');
----
+
For example,
+
[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) // <1>
values ('ad-hoc-1',   // <2>
    'execute-snapshot',  // <3>
    '{"data-collections": ["schema1.table1", "schema2.table2"], // <4>
    "type":"incremental", // <5>
    "additional-conditions":[{"data-collection": "schema1.table1" ,"filter":"color=\'blue\'"}]}'); // <6>
----
+
The values of the `id`,`type`, and `data` parameters in the command correspond to the {link-prefix}:{link-signalling}#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection[fields of the signaling {data-collection}].
+
The following table describes the parameters in the example:
+
.Descriptions of fields in a SQL command for sending an incremental snapshot signal to the signaling {data-collection}
[cols="1,2,6",options="header"]
|===
|Item |Value |Description

|1
|`myschema.debezium_signal`
|Specifies the fully-qualified name of the signaling {data-collection} on the source database.

|2
|`ad-hoc-1`
|The `id` parameter specifies an arbitrary string that is assigned as the `id` identifier for the signal request. +
Use this string to identify logging messages to entries in the signaling {data-collection}.
{prodname} does not use this string.
Rather, during the snapshot, {prodname} generates its own `id` string as a watermarking signal.

|3
|`execute-snapshot`
|The `type` parameter specifies the operation that the signal is intended to trigger. +

|4
|`data-collections`
|A required component of the `data` field of a signal that specifies an array of {data-collection} names or regular expressions to match {data-collection} names to include in the snapshot. +
The array lists regular expressions which match {data-collection}s by their fully-qualified names, using the same format as you use to specify the name of the connector's signaling {data-collection} in the xref:{context}-property-signal-data-collection[`signal.data.collection`] configuration property.

|5
|`incremental`
|An optional `type` component of the `data` field of a signal that specifies the type of snapshot operation to run. +
Currently supports the `incremental` and `blocking` types. +
If you do not specify a value, the connector runs an incremental snapshot.

|6
|`additional-conditions`
| An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot. +
Each additional condition is an object with `data-collection` and `filter` properties.
You can specify different filters for each data collection. +
* The `data-collection` property is the fully-qualified name of the data collection for which the filter will be applied.
For more information about the `additional-conditions` parameter, see xref:{context}-incremental-snapshots-additional-conditions[].
|===

[id="{context}-incremental-snapshots-additional-conditions"]
.Ad hoc incremental snapshots with `additional-conditions`

If you want a snapshot to include only a subset of the content in a {data-collection}, you can modify the signal request by appending an `additional-conditions` parameter to the snapshot signal.

The SQL query for a typical snapshot takes the following form:

[source,sql,subs="+attributes,+quotes"]
----
SELECT * FROM _<tableName>_ ....
----

By adding an `additional-conditions` parameter, you append a `WHERE` condition to the SQL query, as in the following example:

[source,sql,subs="+attributes,+quotes"]
----
SELECT * FROM _<data-collection>_ WHERE _<filter>_ ....
----

The following example shows a SQL query to send an ad hoc incremental snapshot request with an additional condition to the signaling {data-collection}:
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) VALUES (_'<id>'_, _'<snapshotType>'_, '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"_<snapshotType>_","additional-conditions":[{"data-collection": "_<tableName>_", "filter": "_<additional-condition>_"}]}');
----

For example, suppose you have a `products` {data-collection} that contains the following columns:

* `id` (primary key)
* `color`
* `quantity`

If you want an incremental snapshot of the `products` {data-collection} to include only the data items where `color=blue`, you can use the following SQL statement to trigger the snapshot:

[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) VALUES('ad-hoc-1', 'execute-snapshot', '{"data-collections": ["schema1.products"],"type":"incremental", "additional-conditions":[{"data-collection": "schema1.products", "filter": "color=blue"}]}');
----

The `additional-conditions` parameter also enables you to pass conditions that are based on more than one column.
For example, using the `products` {data-collection} from the previous example, you can submit a query that triggers an incremental snapshot that includes the data of only those items for which `color=blue` and `quantity>10`:

[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) VALUES('ad-hoc-1', 'execute-snapshot', '{"data-collections": ["schema1.products"],"type":"incremental", "additional-conditions":[{"data-collection": "schema1.products", "filter": "color=blue AND quantity>10"}]}');
----

The following example, shows the JSON for an incremental snapshot event that is captured by a connector.

.Example: Incremental snapshot event message
[source,json,index=0]
----
{
    "before":null,
    "after": {
        "pk":"1",
        "value":"New data"
    },
    "source": {
        ...
        "snapshot":"incremental" <1>
    },
    "op":"r", <2>
    "ts_ms":"1620393591654",
    "ts_us":"1620393591654547",
    "ts_ns":"1620393591654547920",
    "transaction":null
}
----
[cols="1,1,4",options="header"]
|===
|Item |Field name |Description
|1
|`snapshot`
|Specifies the type of snapshot operation to run. +
Currently, the only valid options are `blocking` and `incremental`. +
Specifying a `type` value in the SQL query that you submit to the signaling {data-collection} is optional. +
If you do not specify a value, the connector runs an incremental snapshot.

|2
|`op`
|Specifies the event type. +
The value for snapshot events is `r`, signifying a `READ` operation.

|===

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-db2-using-the-kafka-signaling-channel-to-trigger-an-incremental-snapshot
[id="db2-triggering-an-incremental-snapshot-kafka"]
==== Using the Kafka signaling channel to trigger an incremental snapshot

:leveloffset: +1

You can send a message to the {link-prefix}:{link-signalling}#debezium-signaling-enabling-kafka-signaling-channel[configured Kafka topic] to request the connector to run an ad hoc incremental snapshot.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value of the message is a JSON object with `type` and `data` fields.

The signal type is `execute-snapshot`, and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6a",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed.
Currently {prodname} supports the `incremental` and `blocking` types. +
See the next section for more details.

|`data-collections`
|_N/A_
| An array of comma-separated regular expressions that match the fully-qualified names of tables to include in the snapshot. +
Specify the names by using the same format as is required for the xref:{context}-property-signal-data-collection[signal.data.collection] configuration option.

|`[.line-through]#additional-condition#`
|_N/A_
| An optional string that specifies a condition that the connector evaluates to designate a subset of records to include in a snapshot. +

[NOTE]
====
This property is deprecated and should be replaced by the `additional-conditions` property.
====

|`additional-conditions`
|_N/A_
| An optional array of additional conditions that specifies criteria that the connector evaluates to designate a subset of records to include in a snapshot. +
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:
`data-collection`:: The fully-qualified name of the {data-collection} that the filter applies to.
You can apply different filters to each {data-collection}.
`filter`:: Specifies column values that must be present in a database record for the snapshot to include it, for example,  `"color='blue'"`. +
 +
The values that you assign to the `filter` parameter are the same types of values that you might specify in the `WHERE` clause of `SELECT` statements when you set the `snapshot.select.statement.overrides` property for a blocking snapshot.
In earlier {prodname} releases, an explicit `filter` parameter was not defined for snapshot signals; instead, filter criteria were implied by the values that were specified for the now deprecated `additional-condition` parameter.
|===

An example of the execute-snapshot Kafka message:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

.Ad hoc incremental snapshots with additional-conditions

{prodname} uses the `additional-conditions` field to select a subset of a {data-collection}'s content.

Typically, when {prodname} runs a snapshot, it runs a SQL query such as:

`SELECT * FROM _<tableName>_ ....`

When the snapshot request includes an `additional-conditions` property, the `data-collection` and `filter` parameters of the  property are appended to the SQL query, for example:

`SELECT * FROM _<data-collection>_ WHERE _<filter>_ ....`

For example, given a `products` {data-collection} with the columns `id` (primary key), `color`, and `brand`, if you want a snapshot to include only content for which `color='blue'`, when you request the snapshot, you could add the `additional-conditions` property to filter the content:
----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "schema1.products" ,"filter":"color='blue'"}]}}`
----

You can use the `additional-conditions` property to pass conditions based on multiple columns.
For example, using the same `products` {data-collection} as in the previous example, if you want a snapshot to include only the content from the `products` {data-collection} for which `color='blue'`, and `brand='MyBrand'`, you could send the following request:

----
Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "schema1.products" ,"filter":"color='blue' AND brand='MyBrand'"}]}}`
----

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-db2-stopping-an-incremental-snapshot
[id="db2-stopping-an-incremental-snapshot"]
==== Stopping an incremental snapshot

:leveloffset: +1

You can also stop an incremental snapshot by sending a signal to the {data-collection} on the source database.
You submit a stop snapshot signal to the {data-collection} by sending a SQL `INSERT` query.

After {prodname} detects the change in the signaling {data-collection}, it reads the signal, and stops the incremental snapshot operation if it's in progress.

The query that you submit specifies the snapshot operation of `incremental`, and, optionally, the {data-collection}s of the current running snapshot to be removed.

.Prerequisites

* {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[Signaling is enabled]. +
** A signaling data collection exists on the source database.
** The signaling data collection is specified in the xref:{context}-property-signal-data-collection[`signal.data.collection`] property.

.Using a source signaling channel to stop an incremental snapshot

. Send a SQL query to stop the ad hoc incremental snapshot to the signaling {data-collection}:
+
[source,sql,indent=0,subs="+attributes,+quotes"]
----
INSERT INTO _<signalTable>_ (id, type, data) values (_'<id>'_, 'stop-snapshot', '{"data-collections": ["_<tableName>_","_<tableName>_"],"type":"incremental"}');
----
+
For example,
+
[source,sql,indent=0,subs="+attributes"]
----
INSERT INTO myschema.debezium_signal (id, type, data) // <1>
values ('ad-hoc-1',   // <2>
    'stop-snapshot',  // <3>
    '{"data-collections": ["schema1.table1", "schema2.table2"], // <4>
    "type":"incremental"}'); // <5>
----
+
The values of the `id`, `type`, and `data` parameters in the signal command correspond to the {link-prefix}:{link-signalling}#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection[fields of the signaling {data-collection}].
+
The following table describes the parameters in the example:
+
.Descriptions of fields in a SQL command for sending a stop incremental snapshot signal to the signaling {data-collection}
[cols="1,2,6",options="header"]
|===
|Item|Value |Description

|1
|`myschema.debezium_signal`
|Specifies the fully-qualified name of the signaling {data-collection} on the source database.

|2
|`ad-hoc-1`
| The `id` parameter specifies an arbitrary string that is assigned as the `id` identifier for the signal request. +
Use this string to identify logging messages to entries in the signaling {data-collection}.
{prodname} does not use this string.

|3
|`stop-snapshot`
| Specifies `type` parameter specifies the operation that the signal is intended to trigger. +

|4
|`data-collections`
|An optional component of the `data` field of a signal that specifies an array of {data-collection} names or regular expressions to match {data-collection} names to remove from the snapshot. +
The array lists regular expressions which match {data-collection}s by their fully-qualified names, using the same format as you use to specify the name of the connector's signaling {data-collection} in the xref:{context}-property-signal-data-collection[`signal.data.collection`] configuration property.
If this component of the `data` field is omitted, the signal stops the entire incremental snapshot that is in progress.

|5
|`incremental`
|A required component of the `data` field of a signal that specifies the type of snapshot operation that is to be stopped. +
Currently, the only valid option is `incremental`. +
If you do not specify a `type` value, the signal fails to stop the incremental snapshot.
|===

:leveloffset: 1

// Type: procedure
// ModuleID: debezium-db2-using-the-kafka-signaling-channel-to-stop-an-incremental-snapshot
[id="db2-stopping-an-incremental-snapshot-kafka"]
==== Using the Kafka signaling channel to stop an incremental snapshot

:leveloffset: +1

You can send a signal message to the {link-prefix}:{link-signalling}#debezium-signaling-enabling-kafka-signaling-channel[configured Kafka signaling topic] to stop an ad hoc incremental snapshot.

The key of the Kafka message must match the value of the `topic.prefix` connector configuration option.

The value of the message is a JSON object with `type` and `data` fields.

The signal type is `stop-snapshot`, and the `data` field must have the following fields:

.Execute snapshot data fields
[cols="2,2,6",options="header"]
|===
|Field | Default | Value

|`type`
|`incremental`
| The type of the snapshot to be executed.
Currently {prodname} supports only the `incremental` type.  +
See the next section for more details.

|`data-collections`
|_N/A_
| An optional array of comma-separated regular expressions that match the fully-qualified names of the tables to include in the snapshot. +
Specify the names by using the same format as is required for the xref:{context}-property-signal-data-collection[signal.data.collection] configuration option.

|===

The following example shows a typical `stop-snapshot` Kafka message:

----
Key = `test_connector`

Value = `{"type":"stop-snapshot","data": {"data-collections": ["schema1.table1", "schema1.table2"], "type": "INCREMENTAL"}}`
----

:leveloffset: 1

[[connector-custom-snapshot]]
=== Custom snapshotter SPI
:leveloffset: +3

For more advanced uses, you can fine-tune control of the snapshot by implementing one of the following interfaces:

`io.debezium.snapshot.spi.Snapshotter`:: Controls whether the connector takes a snapshot.
`io.debezium.snapshot.spi.SnapshotQuery`:: Controls how data is queried during a snapshot.
`io.debezium.snapshot.spi.SnapshotLock`:: Controls whether the connector locks tables when taking a snapshot.


[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.Snapshotter interface. All built-in snapshot modes implement this interface.
----
/**
 * {@link Snapshotter} is used to determine the following details about the snapshot process:
 * <p>
 * - Whether a snapshot occurs. <br>
 * - Whether streaming continues during the snapshot. <br>
 * - Whether the snapshot includes schema (if supported). <br>
 * - Whether to snapshot data or schema following an error.
 * <p>
 * Although Debezium provides many default snapshot modes,
 * to provide more advanced functionality, such as partial snapshots,
 * you can customize implementation of the interface.
 * For more information, see the documentation.
 *
 *
 *
 */
@Incubating
public interface Snapshotter extends Configurable {

    /**
     * @return the name of the snapshotter.
     *
     *
     */
    String name();

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a data snapshot
     */
    boolean shouldSnapshotData(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a schema snapshot
     */
    boolean shouldSnapshotSchema(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @return {@code true} if the snapshotter should stream after taking a snapshot
     */
    boolean shouldStream();

    /**
     * @return {@code true} whether the schema can be recovered if database schema history is corrupted.
     */
    boolean shouldSnapshotOnSchemaError();

    /**
     * @return {@code true} whether the snapshot should be re-executed when there is a gap in data stream.
     */
    boolean shouldSnapshotOnDataError();

    /**
     *
     * @return {@code true} if streaming should resume from the start of the snapshot
     * transaction, or {@code false} for when a connector resumes and takes a snapshot,
     * streaming should resume from where streaming previously left off.
     */
    default boolean shouldStreamEventsStartingFromSnapshot() {
        return true;
    }

    /**
     * Lifecycle hook called after the snapshot phase is successful.
     */
    default void snapshotCompleted() {
        // no operation
    }

    /**
     * Lifecycle hook called after the snapshot phase is aborted.
     */
    default void snapshotAborted() {
        // no operation
    }
}
----

[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.SnapshotQuery interface. All built-in snapshot query modes implement this interface.
----
/**
 * {@link SnapshotQuery} is used to determine the query used during a data snapshot
 *
 *
 */
public interface SnapshotQuery extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Generate a valid query string for the specified table, or an empty {@link Optional}
     * to skip snapshotting this table (but that table will still be streamed from)
     *
     * @param tableId the table to generate a query for
     * @param snapshotSelectColumns the columns to be used in the snapshot select based on the column
     *                              include/exclude filters
     * @return a valid query string, or none to skip snapshotting this table
     */
    Optional<String> snapshotQuery(String tableId, List<String> snapshotSelectColumns);

}
----

[source,java,indent=0,subs="+attributes"]
.io.debezium.snapshot.spi.SnapshotLock interface. All built-in snapshot lock modes implement this interface.
----
/**
 * {@link SnapshotLock} is used to determine the table lock mode used during schema snapshot
 *
 *
 */
public interface SnapshotLock extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Returns a SQL statement for locking the given table during snapshotting, if required by the specific snapshotter
     * implementation.
     */
    Optional<String> tableLockingStatement(Duration lockTimeout, String tableId);

}
----

:leveloffset: 1

// Type: concept
[id="db2-blocking-snapshots"]
=== Blocking snapshots

:leveloffset: +3

To provide more flexibility in managing snapshots, {prodname} includes a supplementary ad hoc snapshot mechanism, known as a _blocking snapshot_.
Blocking snapshots rely on the {prodname} mechanism for {link-prefix}:{link-signalling}#sending-signals-to-a-debezium-connector[sending signals to a {prodname} connector].

A blocking snapshot behaves just like an _initial snapshot_, except that you can trigger it at run time.

You might want to run a blocking snapshot rather than use the standard initial snapshot process in the following situations:

* You add a new {data-collection} and you want to complete the snapshot while the connector is running.
* You add a large {data-collection}, and you want the snapshot to complete in less time than is possible with an incremental snapshot.

.Blocking snapshot process
When you run a blocking snapshot, {prodname} stops streaming, and then initiates a snapshot of the specified {data-collection}, following the same process that it uses during an initial snapshot.
After the snapshot completes, the streaming is resumed.

.Configure snapshot

You can set the following properties in the `data` component of a signal:

 * data-collections: to specify which {data-collection}s must be snapshot
 * additional-conditions: You can specify different filters for different {data-collection}. +
 ** The `data-collection` property is the fully-qualified name of the {data-collection} for which the filter will be applied.
 ** The `filter` property will have the same value used in the  `snapshot.select.statement.overrides`

For example:
[source,json]
----
  {"type": "blocking", "data-collections": ["schema1.table1", "schema1.table2"], "additional-conditions": [{"data-collection": "schema1.table1", "filter": "SELECT * FROM [schema1].[table1] WHERE column1 = 0 ORDER BY column2 DESC"}, {"data-collection": "schema1.table2", "filter": "SELECT * FROM [schema1].[table2] WHERE column2 > 0"}]}
----

.Possible duplicates
A delay might exist between the time that you send the signal to trigger the snapshot, and the time when streaming stops and the snapshot starts.
As a result of this delay, after the snapshot completes, the connector might emit some event records that duplicate records captured by the snapshot.

:leveloffset: 1

// Type: concept
// Title: How {prodname} Db2 connectors read change-data tables
[id="how-debezium-db2-connectors-read-change-data-tables"]
=== Change-data tables

After a complete snapshot, when a {prodname} Db2 connector starts for the first time, the connector identifies the change-data table for each source table that is in capture mode.
The connector does the following for each change-data table:

. Reads change events that were created between the last stored, highest LSN and the current, highest LSN.
. Orders the change events according to the commit LSN and the change LSN for each event.
  This ensures that the connector emits the change events in the order in which the table changes occurred.
. Passes commit and change LSNs as offsets to Kafka Connect.
. Stores the highest LSN that the connector passed to Kafka Connect.

After a restart, the connector resumes emitting change events from the offset (commit and change LSNs) where it left off.
While the connector is running and emitting change events, if you remove a table from capture mode or add a table to capture mode, the connector detects the change, and modifies its behavior accordingly.

// Type: concept
// ModuleID: default-names-of-kafka-topics-that-receive-db2-change-event-records
// Title: Default names of Kafka topics that receive {prodname} Db2 change event records
[[db2-topic-names]]
=== Topic names

By default, the Db2 connector writes change events for all of the `INSERT`, `UPDATE`, and `DELETE` operations that occur in a table to a single Apache Kafka topic that is specific to that table.
The connector uses the following convention to name change event topics:

_topicPrefix_._schemaName_._tableName_

The following list provides definitions for the components of the default name:

_topicPrefix_:: The topic prefix as specified by the xref:db2-property-topic-prefix[`topic.prefix`] connector configuration property.

_schemaName_:: The name of the schema in which the operation occurred.

_tableName_:: The name of the table in which the operation occurred.

For example, consider a Db2 installation with the `mydatabase` database,  which contains four tables: `PRODUCTS`, `PRODUCTS_ON_HAND`, `CUSTOMERS`, and `ORDERS` that are in the `MYSCHEMA` schema. The connector would emit events to these four Kafka topics:

* `mydatabase.MYSCHEMA.PRODUCTS`
* `mydatabase.MYSCHEMA.PRODUCTS_ON_HAND`
* `mydatabase.MYSCHEMA.CUSTOMERS`
* `mydatabase.MYSCHEMA.ORDERS`

The connector applies similar naming conventions to label its internal database schema history topics, xref:about-the-debezium-db2-connector-schema-change-topic[schema change topics], and xref:db2-transaction-metadata[transaction metadata topics].

If the default topic name do not meet your requirements, you can configure custom topic names.
To configure custom topic names, you specify regular expressions in the logical topic routing SMT.
For more information about using the logical topic routing SMT to customize topic naming, see {link-prefix}:{link-topic-routing}#topic-routing[Topic routing].

// Type: concept
// ModuleID: how-debezium-db2-connectors-handle-database-schema-changes
// Title: How {prodname} Db2 connectors handle database schema changes
[[db2-schema-history-topic]]
=== Schema history topic

When a database client queries a database, the client uses the database’s current schema.
However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded.
Also, a connector cannot necessarily apply the current schema to every event.
If an event is relatively old, it's possible that it was recorded before the current schema was applied.

To ensure correct processing of events that occur after a schema change, the {prodname} Db2 connector stores a snapshot of the new schema based on the structures of the Db2 change data tables, which mirror the structures of their associated data tables.
The connector stores the table schema information, together with the LSN of operations the result in schema changes, in the database schema history Kafka topic.
The connector uses the stored schema representation to produce change events that correctly mirror the structure of tables at the time of each insert, update, or delete operation.

When the connector restarts after either a crash or a graceful stop, it resumes reading entries in the Db2 change data tables from the last position that it read.
Based on the schema information that the connector reads from the database schema history topic, the connector applies the table structures that existed at the position where the connector restarts.

If you update the schema of a Db2 table that is in capture mode, it's important that you also update the schema of the corresponding change table.
You must be a Db2 database administrator with elevated privileges to update database schema.
For more information about how to update Db2 database schema in {prodname} environments, see xref:db2-schema-evolution[Schema history eveolution].

The database schema history topic is for internal connector use only.
Optionally, the connector can also xref:about-the-debezium-db2-connector-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].

.Additional resources

* xref:db2-topic-names[Default names for topics] that receive {prodname} event records.

// Type: concept
// Title: About the {prodname} Db2 connector schema change topic
[id="about-the-debezium-db2-connector-schema-change-topic"]
=== Schema change topic

You can configure a {prodname} Db2 connector to produce schema change events that describe schema changes that are applied to tables in the database.

{prodname} emits a message to the schema change topic when:

* A new table goes into capture mode.
* A table is removed from capture mode.
* During a xref:db2-schema-evolution[database schema update], there is a change in the schema for a table that is in capture mode.

The connector writes schema change events to a Kafka schema change topic that has the name `_<topicPrefix>_` where `_<topicPrefix>_` is the topic prefix that is specified in the xref:db2-property-topic-prefix[`topic.prefix`] connector configuration property.

The schema for the schema change event has the following elements:

`name`:: The name of the schema change event message.
`type`:: The type of the change event message.
`version`:: The version of the schema. The version is an integer that is incremented each time the schema is changed.
`fields`:: The fields that are included in the change event message.

.Example: Schema of the Db2 connector schema change topic
The following example shows a typical schema in JSON format.

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {
    "type": "struct",
    "fields": [
      {
        "type": "string",
        "optional": false,
        "field": "databaseName"
      }
    ],
    "optional": false,
    "name": "io.debezium.connector.db2.SchemaChangeKey",
    "version": 1
  },
  "payload": {
    "databaseName": "inventory"
  }
}
----

Messages that the connector sends to the schema change topic contain a payload that includes the following elements:

`databaseName`:: The name of the database to which the statements are applied.
The value of `databaseName` serves as the message key.
`pos`:: The position in the transaction log where the statements appear.
`tableChanges`::  A structured representation of the entire table schema after the schema change.
The `tableChanges` field contains an array that includes entries for each column of the table.
Because the structured representation presents data in JSON or Avro format, consumers can easily read messages without first processing them through a DDL parser.

[IMPORTANT]
====
For a table that is in capture mode, the connector not only stores the history of schema changes in the schema change topic, but also in an internal database schema history topic.
The internal database schema history topic is for connector use only and it is not intended for direct use by consuming applications.
Ensure that applications that require notifications about schema changes consume that information only from the schema change topic.
====

[IMPORTANT]
====
Never partition the database schema history topic.
For the database schema history topic to function correctly, it must maintain a consistent, global order of the event records that the connector emits to it.

To ensure that the topic is not split among partitions, set the partition count for the topic by using one of the following methods:

* If you create the database schema history topic manually, specify a partition count of `1`.
* If you use the Apache Kafka broker to create the database schema history topic automatically, the topic is created, set the value of the link:{link-kafka-docs}/#brokerconfigs_num.partitions[Kafka `num.partitions`] configuration option to `1`.
====

[WARNING]
====
The format of messages that a connector emits to its schema change topic is in an incubating state and can change without notice.
====

.Example: Message emitted to the Db2 connector schema change topic
The following example shows a message in the schema change topic.
The message contains a logical representation of the table schema.

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {
  ...
  },
  "payload": {
    "source": {
      "version": "{debezium-version}",
      "connector": "db2",
      "name": "db2",
      "ts_ms": 0,
      "snapshot": "true",
      "db": "testdb",
      "schema": "DB2INST1",
      "table": "CUSTOMERS",
      "change_lsn": null,
      "commit_lsn": "00000025:00000d98:00a2",
      "event_serial_no": null
    },
    "ts_ms": 1588252618953, // <1>
    "databaseName": "TESTDB", // <2>
    "schemaName": "DB2INST1",
    "ddl": null, // <3>
    "tableChanges": [ // <4>
      {
        "type": "CREATE", // <5>
        "id": "\"DB2INST1\".\"CUSTOMERS\"", // <6>
        "table": { // <7>
          "defaultCharsetName": null,
          "primaryKeyColumnNames": [ // <8>
            "ID"
          ],
          "columns": [ // <9>
            {
              "name": "ID",
              "jdbcType": 4,
              "nativeType": null,
              "typeName": "int identity",
              "typeExpression": "int identity",
              "charsetName": null,
              "length": 10,
              "scale": 0,
              "position": 1,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "FIRST_NAME",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 2,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "LAST_NAME",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 3,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "EMAIL",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 4,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            }
          ],
          "attributes": [ // <10>
            {
              "customAttribute": "attributeValue"
            }
          ]
        }
      }
    ]
  }
}
----

.Descriptions of fields in messages emitted to the schema change topic
[cols="1,3,6",options="header"]
|===
|Item |Field name |Description

|1
|`ts_ms`
|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.

In the source object, ts_ms indicates the time that the change was made in the database. By comparing the value for payload.source.ts_ms with the value for payload.ts_ms, you can determine the lag between the source database update and Debezium.

|2
|`databaseName` +
`schemaName`
|Identifies the database and the schema that contain the change.

|3
|`ddl`
|Always `null` for the Db2 connector.
For other connectors, this field contains the DDL responsible for the schema change.
This DDL is not available to Db2 connectors.

|4
|`tableChanges`
|An array of one or more items that contain the schema changes generated by a DDL command.

|5
|`type`
a|Describes the kind of change. The value is one of the following:

* `CREATE` - table created
* `ALTER` - table modified
* `DROP` - table deleted

|6
|`id`
|Full identifier of the table that was created, altered, or dropped.

|7
|`table`
|Represents table metadata after the applied change.

|8
|`primaryKeyColumnNames`
|List of columns that compose the table's primary key.

|9
|`columns`
|Metadata for each column in the changed table.

|10
|`attributes`
|Custom attribute metadata for each table change.

|===

In messages that the connector sends to the schema change topic, the message key is the name of the database that contains the schema change.
In the following example, the `payload` field contains the key:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {
    "type": "struct",
    "fields": [
      {
        "type": "string",
        "optional": false,
        "field": "databaseName"
      }
    ],
    "optional": false,
    "name": "io.debezium.connector.db2.SchemaChangeKey",
    "version": 1
  },
  "payload": {
    "databaseName": "TESTDB"
  }
}
----


// Type: concept
// ModuleID: debezium-db2-connector-generated-events-that-represent-transaction-boundaries
// Title: {prodname} Db2 connector-generated events that represent transaction boundaries
[[db2-transaction-metadata]]
=== Transaction metadata

{prodname} can generate events that represent transaction boundaries and that enrich change data event messages.

[NOTE]
.Limits on when {prodname} receives transaction metadata
====
{prodname} registers and receives metadata only for transactions that occur after you deploy the connector.
Metadata for transactions that occur before you deploy the connector is not available.
====

{prodname} generates transaction boundary events for the `BEGIN` and `END` delimiters in every transaction.
Transaction boundary events contain the following fields:

`status`:: `BEGIN` or `END`.
`id`:: String representation of the unique transaction identifier.
`ts_ms`:: The time of a transaction boundary event (`BEGIN` or `END` event) at the data source.
If the data source does not provide {prodname} with the event time, then the field instead represents the time at which {prodname} processes the event.
`event_count` (for `END` events):: Total number of events emmitted by the transaction.
`data_collections` (for `END` events):: An array of pairs of `data_collection` and `event_count` elements that indicates the number of events that the connector emits for changes that originate from a data collection.

.Example

[source,json,indent=0,subs="+attributes"]
----
{
  "status": "BEGIN",
  "id": "00000025:00000d08:0025",
  "ts_ms": 1486500577125,
  "event_count": null,
  "data_collections": null
}

{
  "status": "END",
  "id": "00000025:00000d08:0025",
  "ts_ms": 1486500577691,
  "event_count": 2,
  "data_collections": [
    {
      "data_collection": "testDB.dbo.tablea",
      "event_count": 1
    },
    {
      "data_collection": "testDB.dbo.tableb",
      "event_count": 1
    }
  ]
}
----

Unless overridden via the xref:db2-property-topic-transaction[`topic.transaction`] option,
the connector emits transaction events to the xref:db2-property-topic-prefix[`_<topic.prefix>_`]`.transaction` topic.

.Data change event enrichment

When transaction metadata is enabled the connector enriches the change event  `Envelope` with a new `transaction` field.
This field provides information about every event in the form of a composite of fields:

`id`:: String representation of unique transaction identifier.
`total_order`:: The absolute position of the event among all events generated by the transaction.
`data_collection_order`:: The per-data collection position of the event among all events that were emitted by the transaction.

Following is an example of a message:

[source,json,indent=0,subs="+attributes"]
----
{
  "before": null,
  "after": {
    "pk": "2",
    "aa": "1"
  },
  "source": {
...
  },
  "op": "c",
  "ts_ms": "1580390884335",
  "ts_us": "1580390884335875",
  "ts_ns": "1580390884335875412",
  "transaction": {
    "id": "00000025:00000d08:0025",
    "total_order": "1",
    "data_collection_order": "1"
  }
}
----

// Type: assembly
// ModuleID: descriptions-of-debezium-db2-connector-data-change-events
// Title: Descriptions of {prodname} Db2 connector data change events
[[db2-events]]
== Data change events

The {prodname} Db2 connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed.

{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained.

The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converter and you configure it to produce all four basic change event parts, change events have this structure:

[source,json,index=0]
----
{
 "schema": { // <1>
   ...
  },
 "payload": { // <2>
   ...
 },
 "schema": { // <3>
   ...
 },
 "payload": { // <4>
   ...
 },
}
----

.Overview of change event basic content
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +
 +
It is possible to override the table's primary key by setting the xref:db2-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.

|2
|`payload`
|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed.

|3
|`schema`
|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas.

|4
|`payload`
|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.

|===

By default, the connector streams change event records to topics with names that are the same as the event's originating table. For more information, see xref:db2-topic-names[topic names].

[WARNING]
====
The {prodname} Db2 connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or \_. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or \_. If there is an invalid character it is replaced with an underscore character.

This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.

Also, Db2 names for databases, schemas, and tables can be case sensitive. This means that the connector could emit event records for more than one table to the same Kafka topic.
====


// Type: concept
// ModuleID: about-keys-in-debezium-db2-change-events
// Title: About keys in {prodname} db2 change events
[[db2-change-event-keys]]
=== Change event keys

A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.

Consider the following `customers` table, which is followed by an example of a change event key for this table.

.Example table
[source,sql,indent=0]
----
CREATE TABLE customers (
 ID INTEGER IDENTITY(1001,1) NOT NULL PRIMARY KEY,
 FIRST_NAME VARCHAR(255) NOT NULL,
 LAST_NAME VARCHAR(255) NOT NULL,
 EMAIL VARCHAR(255) NOT NULL UNIQUE
);
----

.Example change event key
Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:

[source,json,indent=0]
----
{
    "schema": {  // <1>
        "type": "struct",
        "fields": [  // <2>
            {
                "type": "int32",
                "optional": false,
                "field": "ID"
            }
        ],
        "optional": false,  // <3>
        "name": "mydatabase.MYSCHEMA.CUSTOMERS.Key"  // <4>
    },
    "payload": {  // <5>
        "ID": 1004
    }
}
----

.Description of change event key
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion.

|2
|`fields`
|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.

|3
|`optional`
|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.

|4
|`mydatabase.MYSCHEMA.CUSTOMERS.Key`
a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: +

* `mydatabase` is the name of the connector that generated this event. +
* `MYSCHEMA` is the database schema that contains the table that was changed. +
* `CUSTOMERS` is the table that was updated.

|5
|`payload`
|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `ID` field whose value is `1004`.

|===

////
[NOTE]
====
Although the `column.exclude.list` connector configuration property allows you to omit columns from event values, all columns in a primary or unique key are always included in the event's key.
====

[WARNING]
====
If the table does not have a primary or unique key, then the change event's key is null. The rows in a table without a primary or unique key constraint cannot be uniquely identified.
====
////

// Type: concept
// ModuleID: about-values-in-debezium-db2-change-events
// Title: About values in {prodname} Db2 change events
[[db2-change-event-values]]
=== Change event values

The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure.

Consider the same sample table that was used to show an example of a change event key:

.Example table
[source,sql,indent=0]
----
CREATE TABLE customers (
 ID INTEGER IDENTITY(1001,1) NOT NULL PRIMARY KEY,
 FIRST_NAME VARCHAR(255) NOT NULL,
 LAST_NAME VARCHAR(255) NOT NULL,
 EMAIL VARCHAR(255) NOT NULL UNIQUE
);
----

The event value portion of every change event for the `customers` table specifies the same schema. The event value's payload varies according to the event type:

* <<db2-create-events,_create_ events>>
* <<db2-update-events,_update_ events>>
* <<db2-delete-events,_delete_ events>>

[[db2-create-events]]
=== _create_ events

The following example shows the value portion of a change event that the connector generates for an operation that creates data in the `customers` table:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": {  // <1>
    "type": "struct",
    "fields": [
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "ID"
          },
          {
            "type": "string",
            "optional": false,
            "field": "FIRST_NAME"
          },
          {
            "type": "string",
            "optional": false,
            "field": "LAST_NAME"
          },
          {
            "type": "string",
            "optional": false,
            "field": "EMAIL"
          }
        ],
        "optional": true,
        "name": "mydatabase.MYSCHEMA.CUSTOMERS.Value",  // <2>
        "field": "before"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "ID"
          },
          {
            "type": "string",
            "optional": false,
            "field": "FIRST_NAME"
          },
          {
            "type": "string",
            "optional": false,
            "field": "LAST_NAME"
          },
          {
            "type": "string",
            "optional": false,
            "field": "EMAIL"
          }
        ],
        "optional": true,
        "name": "mydatabase.MYSCHEMA.CUSTOMERS.Value",
        "field": "after"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "string",
            "optional": false,
            "field": "version"
          },
          {
            "type": "string",
            "optional": false,
            "field": "connector"
          },
          {
            "type": "string",
            "optional": false,
            "field": "name"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ms"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_us"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ns"
          },
          {
            "type": "boolean",
            "optional": true,
            "default": false,
            "field": "snapshot"
          },
          {
            "type": "string",
            "optional": false,
            "field": "db"
          },
          {
            "type": "string",
            "optional": false,
            "field": "schema"
          },
          {
            "type": "string",
            "optional": false,
            "field": "table"
          },
          {
            "type": "string",
            "optional": true,
            "field": "change_lsn"
          },
          {
            "type": "string",
            "optional": true,
            "field": "commit_lsn"
          },
        ],
        "optional": false,
        "name": "io.debezium.connector.db2.Source",  // <3>
        "field": "source"
      },
      {
        "type": "string",
        "optional": false,
        "field": "op"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ms"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_us"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ns"
      }
    ],
    "optional": false,
    "name": "mydatabase.MYSCHEMA.CUSTOMERS.Envelope"  // <4>
  },
  "payload": {  // <5>
    "before": null,  // <6>
    "after": {  // <7>
      "ID": 1005,
      "FIRST_NAME": "john",
      "LAST_NAME": "doe",
      "EMAIL": "john.doe@example.org"
    },
    "source": {  // <8>
      "version": "{debezium-version}",
      "connector": "db2",
      "name": "myconnector",
      "ts_ms": 1559729468470,
      "ts_us": 1559729468470476,
      "ts_ns": 1559729468470476000,
      "snapshot": false,
      "db": "mydatabase",
      "schema": "MYSCHEMA",
      "table": "CUSTOMERS",
      "change_lsn": "00000027:00000758:0003",
      "commit_lsn": "00000027:00000758:0005",
    },
    "op": "c",  // <9>
    "ts_ms": 1559729471739,  // <10>
    "ts_us": 1559729471739762,  // <10>
    "ts_ns": 1559729471739762314  // <10>
  }
}
----

.Descriptions of _create_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`schema`
|The value's schema, which describes the structure of the value's payload. A change event's value schema is the same in every change event that the connector generates for a particular table.

|2
|`name`
a|In the `schema` section, each `name` field specifies the schema for a field in the value's payload. +
 +
`mydatabase.MYSCHEMA.CUSTOMERS.Value` is the schema for the payload's `before` and `after` fields. This schema is specific to the `customers` table. The connector uses this schema for all rows in the `MYSCHEMA.CUSTOMERS` table. +
 +
Names of schemas for `before` and `after` fields are of the form `_logicalName_._schemaName_._tableName_.Value`, which ensures that the schema name is unique in the database.
This means that when using the {link-prefix}:{link-avro-serialization}#avro-serialization[Avro converter], the resulting Avro schema for each table in each logical source has its own evolution and history.

|3
|`name`
a|`io.debezium.connector.db2.Source` is the schema for the payload's `source` field. This schema is specific to the Db2 connector. The connector uses it for all events that it generates.

|4
|`name`
a|`mydatabase.MYSCHEMA.CUSTOMERS.Envelope` is the schema for the overall structure of the payload, where `mydatabase` is the database, `MYSCHEMA` is the schema, and `CUSTOMERS` is the table.

|5
|`payload`
|The value's actual data. This is the information that the change event is providing. +
 +
It may appear that JSON representations of events are much larger than the rows they describe. This is because a JSON representation must include the schema portion and the payload portion of the message.
However, by using the {link-prefix}:{link-avro-serialization}#avro-serialization[Avro converter], you can significantly decrease the size of the messages that the connector streams to Kafka topics.

|6
|`before`
|An optional field that specifies the state of the row before the event occurred. When the `op` field is `c` for create, as it is in this example, the `before` field is `null` since this change event is for new content.

|7
|`after`
|An optional field that specifies the state of the row after the event occurred. In this example, the `after` field contains the values of the new row's `ID`, `FIRST_NAME`, `LAST_NAME`, and `EMAIL` columns.

|8
|`source`
a| Mandatory field that describes the source metadata for the event. The `source` structure shows Db2 information about this change, which provides traceability. It also has information you can use to compare to other events in the same topic or in other topics to know whether this event occurred before, after, or as part of the same commit as other events. The source metadata includes:

* {prodname} version
* Connector type and name
* Timestamp for when the change was made in the database
* Whether the event is part of an ongoing snapshot
* Name of the database, schema, and table that contain the new row
* Change LSN
* Commit LSN (omitted if this event is part of a snapshot)

|9
|`op`
a|Mandatory string that describes the type of operation that caused the connector to generate the event. In this example, `c` indicates that the operation created a row. Valid values are:

* `c` = create
* `u` = update
* `d` = delete
* `r` = read (applies to only snapshots)

|10
|`ts_ms`, `ts_us`, `ts_ns`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task. +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

[[db2-update-events]]
=== _update_ events
The value of a change event for an update in the sample `customers` table has the same schema as a _create_ event for that table. Likewise, the _update_ event value's payload has the same structure. However, the event value payload contains different values in an _update_ event. Here is an example of a change event value in an event that the connector generates for an update in the `customers` table:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": { ... },
  "payload": {
    "before": {  // <1>
      "ID": 1005,
      "FIRST_NAME": "john",
      "LAST_NAME": "doe",
      "EMAIL": "john.doe@example.org"
    },
    "after": {  // <2>
      "ID": 1005,
      "FIRST_NAME": "john",
      "LAST_NAME": "doe",
      "EMAIL": "noreply@example.org"
    },
    "source": {  // <3>
      "version": "{debezium-version}",
      "connector": "db2",
      "name": "myconnector",
      "ts_ms": 1559729995937,
      "ts_us": 1559729995937497,
      "ts_ns": 1559729995937497000,
      "snapshot": false,
      "db": "mydatabase",
      "schema": "MYSCHEMA",
      "table": "CUSTOMERS",
      "change_lsn": "00000027:00000ac0:0002",
      "commit_lsn": "00000027:00000ac0:0007",
    },
    "op": "u",  // <4>
    "ts_ms": 1559729998706,  // <5>
    "ts_us": 1559729998706647,  // <5>
    "ts_ns": 1559729998706647825  // <5>
  }
}
----

.Descriptions of _update_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|An optional field that specifies the state of the row before the event occurred. In an _update_ event value, the `before` field contains a field for each table column and the value that was in that column before the database commit. In this example, note that the `EMAIL` value is `john.doe@example.com`.

|2
|`after`
| An optional field that specifies the state of the row after the event occurred. You can compare the `before` and `after` structures to determine what the update to this row was. In the example, the `EMAIL` value is now `noreply@example.com`.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. The `source` field structure contains the same fields as in a _create_ event, but some values are different, for example, the sample _update_ event has different LSNs. You can use this information to compare this event to other events to know whether this event occurred before, after, or as part of the same commit as other events. The source metadata includes:

* {prodname} version
* Connector type and name
* Timestamp for when the change was made in the database
* Whether the event is part of an ongoing snapshot
* Name of the database, schema, and table that contain the new row
* Change LSN
* Commit LSN (omitted if this event is part of a snapshot)

|4
|`op`
a|Mandatory string that describes the type of operation. In an _update_ event value, the `op` field value is `u`, signifying that this row changed because of an update.

|5
|`ts_ms`, `ts_us`, `ts_ns`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task. +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

[NOTE]
====
Updating the columns for a row's primary/unique key changes the value of the row's key. When a key changes, {prodname} outputs _three_ events: a `DELETE` event and a xref:db2-tombstone-events[tombstone event] with the old key for the row, followed by an event with the new key for the row.
====

[[db2-delete-events]]
=== _delete_ events

The value in a _delete_ change event has the same `schema` portion as _create_ and _update_ events for the same table. The event value `payload` in a _delete_ event for the sample `customers` table looks like this:

[source,json,indent=0,subs="+attributes"]
----
{
  "schema": { ... },
  },
  "payload": {
    "before": {  // <1>
      "ID": 1005,
      "FIRST_NAME": "john",
      "LAST_NAME": "doe",
      "EMAIL": "noreply@example.org"
    },
    "after": null,  // <2>
    "source": {  // <3>
      "version": "{debezium-version}",
      "connector": "db2",
      "name": "myconnector",
      "ts_ms": 1559730445243,
      "ts_us": 1559730445243482,
      "ts_ns": 1559730445243482000,
      "snapshot": false,
      "db": "mydatabase",
      "schema": "MYSCHEMA",
      "table": "CUSTOMERS",
      "change_lsn": "00000027:00000db0:0005",
      "commit_lsn": "00000027:00000db0:0007"
    },
    "op": "d",  // <4>
    "ts_ms": 1559730450205,  // <5>
    "ts_us": 1559730450205521,  // <5>
    "ts_ns": 1559730450205521475  // <5>
  }
}
----

.Descriptions of _delete_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`before`
|Optional field that specifies the state of the row before the event occurred. In a _delete_ event value, the `before` field contains the values that were in the row before it was deleted with the database commit.

|2
|`after`
| Optional field that specifies the state of the row after the event occurred. In a _delete_ event value, the `after` field is `null`, signifying that the row no longer exists.

|3
|`source`
a|Mandatory field that describes the source metadata for the event. In a _delete_ event value, the `source` field structure is the same as for _create_ and _update_ events for the same table. Many `source` field values are also the same. In a _delete_ event value, the `ts_ms` and LSN field values, as well as other values, might have changed. But the `source` field in a _delete_ event value provides the same metadata:

* {prodname} version
* Connector type and name
* Timestamp for when the change was made in the database
* Whether the event is part of an ongoing snapshot
* Name of the database, schema, and table that contain the new row
* Change LSN
* Commit LSN (omitted if this event is part of a snapshot)

|4
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `d`, signifying that this row was deleted.

|5
|`ts_ms`, `ts_us`, `ts_ns`
a|Optional field that displays the time at which the connector processed the event.
The time is based on the system clock in the JVM running the Kafka Connect task. +
 +
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

A _delete_ change event record provides a consumer with the information it needs to process the removal of this row. The old values are included because some consumers might require them in order to properly handle the removal.

Db2 connector events are designed to work with link:{link-kafka-docs}/#compaction[Kafka log compaction]. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.

[[db2-tombstone-events]]
When a row is deleted, the _delete_ event value still works with log compaction, because Kafka can remove all earlier messages that have that same key. However, for Kafka to remove all messages that have that same key, the message value must be `null`. To make this possible, after {prodname}’s Db2 connector emits a _delete_ event, the connector emits a special tombstone event that has the same key but a `null` value.

// Type: reference
// ModuleID: how-debezium-db2-connectors-map-data-types
// Title: How {prodname} Db2 connectors map data types
[[db2-data-types]]
== Data type mappings

For a complete description of the data types that Db2 supports, see https://www.ibm.com/support/knowledgecenter/en/SSEPGG_11.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0008483.html[Data Types] in the Db2 documentation.

The Db2 connector represents changes to rows with events that are structured like the table in which the row exists. The event contains a field for each column value. How that value is represented in the event depends on the Db2 data type of the column. This section describes these mappings.
If the default data type conversions do not meet your needs, you can {link-prefix}:{link-custom-converters}#custom-converters[create a custom converter] for the connector.


[id="db2-basic-types"]
=== Basic types

The following table describes how the connector maps each Db2 data type to a _literal type_ and a _semantic type_ in event fields.

* _literal type_ describes how the value is represented using Kafka Connect schema types: `INT8`, `INT16`, `INT32`, `INT64`, `FLOAT32`, `FLOAT64`, `BOOLEAN`, `STRING`, `BYTES`, `ARRAY`, `MAP`, and `STRUCT`.

* _semantic type_ describes how the Kafka Connect schema captures the _meaning_ of the field using the name of the Kafka Connect schema for the field.

.Mappings for Db2 basic data types
[cols="25%a,20%a,55%a",options="header"]
|===
|Db2 data type
|Literal type (schema type)
|Semantic type (schema name) and Notes

|`BOOLEAN`
|`BOOLEAN`
|Only snapshots can be taken from tables with BOOLEAN type columns. Currently SQL Replication on Db2 does not support BOOLEAN, so Debezium can not perform CDC on those tables. Consider using a different type.


|`BIGINT`
|`INT64`
|n/a

|`BINARY`
|`BYTES`
|n/a

|`BLOB`
|`BYTES`
|n/a

|`CHAR[(N)]`
|`STRING`
|n/a

|`CLOB`
|`STRING`
|n/a

|`DATE`
|`INT32`
|`io.debezium.time.Date` +
 +
String representation of a timestamp without timezone information

|`DECFLOAT`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`

|`DECIMAL`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal`

|`DBCLOB`
|`STRING`
|n/a

|`DOUBLE`
|`FLOAT64`
|n/a

|`INTEGER`
|`INT32`
|n/a

|`REAL`
|`FLOAT32`
|n/a

|`SMALLINT`
|`INT16`
|n/a

|`TIME`
|`INT32`
|`io.debezium.time.Time` +
 +
String representation of a time without timezone information

|`TIMESTAMP`
|`INT64`
|`io.debezium.time.MicroTimestamp` +
 +
String representation of a timestamp without timezone information

|`VARBINARY`
|`BYTES`
|n/a

|`VARCHAR[(N)]`
|`STRING`
|n/a

|`VARGRAPHIC`
|`STRING`
|n/a

|`XML`
|`STRING`
|`io.debezium.data.Xml` +
 +
String representation of an XML document
|===

If present, a column's default value is propagated to the corresponding field's Kafka Connect schema. Change events contain the field's default value unless an explicit column value had been given. Consequently, there is rarely a need to obtain the default value from the schema.
Passing the default value helps satisfy compatibility rules when {link-prefix}:{link-avro-serialization}[using Avro] as the serialization format together with the Confluent schema registry.

[[db2-temporal-types]]
=== Temporal types

Except for the `DATETIMEOFFSET` data type, which contains time zone information, Db2 maps temporal types based on the value of the `time.precision.mode` connector configuration property.
The following sections describe these mappings:

* xref:db2-time-precision-mode-adaptive[`time.precision.mode=adaptive`]
* xref:db2-time-precision-mode-connect[`time.precision.mode=connect`]

[[db2-time-precision-mode-adaptive]]
.`time.precision.mode=adaptive`
When the `time.precision.mode` configuration property is set to `adaptive`, the default, the connector determines the literal type and semantic type based on the column's data type definition. This ensures that events _exactly_ represent the values in the database.

.Mappings when `time.precision.mode` is `adaptive`
[cols="25%a,20%a,55%a",options="header"]
|===
|Db2 data type |Literal type (schema type) |Semantic type (schema name) and Notes

|`DATE`
|`INT32`
|`io.debezium.time.Date` +
 +
Represents the number of days since the epoch.

|`TIME(0)`, `TIME(1)`, `TIME(2)`, `TIME(3)`
|`INT32`
|`io.debezium.time.Time` +
 +
Represents the number of milliseconds past midnight, and does not include timezone information.

|`TIME(4)`, `TIME(5)`, `TIME(6)`
|`INT64`
|`io.debezium.time.MicroTime` +
 +
Represents the number of microseconds past midnight, and does not include timezone information.

|`TIME(7)`
|`INT64`
|`io.debezium.time.NanoTime` +
 +
Represents the number of nanoseconds past midnight, and does not include timezone information.

|`DATETIME`
|`INT64`
|`io.debezium.time.Timestamp` +
 +
Represents the number of milliseconds since the epoch, and does not include timezone information.

|===

[[db2-time-precision-mode-connect]]
.`time.precision.mode=connect`
When the `time.precision.mode` configuration property is set to `connect`, the connector uses Kafka Connect logical types. This may be useful when consumers can handle only the built-in Kafka Connect logical types and are unable to handle variable-precision time values. However, since Db2 supports tenth of a microsecond precision, the events generated by a connector with the `connect` time precision *results in a loss of precision* when the database column has a _fractional second precision_ value that is greater than 3.

.Mappings when `time.precision.mode` is `connect`
[cols="25%a,20%a,55%a",options="header"]
|===
|Db2 data type |Literal type (schema type) |Semantic type (schema name) and Notes

|`DATE`
|`INT32`
|`org.apache.kafka.connect.data.Date` +
 +
Represents the number of days since the epoch.

|`TIME([P])`
|`INT64`
|`org.apache.kafka.connect.data.Time` +
 +
Represents the number of milliseconds since midnight, and does not include timezone information. Db2 allows `P` to be in the range 0-7 to store up to tenth of a microsecond precision, though this mode results in a loss of precision when `P` is greater than 3.

|`DATETIME`
|`INT64`
|`org.apache.kafka.connect.data.Timestamp` +
 +
Represents the number of milliseconds since the epoch, and does not include timezone information.

|===

[[db2-timestamp-types]]
=== Timestamp types

The `DATETIME` type represents a timestamp without time zone information.
Such columns are converted into an equivalent Kafka Connect value based on UTC.
For example, the `DATETIME` value "2018-06-20 15:13:16.945104" is represented by an `io.debezium.time.Timestamp` with the value "1529507596000".

The timezone of the JVM running Kafka Connect and {prodname} does not affect this conversion.

[[db2-decimal-types]]
=== Decimal types

[cols="27%a,18%a,55%a",options="header"]
|===
|Db2 data type |Literal type (schema type) |Semantic type (schema name) and Notes

|`NUMERIC[(P[,S])]`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal` +
 +
The `scale` schema parameter contains an integer that represents how many digits the decimal point is shifted.
The `connect.decimal.precision` schema parameter contains an integer that represents the precision of the given decimal value.

|`DECIMAL[(P[,S])]`
|`BYTES`
|`org.apache.kafka.connect.data.Decimal` +
 +
The `scale` schema parameter contains an integer that represents how many digits the decimal point is shifted.
The `connect.decimal.precision` schema parameter contains an integer that  represents the precision of the given decimal value.

|===

// Type: assembly
// ModuleID: setting-up-db2-to-run-a-debezium-connector
// Title: Setting up Db2 to run a {prodname} connector
[[setting-up-db2]]
== Setting up Db2

For {prodname} to capture change events that are committed to Db2 tables, a Db2 database administrator with the necessary privileges must configure tables in the database for change data capture.
After you begin to run {prodname} you can adjust the configuration of the capture agent to optimize performance.


// Type: procedure
// ModuleID: configuring-db2-tables-for-change-data-capture
// Title: Configuring Db2 tables for change data capture
[id="putting-tables-in-capture-mode"]
=== Putting tables into capture mode

To put tables into capture mode, {prodname} provides a set of user-defined functions (UDFs) for your convenience.
The procedure here shows how to install and run these management UDFs.
Alternatively, you can run Db2 control commands to put tables into capture mode.
The administrator must then enable CDC for each table that you want Debezium to capture.

.Prerequisites

* You are logged in to Db2 as the `db2instl` user.
* On the Db2 host, the Debezium management UDFs are available in the $HOME/asncdctools/src directory.
 UDFs are available from the link:https://github.com/debezium/debezium-examples/tree/main/tutorial/debezium-db2-init/db2server[Debezium examples repository].
* The Db2 command `bldrtn` is on PATH, e.g. by running `export PATH=$PATH:/opt/ibm/db2/V11.5.0.0/samples/c/` with Db2 11.5

.Procedure

. Compile the {prodname} management UDFs on the Db2 server host by using the `bldrtn`
command provided with Db2:
+
[source,shell]
----
cd $HOME/asncdctools/src
----
+
[source,shell]
----
bldrtn asncdc
----

. Start the database if it is not already running. Replace `DB_NAME` with the name of the database that you want {prodname} to connect to.
+
[source,shell]
----
db2 start db DB_NAME
----

. Ensure that JDBC can read the Db2 metadata catalog:
+
[source,shell]
----
cd $HOME/sqllib/bnd
----
+
[source,shell]
----
db2 connect to DB_NAME
db2 bind db2schema.bnd blocking all grant public sqlerror continue
----

. Ensure that the database was recently backed-up. The ASN agents must have a recent starting point to read from. If you need to perform a backup, run the following commands, which prune the data so that only the most recent version is available. If you do not need to retain the older versions of the data, specify `dev/null` for the backup location.

.. Back up the database. Replace `DB_NAME` and `BACK_UP_LOCATION` with appropriate values:
+
[source,shell]
----
db2 backup db DB_NAME to BACK_UP_LOCATION
----

.. Restart the database:
+
[source,shell]
----
db2 restart db DB_NAME
----

. Connect to the database to install the {prodname} management UDFs. It is assumed that you are logged in as the `db2instl` user so the UDFs should be installed on the `db2inst1` user.
+
[source,shell]
----
db2 connect to DB_NAME
----

. Copy the {prodname} management UDFs and set permissions for them:
+
[source,shell]
----
cp $HOME/asncdctools/src/asncdc $HOME/sqllib/function
----
+
[source,shell]
----
chmod 777 $HOME/sqllib/function
----

. Enable the {prodname} UDF that starts and stops the ASN capture agent:
+
[source,shell]
----
db2 -tvmf $HOME/asncdctools/src/asncdc_UDF.sql
----

. Create the ASN control tables:
+
[source,shell]
----
$ db2 -tvmf $HOME/asncdctools/src/asncdctables.sql
----

. Enable the {prodname} UDF that adds tables to capture mode and removes tables from capture mode:
+
[source,shell]
----
$ db2 -tvmf $HOME/asncdctools/src/asncdcaddremove.sql
----
+
After you set up the Db2 server, use the UDFs to control Db2 replication (ASN) with SQL commands.
Some of the UDFs expect a return value in which case you use the SQL `VALUE` statement to invoke them.
For other UDFs, use the SQL `CALL` statement.

. Start the ASN agent from an SQL client:
+
[source,sql]
----
VALUES ASNCDC.ASNCDCSERVICES('start','asncdc');
----
+
or from the shell:
+
[source,shell]
----
db2 "VALUES ASNCDC.ASNCDCSERVICES('start','asncdc');"
----
+

The preceding statement returns one of the following results:
+
* `asncap is already running`
* `+start -->+` `_<COMMAND>_`
+
In this case, enter the specified `_<COMMAND>_` in the terminal window as shown in the following example:
+
[source,shell]
----
/database/config/db2inst1/sqllib/bin/asncap capture_schema=asncdc capture_server=SAMPLE &
----

. Put tables into capture mode. Invoke the following statement for each table that you want to put into capture. Replace `MYSCHEMA`  with the name of the schema that contains the table you want to put into capture mode. Likewise, replace `MYTABLE` with the name of the table to put into capture mode:
+
[source,sql]
----
CALL ASNCDC.ADDTABLE('MYSCHEMA', 'MYTABLE');
----

. Reinitialize the ASN service:
+
[source,sql]
----
VALUES ASNCDC.ASNCDCSERVICES('reinit','asncdc');
----

.Additional resource

xref:db2-management[Reference table for {prodname} Db2 management UDFs]

// Type: concept
// ModuleID: effect-of-db2-capture-agent-configuration-on-server-load-and-latency
=== Effect of Db2 capture agent configuration on server load and latency

When a database administrator enables change data capture for a source table, the capture agent begins to run.
The agent reads new change event records from the transaction log and replicates the event records to a capture table.
Between the time that a change is committed in the source table, and the time that the change appears in the corresponding change table, there is always a small latency interval.
This latency interval represents a gap between when changes occur in the source table and when they become available for {prodname} to stream to Apache Kafka.

Ideally, for applications that must respond quickly to changes in data, you want to maintain close synchronization between the source and capture tables.
You might imagine that running the capture agent to continuously process change events as rapidly as possible might result in increased throughput and reduced latency --
populating change tables with new event records as soon as possible after the events occur, in near real time.
However, this is not necessarily the case.
There is a performance penalty to pay in the pursuit of more immediate synchronization.
Each time that the change agent queries the database for new event records, it increases the CPU load on the database host.
The additional load on the server can have a negative effect on overall database performance, and potentially reduce transaction efficiency, especially during times of peak database use.

It's important to monitor database metrics so that you know if the database reaches the point where the server can no longer support the capture agent's level of activity.
If you experience performance issues while running the capture agent, adjust capture agent settings to reduce CPU load.

// Type: reference
// ModuleID: db2-capture-agent-configuration-parameters
=== Db2 capture agent configuration parameters

On Db2, the `IBMSNAP_CAPPARMS` table contains parameters that control the behavior of the capture agent.
You can adjust the values for these parameters to balance the configuration of the capture process to reduce CPU load and still maintain acceptable levels of latency.

[NOTE]
====
Specific guidance about how to configure Db2 capture agent parameters is beyond the scope of this documentation.
====

In the `IBMSNAP_CAPPARMS` table, the following parameters have the greatest effect on reducing CPU load:

`COMMIT_INTERVAL`::
* Specifies the number of seconds that the capture agent waits to commit data to the change data tables.
* A higher value reduces the load on the database host and increases latency.
* The default value is `30`.

`SLEEP_INTERVAL`::
* Specifies the number of seconds that the capture agent waits to start a new commit cycle after it reaches the end of the active transaction log.
* A higher value reduces the load on the server, and increases latency.
* The default value is `5`.

.Additional resources
* For more information about capture agent parameters, see the Db2 documentation.

// Type: assembly
// ModuleID: deployment-of-debezium-db2-connectors
// Title: Deployment of {prodname} Db2 connectors
[[db2-deploying-a-connector]]
== Deployment

To deploy a {prodname} Db2 connector, you install the {prodname} Db2 connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect.

.Prerequisites

* link:https://zookeeper.apache.org/[Apache ZooKeeper], link:http://kafka.apache.org/[Apache Kafka], and link:{link-kafka-docs}.html#connect[Kafka Connect] are installed.
* Db2 is installed and xref:setting-up-db2[capture mode is enabled for tables] to prepare the database to be used with the {prodname} connector.

.Procedure

. Download the link:https://repo1.maven.org/maven2/io/debezium/debezium-connector-db2/{debezium-version}/debezium-connector-db2-{debezium-version}-plugin.tar.gz[{prodname} Db2 connector plug-in archive] from Maven Central.
. Extract the JAR files into your Kafka Connect environment.
. Download the link:https://repo1.maven.org/maven2/com/ibm/db2/jcc/{db2-version}/jcc-{db2-version}.jar[JDBC driver for Db2] from Maven Central, and extract the downloaded driver file to the directory that contains the {prodname} Db2 connector JAR file (that is, `debezium-connector-db2-{debezium-version}.jar`).
+
[IMPORTANT]
====
Due to licensing requirements, the {prodname} Db2 connector archive does not include the Db2 JDBC driver that {prodname} requires to connect to a Db2 database.
To enable the connector to access the database, you must add the driver to your connector environment.
====
. Add the directory with the JAR files to {link-kafka-docs}/#connectconfigs[Kafka Connect's `plugin.path`].
. Restart your Kafka Connect process to pick up the new JAR files.

If you are working with immutable containers, see link:https://quay.io/organization/debezium[{prodname}'s container images] for Apache ZooKeeper, Apache Kafka and Kafka Connect with the Db2 connector already installed and ready to run.

You can also xref:operations/openshift.adoc[run {prodname} on Kubernetes and OpenShift].

.Next steps

* xref:db2-example-configuration[Configure the connector] and xref:db2-adding-connector-configuration[add the configuration to your Kafka Connect cluster.]


[[db2-example-configuration]]
=== Db2 connector configuration example

Following is an example of the configuration for a connector instance that captures data from a Db2 server on port 50000 at 192.168.99.100, which we logically name `fullfillment`.
Typically, you configure the {prodname} Db2 connector in a JSON file by setting the configuration properties that are available for the connector.

You can choose to produce events for a subset of the schemas and tables in a database.
Optionally, you can ignore, mask, or truncate columns that contain sensitive data, that are larger than a specified size, or that you do not need.

[source,json]
----
{
  "name": "db2-connector",  // <1>
  "config": {
    "connector.class": "io.debezium.connector.db2.Db2Connector", // <2>
    "database.hostname": "192.168.99.100", // <3>
    "database.port": "50000", // <4>
    "database.user": "db2inst1", // <5>
    "database.password": "Password!", // <6>
    "database.dbname": "mydatabase", // <7>
    "topic.prefix": "fullfillment", // <8>
    "table.include.list": "MYSCHEMA.CUSTOMERS", // <9>
    "schema.history.internal.kafka.bootstrap.servers": "kafka:9092", // <10>
    "schema.history.internal.kafka.topic": "schemahistory.fullfillment" // <11>
  }
}
----
<1> The name of the connector when registered with a Kafka Connect service.
<2> The name of this Db2 connector class.
<3> The address of the Db2 instance.
<4> The port number of the Db2 instance.
<5> The name of the Db2 user.
<6> The password for the Db2 user.
<7> The name of the database to capture changes from.
<8> The logical name of the Db2 instance/cluster, which forms a namespace and is used in all the names of the Kafka topics to which the connector writes, the Kafka Connect schema names, and the namespaces of the corresponding Avro schema when the {link-prefix}:{link-avro-serialization}[Avro Connector] is used.
<9> A list of all tables whose changes {prodname} should capture.
<10> The list of Kafka brokers that this connector uses to write and recover DDL statements to the database schema history topic.
<11> The name of the database schema history topic where the connector writes and recovers DDL statements. This topic is for internal use only and should not be used by consumers.


For the complete list of the configuration properties that you can set for the {prodname} Db2 connector, see xref:db2-connector-properties[Db2 connector properties].


You can send this configuration with a `POST` command to a running Kafka Connect service.
The service records the configuration and starts one connector task that performs the following actions:

* Connects to the Db2 database.
* Reads change-data tables for tables that are in capture mode.
* Streams change event records to Kafka topics.

[[db2-adding-connector-configuration]]
=== Adding connector configuration

To start running a Db2 connector, create a connector configuration and add the configuration to your Kafka Connect cluster.

.Prerequisites

* xref:setting-up-db2[Db2 replication is enabled] to expose change data for tables that are in capture mode.
* The Db2 connector is installed.

.Procedure

. Create a configuration for the Db2 connector.

. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster.

.Results

After the connector starts, it xref:db2-snapshots[performs a consistent snapshot] of the Db2 database tables that the connector is configured to capture changes for.
The connector then starts generating data change events for row-level operations and streaming change event records to Kafka topics.


// Type: reference
// Title: Descriptions of {prodname} Db2 connector configuration properties
// ModuleID: descriptions-of-debezium-db2-connector-configuration-properties
[[db2-connector-properties]]
=== Connector properties

The {prodname} Db2 connector has numerous configuration properties that you can use to achieve the right connector behavior for your application.
Many properties have default values.
Information about the properties is organized as follows:

* xref:db2-required-configuration-properties[Required configuration properties]
* xref:db2-advanced-configuration-properties[Advanced configuration properties]
* xref:debezium-db2-connector-database-history-configuration-properties[Database schema history connector configuration properties] that control how {prodname} processes events that it reads from the database schema history topic.
** xref:debezium-db2-connector-pass-through-database-driver-configuration-properties[Pass-through database schema history properties]
* xref:debezium-db2-connector-pass-through-database-driver-configuration-properties[Pass-through database driver properties] that control the behavior of the database driver.


[id="db2-required-configuration-properties"]
==== Required {prodname} Db2 connector configuration properties

The following configuration properties are _required_ unless a default value is available.

[cols="30%a,25%a,45%a",options="header"]
|===
|Property |Default |Description

|[[db2-property-name]]<<db2-property-name, `+name+`>>
|No default
|Unique name for the connector. Attempting to register again with the same name will fail. This property is required by all Kafka Connect connectors.

|[[db2-property-connector-class]]<<db2-property-connector-class, `+connector.class+`>>
|No default
|The name of the Java class for the connector. Always use a value of `io.debezium.connector.db2.Db2Connector` for the Db2 connector.

|[[db2-property-tasks-max]]<<db2-property-tasks-max, `+tasks.max+`>>
|`1`
|The maximum number of tasks that should be created for this connector. The Db2 connector always uses a single task and therefore does not use this value, so the default is always acceptable.

|[[db2-property-database-hostname]]<<db2-property-database-hostname, `+database.hostname+`>>
|No default
|IP address or hostname of the Db2 database server.

|[[db2-property-database-port]]<<db2-property-database-port, `+database.port+`>>
|`50000`
|Integer port number of the Db2 database server.

|[[db2-property-database-user]]<<db2-property-database-user, `+database.user+`>>
|No default
|Name of the Db2 database user for connecting to the Db2 database server.

|[[db2-property-database-password]]<<db2-property-database-password, `+database.password+`>>
|No default
|Password to use when connecting to the Db2 database server.

|[[db2-property-database-dbname]]<<db2-property-database-dbname, `+database.dbname+`>>
|No default
|The name of the Db2 database from which to stream the changes

|[[db2-property-db2-platform]]<<db2-property-db2-platform, `+db2.platform+`>>
|`LUW`
|The Db2 server platform.
You can specify one of the following options:
[horizontal]
 `LUW`:: Db2 for Linux, UNIX, and Windows
 `ZOS`:: Db2 for z/OS. Support for using {prodname} with z/OS is incubating.

[NOTE]
====
If you use {prodname} with Db2 for z/OS, it might also be necessary to configure the xref:db2-property-cdc-control-schema[`cdc.control.schema`] and xref:db2-property-cdc-change-tables-schema[`cdc.change.tables.schema`] configuration options.
====

|[[db2-property-topic-prefix]]<<db2-property-topic-prefix, `+topic.prefix+`>>
|No default
|Topic prefix which provides a namespace for the particular Db2 database server that hosts the database for which {prodname} is capturing changes.
Only alphanumeric characters, hyphens, dots and underscores must be used in the topic prefix name.
The topic prefix should be unique across all other connectors, since this topic prefix is used for all Kafka topics that receive records from this connector. +
 +
[WARNING]
====
Do not change the value of this property.
If you change the name value, after a restart, instead of continuing to emit events to the original topics, the connector emits subsequent events to topics whose names are based on the new value.
The connector is also unable to recover its database schema history topic.
====

|[[db2-property-table-include-list]]<<db2-property-table-include-list, `+table.include.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers for tables whose changes you want the connector to capture.
When this property is set, the connector captures changes only from the specified tables.
Each identifier is of the form _schemaName_._tableName_. By default, the connector captures changes in every non-system table. +

To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table it does not match substrings that might be present in a table name. +
If you include this property in the configuration, do not also set the `table.exclude.list` property.

|[[db2-property-table-exclude-list]]<<db2-property-table-exclude-list, `+table.exclude.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers for tables whose changes you do not want the connector to capture.
The connector captures changes in each non-system table that is not included in the exclude list.
Each identifier is of the form _schemaName_._tableName_. +

To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table it does not match substrings that might be present in a table name. +
If you include this property in the configuration, do not also set the `table.include.list` property.

|[[db2-property-column-include-list]]<<db2-property-column-include-list, `+column.include.list+`>>
|_empty string_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to include in change event record values.
Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_. +

To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; it does not match substrings that might be present in a column name.
If you include this property in the configuration, do not also set the `column.exclude.list` property.

|[[db2-property-column-exclude-list]]<<db2-property-column-exclude-list, `+column.exclude.list+`>>
|_empty string_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to exclude from change event values.
Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_. +

To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; it does not match substrings that might be present in a column name.
Primary key columns are always included in the event's key, even if they are excluded from the value.
If you include this property in the configuration, do not set the `column.include.list` property.

|[[db2-property-column-mask-hash]]<<db2-property-column-mask-hash, `column.mask.hash._hashAlgorithm_.with.salt._salt_`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Fully-qualified names for columns are of the form _schemaName_._tableName_._columnName_. +
To match the name of a column {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.
In the resulting change event record, the values for the specified columns are replaced with pseudonyms.

A pseudonym consists of the hashed value that results from applying the specified _hashAlgorithm_ and _salt_.
Based on the hash function that is used, referential integrity is maintained, while column values are replaced with pseudonyms.
Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation. +
 +
In the following example, `CzQMA0cB5K` is a randomly selected salt. +

----
column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName
----

If necessary, the pseudonym is automatically shortened to the length of the column.
The connector configuration can include multiple properties that specify different hash algorithms and salts. +
 +
Depending on the _hashAlgorithm_ used, the _salt_ selected, and the actual data set, the resulting data set might not be completely masked.

|[[db2-property-time-precision-mode]]<<db2-property-time-precision-mode, `+time.precision.mode+`>>
|`adaptive`
| Time, date, and timestamps can be represented with different kinds of precision: +
 +
`adaptive` captures the time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type. +
 +
`connect` always represents time and timestamp values by using Kafka Connect's built-in representations for `Time`, `Date`, and `Timestamp`, which uses millisecond precision regardless of the database columns' precision.
For more information, see xref:db2-temporal-types[temporal types].

|[[db2-property-tombstones-on-delete]]<<db2-property-tombstones-on-delete, `+tombstones.on.delete+`>>
|`true`
|Controls whether a _delete_ event is followed by a tombstone event. +
 +
`true` - a delete operation is represented by a _delete_ event and a subsequent tombstone event.  +
 +
`false` - only a _delete_ event is emitted. +
 +
After a source record is deleted, emitting a tombstone event (the default behavior) allows Kafka to completely delete all events that pertain to the key of the deleted row in case {link-kafka-docs}/#compaction[log compaction] is enabled for the topic.

|[[db2-property-include-schema-changes]]<<db2-property-include-schema-changes, `+include.schema.changes+`>>
|`true`
|Boolean value that specifies whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change is recorded with a key that contains the database name and a value that is a JSON structure that describes the schema update. This is independent of how the connector internally records database schema history.

|[[db2-property-column-truncate-to-length-chars]]<<db2-property-column-truncate-to-length-chars, `column.truncate.to._length_.chars`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want to truncate the data in a set of columns when it exceeds the number of characters specified by the _length_ in the property name.
Set `length` to a positive integer value, for example, `column.truncate.to.20.chars`.

The fully-qualified name of a column observes the following format: _schemaName_._tableName_._columnName_.
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.

You can specify multiple properties with different lengths in a single configuration.

|[[db2-property-column-mask-with-length-chars]]<<db2-property-column-mask-with-length-chars, `column.mask.with._length_.chars`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want the connector to mask the values for a set of columns, for example, if they contain sensitive data.
Set `_length_` to a positive integer to replace data in the specified columns with the number of asterisk (`*`) characters specified by the _length_ in the property name.
Set _length_ to `0` (zero) to replace data in the specified columns with an empty string.

The fully-qualified name of a column observes the following format: _schemaName_._tableName_._columnName_. +
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.

You can specify multiple properties with different lengths in a single configuration.

|[[db2-property-column-propagate-source-type]]<<db2-property-column-propagate-source-type, `+column.propagate.source.type+`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns for which you want the connector to emit extra parameters that represent column metadata.
When this property is set, the connector adds the following fields to the schema of event records:

* `pass:[_]pass:[_]debezium.source.column.type` +
* `pass:[_]pass:[_]debezium.source.column.length` +
* `pass:[_]pass:[_]debezium.source.column.scale` +

These parameters propagate a column's original type name and length (for variable-width types), respectively. +
Enabling the connector to emit this extra data can assist in properly sizing specific numeric or character-based columns in sink databases.

The fully-qualified name of a column observes one of the following formats: _databaseName_._tableName_._columnName_, or _databaseName_._schemaName_._tableName_._columnName_. +
To match the name of a column, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.

|[[db2-property-datatype-propagate-source-type]]<<db2-property-datatype-propagate-source-type, `+datatype.propagate.source.type+`>>
|_n/a_
|An optional, comma-separated list of regular expressions that specify the fully-qualified names of data types that are defined for columns in a database.
When this property is set, for columns with matching data types, the connector emits event records that include the following extra fields in their schema:

* `pass:[_]pass:[_]debezium.source.column.type` +
* `pass:[_]pass:[_]debezium.source.column.length` +
* `pass:[_]pass:[_]debezium.source.column.scale` +

These parameters propagate a column's original type name and length (for variable-width types), respectively. +
Enabling the connector to emit this extra data can assist in properly sizing specific numeric or character-based columns in sink databases.

The fully-qualified name of a column observes one of the following formats: _databaseName_._tableName_._typeName_, or _databaseName_._schemaName_._tableName_._typeName_. +
To match the name of a data type, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the data type; the expression does not match substrings that might be present in a type name.

For the list of Db2-specific data type names, see the xref:db2-data-types[Db2 data type mappings] .

|[[db2-property-message-key-columns]]<<db2-property-message-key-columns, `+message.key.columns+`>>
|_empty string_
|A list of expressions that specify the columns that the connector uses to form custom message keys for change event records that it publishes to the Kafka topics for specified tables.

By default, {prodname} uses the primary key column of a table as the message key for records that it emits.
In place of the default, or to specify a key for tables that lack a primary key, you can configure custom message keys based on one or more columns. +
 +
To establish a custom message key for a table, list the table, followed by the columns to use as the message key.
Each list entry takes the following format: +
 +
`_<fully-qualified_tableName>_:__<keyColumn>__,_<keyColumn>_` +
 +
To base a table key on multiple column names, insert commas between the column names. +
Each fully-qualified table name is a regular expression in the following format: +

`_<schemaName>_._<tableName>_` +

The property can list entries for multiple tables.
Use a semicolon to separate entries for different tables in the list. +
 +
The following example sets the message key for the tables `inventory.customers` and `purchaseorders`: +
 +
`inventory.customers:pk1,pk2;(.*).purchaseorders:pk3,pk4` +
 +
In the preceding example, the columns `pk1` and `pk2` are specified as the message key for the table `inventory.customer`.
For `purchaseorders` tables in any schema, the columns `pk3` and `pk4` serve as the message key.

|[[db2-property-schema-name-adjustment-mode]]<<db2-property-schema-name-adjustment-mode,`+schema.name.adjustment.mode+`>>
|none
|Specifies how schema names should be adjusted for compatibility with the message converter used by the connector. Possible settings:  +

* `none` does not apply any adjustment. +
* `avro` replaces the characters that cannot be used in the Avro type name with underscore. +
* `avro_unicode` replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java +

|[[db2-property-field-name-adjustment-mode]]<<db2-property-field-name-adjustment-mode,`+field.name.adjustment.mode+`>>
|none
|Specifies how field names should be adjusted for compatibility with the message converter used by the connector. Possible settings:  +

* `none` does not apply any adjustment. +
* `avro` replaces the characters that cannot be used in the Avro type name with underscore. +
* `avro_unicode` replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java +

See {link-prefix}:{link-avro-serialization}#avro-naming[Avro naming] for more details.
|===

// Title: Advanced {prodname} Db2 connector configuration properties
[id="db2-advanced-configuration-properties"]
==== Advanced connector configuration properties

The following _advanced_ configuration properties have defaults that work in most situations and therefore rarely need to be specified in the connector's configuration.

[cols="30%a,25%a,45%a",options="header"]
|===
|Property |Default |Description

|[[db2-property-converters]]<<db2-property-converters, `converters`>>
|No default
|Enumerates a comma-separated list of the symbolic names of the {link-prefix}:{link-custom-converters}#custom-converters[custom converter] instances that the connector can use.
For example, +

`isbn`

You must set the `converters` property to enable the connector to use a custom converter.

For each converter that you configure for a connector, you must also add a `.type` property, which specifies the fully-qualified name of the class that implements the converter interface.
The `.type` property uses the following format: +

`_<converterSymbolicName>_.type` +

For example, +

 isbn.type: io.debezium.test.IsbnConverter

If you want to further control the behavior of a configured converter, you can add one or more configuration parameters to pass values to the converter.
To associate any additional configuration parameter with a converter, prefix the parameter names with the symbolic name of the converter. +
For example, +

 isbn.schema.name: io.debezium.db2.type.Isbn

|[[db2-property-snapshot-mode]]<<db2-property-snapshot-mode, `+snapshot.mode+`>>
|_initial_
|Specifies the criteria for performing a snapshot when the connector starts: +

`always`:: The connector performs a snapshot every time that it starts.
The snapshot includes the structure and data of the captured tables.
Specify this value to populate topics with a complete representation of the data from the captured tables every time that the connector starts.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

`initial`:: The connector performs a database snapshot as described in the xref:db2-default-workflow-for-performing-an-initial-snapshot[default workflow for creating an initial snapshot].
After the snapshot completes, the connector begins to stream event records for subsequent database changes.

`initial_only`:: The connector performs a database a snapshot only when no offsets have been recorded for the logical server name.
After the snapshot completes, the connector stops.
It does not transition to streaming event records for subsequent database changes.

`schema_only`:: Deprecated, see `no_data`.

`no_data`:: The connector runs a snapshot that captures the structure of all relevant tables, performing all the steps described in the xref:db2-default-workflow-for-performing-an-initial-snapshot[default snapshot workflow], except that it does not create `READ` events to represent the data set at the point of the connector's start-up (Step 7.b).

`recovery`:: Set this option to restore a database schema history topic that is lost or corrupted.
After a restart, the connector runs a snapshot that rebuilds the topic from the source tables.
You can also set the property to periodically prune a database schema history topic that experiences unexpected growth. +
+
WARNING: Do not use this mode to perform a snapshot if schema changes were committed to the database after the last connector shutdown.

`when_needed`:: After the connector starts, it performs a snapshot only if it detects one of the following circumstances:

* It cannot detect any topic offsets.
* A previously recorded offset specifies a log position that is not available on the server.

`configuration_based`:: With this option, you control snapshot behavior through a set of connector properties that have the prefix 'snapshot.mode.configuration.based'.


`custom`:: The `custom` snapshot mode lets you inject your own implementation of the `io.debezium.spi.snapshot.Snapshotter` interface.
Set the `snapshot.mode.custom.name` configuration property to the name provided by the `name()` method of your implementation.

For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[db2-property-snapshot-mode-configuration-based-snapshot-data]]<<db2-property-configuration-based-snapshot-data, `+snapshot.mode.configuration.based.snapshot.data+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table data when it performs a snapshot.

|[[db2-property-snapshot-mode-configuration-based-snapshot-schema]]<<db2-property-configuration-based-snapshot-schema, `+snapshot.mode.configuration.based.snapshot.schema+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes the table schema when it performs a snapshot.

|[[db2-property-snapshot-mode-configuration-based-start-stream]]<<db2-property-configuration-based-start-stream, `+snapshot.mode.configuration.based.start.stream+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector begins to stream change events after a snapshot completes.

|[[db2-property-snapshot-mode-configuration-based-snapshot-on-schema-error]]<<db2-property-configuration-based-snapshot-on-schema-error, `+snapshot.mode.configuration.based.snapshot.on.schema.error+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, set this property to specify whether the connector includes table schema in a snapshot if the schema history topic is not available.

|[[db2-property-snapshot-mode-configuration-based-snapshot-on-data-error]]<<db2-property-configuration-based-snapshot-on-data-error, `+snapshot.mode.configuration.based.snapshot.on.data.error+`>>
|false
|If the `snapshot.mode` is set to `configuration_based`, this property specifies whether the connector attempts to snapshot table data if it does not find the last committed offset in the transaction log. +
Set the value to `true` to instruct the connector to perform a new snapshot.

|[[db2-property-snapshot-mode-custom-name]]<<db2-property-snapshot-mode-custom-name, `+snapshot.mode.custom.name+`>>
|No default
| If `snapshot.mode` is set to `custom`, use this setting to specify the name of the custom implementation that is provided in the `name()` method that is defined in the 'io.debezium.spi.snapshot.Snapshotter' interface.
After a connector restart, {prodname} calls the specified custom implementation to determine whether to perform a snapshot.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[db2-property-snapshot-locking-mode]]<<db2-property-snapshot-locking-mode, `+snapshot.locking.mode+`>>
|_exclusive_
a|Controls whether and for how long the connector holds a table lock.
Table locks prevent other database clients from performing certain table operations during a snapshot.
You can set the following values:

`exclusive`:: Controls how the connector holds locks on tables while performing the schema snapshot when `snapshot.isolation.mode` is `REPEATABLE_READ` or `EXCLUSIVE`. +
The connector holds a table lock that ensures exclusive table access during only the initial phase of the snapshot in which the connector reads the database schema and other metadata.
In subsequent phases of the snapshot, the connector uses a flashback query, which requires no locks, to select all rows from each table.
If you prefer snapshots to run without setting any locks, set the following option, `none`.

`none`:: Prevents the connector from acquiring any table locks during the snapshot.
Use this setting only if no schema changes might occur during the creation of the snapshot.

`custom`:: The connector performs a snapshot according to the implementation specified by the xref:db2-property-snapshot-locking-mode-custom-name[`snapshot.locking.mode.custom.name`] property, which is a custom implementation of the `io.debezium.spi.snapshot.SnapshotLock` interface.

|[[db2-property-snapshot-locking-mode-custom-name]]<<db2-property-snapshot-locking-mode-custom-name, `+snapshot.locking.mode.custom.name+`>>
|No default
| When `snapshot.locking.mode` is set to `custom`, use this setting to specify the name of the custom locking implementation provided in the `name()` method that is defined by the 'io.debezium.spi.snapshot.SnapshotLock' interface.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[db2-property-snapshot-query-mode]]<<db2-property-snapshot-query-mode, `+snapshot.query.mode+`>>
|`select_all`
|Specifies how the connector queries data while performing a snapshot. +
Set one of the following options:

`select_all`:: The connector performs a `select all` query by default, optionally adjusting the columns selected based on the column include and exclude list configurations.

`custom`:: The connector performs a snapshot query according to the implementation specified by the xref:db2-property-snapshot-snapshot-query-mode-custom-name[`snapshot.query.mode.custom.name`] property, which defines a custom implementation of the `io.debezium.spi.snapshot.SnapshotQuery` interface. +

This setting enables you to manage snapshot content in a more flexible manner compared to using the xref:db2-property-snapshot-select-statement-overrides[`snapshot.select.statement.overrides`] property.

|[[db2-property-snapshot-snapshot-query-mode-custom-name]]<<db2-property-snapshot-query-mode-custom-name, `+snapshot.query.mode.custom.name+`>>
|No default
| When xref:db2-property-snapshot-query-mode[`snapshot.query.mode`] is set to `custom`, use this setting to specify the name of the custom query implementation provided in the `name()` method that is defined by the 'io.debezium.spi.snapshot.SnapshotQuery' interface.
For more information, see xref:connector-custom-snapshot[custom snapshotter SPI].

|[[db2-property-snapshot-isolation-mode]]<<db2-property-snapshot-isolation-mode, `+snapshot.isolation.mode+`>>
|`repeatable_read`
|During a snapshot, controls the transaction isolation level and how long the connector locks the tables that are in capture mode. The possible values are: +
 +
`read_uncommitted` - Does not prevent other transactions from updating table rows during an initial snapshot. This mode has no data consistency guarantees; some data might be lost or corrupted. +
 +
`read_committed` - Does not prevent other transactions from updating table rows during an initial snapshot. It is possible for a new record to appear twice: once in the initial snapshot and once in the streaming phase. However, this consistency level is appropriate for data mirroring. +
 +
`repeatable_read` - Prevents other transactions from updating table rows during an initial snapshot. It is possible for a new record to appear twice: once in the initial snapshot and once in the streaming phase. However, this consistency level is appropriate for data mirroring. +
 +
`exclusive` - Uses repeatable read isolation level but takes an  exclusive lock for all tables to be read. This mode prevents other transactions from updating table rows during an initial snapshot. Only `exclusive` mode guarantees full consistency; the initial snapshot and streaming logs constitute a linear history.

|[[db2-property-event-processing-failure-handling-mode]]<<db2-property-event-processing-failure-handling-mode, `+event.processing.failure.handling.mode+`>>
|`fail`
|Specifies how the connector handles exceptions during processing of events. The possible values are: +
 +
`fail` - The connector logs the offset of the problematic event and stops processing. +
 +
`warn` - The connector logs the offset of the problematic event and continues processing with the next event. +
 +
`skip` - The connector skips the problematic event and continues processing with the next event.

|[[db2-property-poll-interval-ms]]<<db2-property-poll-interval-ms, `+poll.interval.ms+`>>
|`500`
|Positive integer value that specifies the number of milliseconds the connector should wait for new change events to appear before it starts processing a batch of events. Defaults to 500 milliseconds, or 0.5 second.

|[[db2-property-max-batch-size]]<<db2-property-max-batch-size, `+max.batch.size+`>>
|`2048`
|Positive integer value that specifies the maximum size of each batch of events that the connector processes.

|[[db2-property-max-queue-size]]<<db2-property-max-queue-size, `+max.queue.size+`>>
|`8192`
|Positive integer value that specifies the maximum number of records that the blocking queue can hold.
When {prodname} reads events streamed from the database, it places the events in the blocking queue before it writes them to Kafka.
The blocking queue can provide backpressure for reading change events from the database
in cases where the connector ingests messages faster than it can write them to Kafka, or when Kafka becomes unavailable.
Events that are held in the queue are disregarded when the connector periodically records offsets.
Always set the value of `max.queue.size` to be larger than the value of xref:{context}-property-max-batch-size[`max.batch.size`].

|[[db2-property-max-queue-size-in-bytes]]<<db2-property-max-queue-size-in-bytes, `+max.queue.size.in.bytes+`>>
|`0`
|A long integer value that specifies the maximum volume of the blocking queue in bytes.
By default, volume limits are not specified for the blocking queue.
To specify the number of bytes that the queue can consume, set this property to a positive long value. +
If xref:db2-property-max-queue-size[`max.queue.size`] is also set, writing to the queue is blocked when the size of the queue reaches the limit specified by either property.
For example, if you set `max.queue.size=1000`, and `max.queue.size.in.bytes=5000`, writing to the queue is blocked after the queue contains 1000 records, or after the volume of the records in the queue reaches 5000 bytes.

|[[db2-property-heartbeat-interval-ms]]<<db2-property-heartbeat-interval-ms, `+heartbeat.interval.ms+`>>
|`0`
|Controls how frequently the connector sends heartbeat messages to a Kafka topic. The default behavior is that the connector does not send heartbeat messages. +
 +
Heartbeat messages are useful for monitoring whether the connector is receiving change events from the database. Heartbeat messages might help decrease the number of change events that need to be re-sent when a connector restarts. To send heartbeat messages, set this property to a positive integer, which indicates the number of milliseconds between heartbeat messages. +
 +
Heartbeat messages are useful when there are many updates in a database that is being tracked but only a tiny number of updates are in tables that are in capture mode. In this situation, the connector reads from the database transaction log as usual but rarely emits change records to Kafka. This means that the connector has few opportunities to send the latest offset to Kafka. Sending heartbeat messages enables the connector to send the latest offset to Kafka.

|[[db2-property-snapshot-delay-ms]]<<db2-property-snapshot-delay-ms, `+snapshot.delay.ms+`>>
|No default
|An interval in milliseconds that the connector should wait before performing a snapshot when the connector starts. If you are starting multiple connectors in a cluster, this property is useful for avoiding snapshot interruptions, which might cause re-balancing of connectors.

|[[db2-property-streaming-delay-ms]]<<db2-property-streaming-delay-ms, `+streaming.delay.ms+`>>
|0
|Specifies the time, in milliseconds, that the connector delays the start of the streaming process after it completes a snapshot.
Setting a delay interval helps to prevent the connector from restarting snapshots in the event that a failure occurs immediately after the snapshot completes, but before the streaming process begins.
Set a delay value that is higher than the value of the {link-kafka-docs}/#connectconfigs_offset.flush.interval.ms[`offset.flush.interval.ms`] property that is set for the Kafka Connect worker.

|[[db2-property-snapshot-include-collection-list]]<<db2-property-snapshot-include-collection-list, `+snapshot.include.collection.list+`>>
| All tables specified in `table.include.list`
|An optional, comma-separated list of regular expressions that match the fully-qualified names (`_<schemaName>.<tableName>_`) of the tables to include in a snapshot.
The specified items must be named in the connector's xref:db2-property-table-include-list[`table.include.list`] property.
This property takes effect only if the connector's xref:db2-property-snapshot-mode[`snapshot.mode`] property is set to a value other than `never`. +
This property does not affect the behavior of incremental snapshots. +

To match the name of a table, {prodname} applies the regular expression that you specify as an _anchored_ regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name.

|[[db2-property-snapshot-fetch-size]]<<db2-property-snapshot-fetch-size, `+snapshot.fetch.size+`>>
|`2000`
|During a snapshot, the connector reads table content in batches of rows. This property specifies the maximum number of rows in a batch.

|[[db2-property-snapshot-lock-timeout-ms]]<<db2-property-snapshot-lock-timeout-ms, `+snapshot.lock.timeout.ms+`>>
|`10000`
|Positive integer value that specifies the maximum amount of time (in milliseconds) to wait to obtain table locks when performing a snapshot. If the connector cannot acquire table locks in this interval, the snapshot fails. xref:db2-snapshots[How the connector performs snapshots] provides details. Other possible settings are: +
 +
`0` -  The connector immediately fails when it cannot obtain a lock. +
 +
`-1` - The connector waits infinitely.

|[[db2-property-snapshot-select-statement-overrides]]<<db2-property-snapshot-select-statement-overrides, `+snapshot.select.statement.overrides+`>>
|No default
|Specifies the table rows to include in a snapshot.
Use the property if you want a snapshot to include only a subset of the rows in a table.
This property affects snapshots only.
It does not apply to events that the connector reads from the log.

The property contains a comma-separated list of fully-qualified table names in the form `_<schemaName>.<tableName>_`. For example, +
 +
`+"snapshot.select.statement.overrides": "inventory.products,customers.orders"+` +
 +
For each table in the list, add a further configuration property that specifies the `SELECT` statement for the connector to run on the table when it takes a snapshot.
The specified `SELECT` statement determines the subset of table rows to include in the snapshot.
Use the following format to specify the name of this `SELECT` statement property: +
 +
`snapshot.select.statement.overrides._<schemaName>_._<tableName>_`.
For example,
`snapshot.select.statement.overrides.customers.orders`. +
 +
Example:

From a `customers.orders` table that includes the soft-delete column, `delete_flag`, add the following properties if you want a snapshot to include only those records that are not soft-deleted:

----
"snapshot.select.statement.overrides": "customer.orders",
"snapshot.select.statement.overrides.customer.orders": "SELECT * FROM [customers].[orders] WHERE delete_flag = 0 ORDER BY id DESC"
----

In the resulting snapshot, the connector includes only the records for which `delete_flag = 0`.

|[[db2-property-provide-transaction-metadata]]<<db2-property-provide-transaction-metadata, `+provide.transaction.metadata+`>>
|`false`
|Determines whether the connector generates events with transaction boundaries and enriches change event envelopes with transaction metadata. Specify `true` if you want the connector to do this. See xref:db2-transaction-metadata[Transaction metadata] for details.

|[[db2-property-skipped-operations]]<<db2-property-skipped-operations, `+skipped.operations+`>>
|`t`
|A comma-separated list of operation types that will be skipped during streaming.
The operations include: `c` for inserts/create, `u` for updates, `d` for deletes, `t` for truncates, and `none` to not skip any operations.
By default, truncate operations are skipped (not emitted by this connector).

|[[db2-property-signal-data-collection]]<<db2-property-signal-data-collection, `+signal.data.collection+`>>
|No default
| Fully-qualified name of the data collection that is used to send {link-prefix}:{link-signalling}#debezium-signaling-enabling-source-signaling-channel[signals] to the connector.
Use the following format to specify the collection name: +
`_<schemaName>_._<tableName>_`

|[[db2-property-signal-enabled-channels]]<<db2-property-signal-enabled-channels, `+signal.enabled.channels+`>>
|source
| List of the signaling channel names that are enabled for the connector.
By default, the following channels are available:

* `source`
* `kafka`
* `file`
* `jmx`
Optionally, you can also implement a {link-prefix}:{link-signalling}#debezium-signaling-enabling-custom-signaling-channel[custom signaling channel].
|[[db2-property-notification-enabled-channels]]<<db2-property-notification-enabled-channels, `+notification.enabled.channels+`>>
|No default
| List of the notification channel names that are enabled for the connector.
By default, the following channels are available:

* `sink`
* `log`
* `jmx`
Optionally, you can also implement a {link-prefix}:{link-notification}#debezium-notification-custom-channel[custom notification channel].
|[[db2-property-incremental-snapshot-chunk-size]]<<db2-property-incremental-snapshot-chunk-size, `+incremental.snapshot.chunk.size+`>>
|`1024`
|The maximum number of rows that the connector fetches and reads into memory during an incremental snapshot chunk.
Increasing the chunk size provides greater efficiency, because the snapshot runs fewer snapshot queries of a greater size.
However, larger chunk sizes also require more memory to buffer the snapshot data.
Adjust the chunk size to a value that provides the best performance in your environment.

|[[db2-property-incremental-snapshot-watermarking-strategy]]<<db2-property-incremental-snapshot-watermarking-strategy, `+incremental.snapshot.watermarking.strategy+`>>
|`insert_insert`
|Specifies the watermarking mechanism that the connector uses during an incremental snapshot to deduplicate events that might be captured by an incremental snapshot and then recaptured after streaming resumes. +
You can specify one of the following options:

`insert_insert`:: When you send a signal to initiate an incremental snapshot, for every chunk that {prodname} reads during the snapshot, it writes an entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, {prodname} inserts a second entry that records the signal to close the window.
`insert_delete`:: When you send a signal to initiate an incremental snapshot, for every chunk that {prodname} reads, it writes a single entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, this entry is removed.
No entry is created for the signal to close the snapshot window.
Set this option to prevent rapid growth of the signaling data collection.

|[[db2-property-topic-naming-strategy]]<<db2-property-topic-naming-strategy, `topic.naming.strategy`>>
|`io.debezium.schema.SchemaTopicNamingStrategy`
|The name of the TopicNamingStrategy class that should be used to determine the topic name for data change, schema change, transaction, heartbeat event etc., defaults to `SchemaTopicNamingStrategy`.

|[[db2-property-topic-delimiter]]<<db2-property-topic-delimiter, `topic.delimiter`>>
|`.`
|Specify the delimiter for topic name, defaults to `.`.

|[[db2-property-topic-cache-size]]<<db2-property-topic-cache-size, `topic.cache.size`>>
|`10000`
|The size used for holding the topic names in bounded concurrent hash map. This cache will help to determine the topic name corresponding to a given data collection.

|[[db2-property-topic-heartbeat-prefix]]<<db2-property-topic-heartbeat-prefix, `+topic.heartbeat.prefix+`>>
|`__debezium-heartbeat`
|Controls the name of the topic to which the connector sends heartbeat messages. The topic name has this pattern: +
 +
_topic.heartbeat.prefix_._topic.prefix_ +
 +
For example, if the topic prefix is `fulfillment`, the default topic name is `__debezium-heartbeat.fulfillment`.

|[[db2-property-topic-transaction]]<<db2-property-topic-transaction, `topic.transaction`>>
|`transaction`
|Controls the name of the topic to which the connector sends transaction metadata messages. The topic name has this pattern: +
 +
_topic.prefix_._topic.transaction_ +
 +
For example, if the topic prefix is `fulfillment`, the default topic name is `fulfillment.transaction`.

|[[db2-property-snapshot-max-threads]]<<db2-property-snapshot-max-threads, `snapshot.max.threads`>>
|`1`
|Specifies the number of threads that the connector uses when performing an initial snapshot.
To enable parallel initial snapshots, set the property to a value greater than 1.
In a parallel initial snapshot, the connector processes multiple tables concurrently.
This feature is incubating.

|[[db2-property-custom-metric-tags]]<<db2-property-custom-metric-tags, `custom.metric.tags`>>
|`No default`
|Defines tags that customize MBean object names by adding metadata that provides contextual information.
Specify a comma-separated list of key-value pairs.
Each key represents a tag for the MBean object name, and the corresponding value represents a value for the key, for example,  +
`k1=v1,k2=v2`

The connector appends the specified tags to the base MBean object name.
Tags can help you to organize and categorize metrics data.
You can define tags to identify particular application instances, environments, regions, versions, and so forth.
For more information, see xref:customized-mbean-names[Customized MBean names].

|[[db2-property-errors-max-retires]]<<db2-property-errors-max-retires, `errors.max.retries`>>
|`-1`
|Specifies how the connector responds after an operation that results in a retriable error, such as a connection error. +
Set one of the following options:

`-1`:: No limit. The connector always restarts automatically, and retries the operation, regardless of the number of previous failures.

`0`:: Disabled. The connector fails immediately, and never retries the operation.
User intervention is required to restart the connector.

`> 0`:: The connector restarts automatically until it reaches the specified maximum number of retries.
After the next failure, the connector stops, and user intervention is required to restart it.

|[[db2-property-database-query-timeout-ms]]<<db2-property-database-query-timeout-ms, `database.query.timeout.ms`>>
|`600000` (10 minutes)
|Specifies the time, in milliseconds, that the connector waits for a query to complete.
Set the value to `0` (zero) to remove the timeout limit.

|[[db2-property-cdc-control-schema]]<<db2-property-cdc-control-schema, `cdc.control.schema`>>
|`ASNCDC`
|Specifies the name of the database schema that stores CDC control structures.

|[[db2-property-cdc-change-tables-schema]]<<db2-property-cdc-change-tables-schema, `cdc.change.tables.schema`>>
|`ASNCDC`
|Specifies the name of the database schema that stores CDC control structures.

|===

[id="debezium-db2-connector-database-history-configuration-properties"]
==== {prodname} connector database schema history configuration properties

:leveloffset: +1

{prodname} provides a set of `schema.history.internal.*` properties that control how the connector interacts with the schema history topic.

The following table describes the `schema.history.internal` properties for configuring the {prodname} connector.

.Connector database schema history configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-database-history-kafka-topic]]<<{context}-property-database-history-kafka-topic, `+schema.history.internal.kafka.topic+`>>
|No default
|The full name of the Kafka topic where the connector stores the database schema history.

|[[{context}-property-database-history-kafka-bootstrap-servers]]<<{context}-property-database-history-kafka-bootstrap-servers, `+schema.history.internal.kafka.bootstrap.servers+`>>
|No default
|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster. This connection is used for retrieving the database schema history previously stored by the connector, and for writing each DDL statement read from the source database. Each pair should point to the same Kafka cluster used by the Kafka Connect process.

|[[{context}-property-database-history-kafka-recovery-poll-interval-ms]]<<{context}-property-database-history-kafka-recovery-poll-interval-ms, `+schema.history.internal.kafka.recovery.poll.interval.ms+`>>
|`100`
|An integer value that specifies the maximum number of milliseconds the connector should wait during startup/recovery while polling for persisted data. The default is 100ms.

|[[{context}-property-database-history-kafka-query-timeout-ms]]<<{context}-property-database-history-kafka-query-timeout-ms, `+schema.history.internal.kafka.query.timeout.ms+`>>
|`3000`
|An integer value that specifies the maximum number of milliseconds the connector should wait while fetching cluster information using Kafka admin client.

|[[{context}-property-database-history-kafka-create-timeout-ms]]<<{context}-property-database-history-kafka-create-timeout-ms, `+schema.history.internal.kafka.create.timeout.ms+`>>
|`30000`
|An integer value that specifies the maximum number of milliseconds the connector should wait while create kafka history topic using Kafka admin client.

|[[{context}-property-database-history-kafka-recovery-attempts]]<<{context}-property-database-history-kafka-recovery-attempts, `+schema.history.internal.kafka.recovery.attempts+`>>
|`100`
|The maximum number of times that the connector should try to read persisted history data before the connector recovery fails with an error. The maximum amount of time to wait after receiving no data is `recovery.attempts` × `recovery.poll.interval.ms`.

|[[{context}-property-database-history-skip-unparseable-ddl]]<<{context}-property-database-history-skip-unparseable-ddl, `+schema.history.internal.skip.unparseable.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector should ignore malformed or unknown database statements or stop processing so a human can fix the issue.
The safe default is `false`.
Skipping should be used only with care as it can lead to data loss or mangling when the binlog is being processed.

|[[{context}-property-database-history-store-only-captured-tables-ddl]]<<{context}-property-database-history-store-only-captured-tables-ddl, `+schema.history.internal.store.only.captured.tables.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector records schema structures from all tables in a schema or database, or only from tables that are designated for capture. +
Specify one of the following values:

`false` (default):: During a database snapshot, the connector records the schema data for all non-system tables in the database, including tables that are not designated for capture.
It's best to retain the default setting.
If you later decide to capture changes from tables that you did not originally designate for capture, the connector can easily begin to capture data from those tables, because their schema structure is already stored in the schema history topic.
{prodname} requires the schema history of a table so that it can identify the structure that was present at the time that a change event occurred.

`true`:: During a database snapshot, the connector records the table schemas only for the tables from which {prodname} captures change events.
If you change the default value, and you later configure the connector to capture data from other tables in the database, the connector lacks the schema information that it requires to capture change events from the tables. +

|[[{context}-property-database-history-store-only-captured-databases-ddl]]<<{context}-property-database-history-store-only-captured-databases-ddl, `+schema.history.internal.store.only.captured.databases.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector records schema structures from all logical databases in the database instance. +
Specify one of the following values:

`true`:: The connector records schema structures only for tables in the logical database and schema from which {prodname} captures change events.
`false`:: The connector records schema structures for all logical databases. +

NOTE: The default value is `true` for MySQL Connector +

|===

[id="{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients"]
.Pass-through database schema history properties for configuring producer and consumer clients
{empty} +
{prodname} relies on a Kafka producer to write schema changes to database schema history topics.
Similarly, it relies on a Kafka consumer to read from database schema history topics when a connector starts.
You define the configuration for the Kafka producer and consumer clients by assigning values to a set of pass-through configuration properties that begin with the `schema.history.internal.producer.\*` and `schema.history.internal.consumer.*` prefixes.
The pass-through producer and consumer database schema history properties control a range of behaviors, such as how these clients secure connections with the Kafka broker, as shown in the following example:

[source,indent=0]
----
schema.history.internal.producer.security.protocol=SSL
schema.history.internal.producer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
schema.history.internal.producer.ssl.keystore.password=test1234
schema.history.internal.producer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
schema.history.internal.producer.ssl.truststore.password=test1234
schema.history.internal.producer.ssl.key.password=test1234

schema.history.internal.consumer.security.protocol=SSL
schema.history.internal.consumer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
schema.history.internal.consumer.ssl.keystore.password=test1234
schema.history.internal.consumer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
schema.history.internal.consumer.ssl.truststore.password=test1234
schema.history.internal.consumer.ssl.key.password=test1234
----

{prodname} strips the prefix from the property name before it passes the property to the Kafka client.

See the Kafka documentation for more details about link:https://kafka.apache.org/documentation.html#producerconfigs[Kafka producer configuration properties] and link:https://kafka.apache.org/documentation.html#consumerconfigs[Kafka consumer configuration properties].

:leveloffset: 1

[id="debezium-{context}-connector-kafka-signals-configuration-properties"]
==== {prodname} connector Kafka signals configuration properties

:leveloffset: +1

{prodname} provides a set of `signal.*` properties that control how the connector interacts with the Kafka signals topic.

The following table describes the Kafka `signal` properties.

.Kafka signals configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-signal-kafka-topic]]<<{context}-property-signal-kafka-topic, `+signal.kafka.topic+`>>
|<topic.prefix>-signal
|The name of the Kafka topic that the connector monitors for ad hoc signals.
[NOTE]
====
If {link-prefix}:{link-topic-auto-creation}#topic-auto-create-config[automatic topic creation] is disabled, you must manually create the required signaling topic.
A signaling topic is required to preserve signal ordering.
The signaling topic must have a single partition.
====

|[[{context}-property-signal-kafka-groupId]]<<{context}-property-signal-kafka-groupId, `+signal.kafka.groupId+`>>
|kafka-signal
|The name of the group ID  that is used by Kafka consumers.

|[[{context}-property-signal-kafka-bootstrap-servers]]<<{context}-property-signal-kafka-bootstrap-servers, `+signal.kafka.bootstrap.servers+`>>
|No default
|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster.
Each pair references the Kafka cluster that is used by the {prodname} Kafka Connect process.

|[[{context}-property-signal-kafka-poll-timeout-ms]]<<{context}-property-signal-kafka-poll-timeout-ms, `+signal.kafka.poll.timeout.ms+`>>
|`100`
|An integer value that specifies the maximum number of milliseconds that the connector waits when polling signals.

|[[{context}-kafka-consumer-offset-commit-enabled]]<<{context}-kafka-consumer-offset-commit-enabled, `+kafka.consumer.offset.commit.enabled+`>>
|`false`
|Enable the offset commit for the signal topic in order to guarantee At-Least-Once delivery. If disabled, only signals received when the consumer is up&running are processed. Any signals received when the consumer is down are lost.

|===

[id="debezium-{context}-connector-pass-through-signals-kafka-consumer-configuration-properties"]
=== {prodname} connector pass-through signals Kafka consumer client configuration properties

The {prodname} connector provides for pass-through configuration of the signals Kafka consumer.
Pass-through signals properties begin with the prefix `signals.consumer.*`.
For example, the connector passes properties such as `signal.consumer.security.protocol=SSL` to the Kafka consumer.

{prodname} strips the prefixes from the properties before it passes the properties to the Kafka signals consumer.

:leveloffset: 1

[id="debezium-{context}-connector-kafka-notifications-configuration-properties"]
==== {prodname} connector sink notifications configuration properties

:leveloffset: +1

The following table describes the `notification` properties.

.Sink notification configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-notification-sink-topic-name]]<<{context}-property-notification-sink-topic-name, `+notification.sink.topic.name+`>>
|No default
|The name of the topic that receives notifications from {prodname}.
This property is required when you configure the xref:{context}-property-notification-enabled-channels[`notification.enabled.channels`] property to include `sink` as one of the enabled notification channels.
|===

:leveloffset: 1

[id="debezium-db2-connector-pass-through-database-driver-configuration-properties"]
==== {prodname} connector pass-through database driver configuration properties

:leveloffset: +1

The {prodname} connector provides for pass-through configuration of the database driver.
Pass-through database properties begin with the prefix `driver.*`.
For example, the connector passes properties such as `driver.foobar=false` to the JDBC URL.

As is the case with the xref:{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[pass-through properties for database schema history clients], {prodname} strips the prefixes from the properties before it passes them to the database driver.

:leveloffset: 1

// Type: assembly
// ModuleID: monitoring-debezium-db2-connector-performance
// Title: Monitoring {prodname} Db2 connector performance
[[db2-monitoring]]
== Monitoring

The {prodname} Db2 connector provides three types of metrics that are in addition to the built-in support for JMX metrics that Apache ZooKeeper, Apache Kafka, and Kafka Connect provide.

* xref:db2-snapshot-metrics[Snapshot metrics] provide information about connector operation while performing a snapshot.
* xref:db2-streaming-metrics[Streaming metrics] provide information about connector operation when the connector is capturing changes and streaming change event records.
* xref:db2-schema-history-metrics[Schema history metrics] provide information about the status of the connector's schema history.

{link-prefix}:{link-debezium-monitoring}#monitoring-debezium[{prodname} monitoring documentation] provides details for how to expose these metrics by using JMX.

// Type: concept
// ModuleID: monitoring-debezium-db2-connectors-customized-mbean-names
// Title: Customized names for Db2 connector snapshot and streaming MBean objects
=== Customized MBean names

:leveloffset: +1

{prodname} connectors expose metrics via the MBean name for the connector.
These metrics, which are specific to each connector instance, provide data about the behavior of the connector's snapshot, streaming, and schema history processes.

By default, when you deploy a correctly configured connector, {prodname} generates a unique MBean name for each of the different connector metrics.
To view the metrics for a connector process, you configure your observability stack to monitor its MBean.
But these default MBean names depend on the connector configuration; configuration changes can result in changes to the MBean names.
A change to the MBean name breaks the linkage between the connector instance and the MBean, disrupting monitoring activity.
In this scenario, you must reconfigure the observability stack to use the new MBean name if you want to resume monitoring.

To prevent monitoring disruptions that result from MBean name changes, you can configure custom metrics tags.
You configure custom metrics by adding the `custom.metric.tags` property to the connector configuration.
The property accepts key-value pairs in which each key represents a tag for the MBean object name, and the corresponding value represents the value of that tag.
For example: `k1=v1,k2=v2`.
{prodname} appends the specified tags to the MBean name of the connector.

After you configure the `custom.metric.tags` property for a connector, you can configure the observability stack to retrieve metrics associated with the specified tags.
The observability stack then uses the specified tags, rather than the mutable MBean names to uniquely identify connectors.
Later, if {prodname} redefines how it constructs MBean names, or if the `topic.prefix` in the connector configuration changes, metrics collection is uninterrupted,
because the metrics scrape task uses the specified tag patterns to identify the connector.

A further benefit of using custom tags, is that you can use tags that reflect the architecture of your data pipeline, so that metrics are organized in a way that suits you operational needs.
For example, you might specify tags with values that declare the type of connector activity, the application context, or the data source, for example, `db1-streaming-for-application-abc`.
If you specify multiple key-value pairs, all of the specified pairs are appended to the connector's MBean name.

The following example illustrates how tags modify the default MBean name.

.How custom tags modify the connector MBean name
=======
By default, the {connector-name} connector uses the following MBean name for streaming metrics:
 +
[source,subs="attributes+,quotes"]
----
debezium.{context}:type=connector-metrics,context=streaming,server=_<topic.prefix>_
----

If you set the value of `custom.metric.tags` to `database=salesdb-streaming,table=inventory`, {prodname} generates the following custom MBean name:

[source,subs="attributes+,quotes"]
----
debezium.{context}:type=connector-metrics,context=streaming,server=_<topic.prefix>_,database=salesdb-streaming,table=inventory
----
=======


:leveloffset: 1

// Type: reference
// ModuleID: monitoring-debezium-during-snapshots-of-db2-databases
// Title: Monitoring {prodname} during snapshots of Db2 databases
[[db2-snapshot-metrics]]
=== Snapshot metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=snapshot,server=_<topic.prefix>_`.

:leveloffset: 1

:leveloffset: +1

Snapshot metrics are not exposed unless a snapshot operation is active, or if a snapshot has occurred since the last connector start.

The following table lists the snapshot metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-snaps-metric-lastevent_{context}]]<<connectors-snaps-metric-lastevent_{context}, `LastEvent`>>
|`string`
|The last snapshot event that the connector has read.

|[[connectors-snaps-metric-millisecondssincelastevent_{context}]]<<connectors-snaps-metric-millisecondssincelastevent_{context}, `MilliSecondsSinceLastEvent`>>
|`long`
|The number of milliseconds since the connector has read and processed the most recent event.

|[[connectors-snaps-metric-totalnumberofeventsseen_{context}]]<<connectors-snaps-metric-totalnumberofeventsseen_{context}, `TotalNumberOfEventsSeen`>>
|`long`
|The total number of events that this connector has seen since last started or reset.

|[[connectors-snaps-metric-numberofeventsfiltered_{context}]]<<connectors-snaps-metric-numberofeventsfiltered_{context}, `NumberOfEventsFiltered`>>
|`long`
| The number of events that have been filtered by include/exclude list filtering rules configured on the connector.

|[[connectors-snaps-metric-capturedtables_{context}]]<<connectors-snaps-metric-capturedtables_{context}, `CapturedTables`>>
|`string[]`
|The list of tables that are captured by the connector.

|[[connectors-snaps-metric-queuetotalcapacity_{context}]]<<connectors-snaps-metric-queuetotalcapacity_{context}, `QueueTotalCapacity`>>
|`int`
|The length the queue used to pass events between the snapshotter and the main Kafka Connect loop.

|[[connectors-snaps-metric-queueremainingcapacity_{context}]]<<connectors-snaps-metric-queueremainingcapacity_{context}, `QueueRemainingCapacity`>>
|`int`
|The free capacity of the queue used to pass events between the snapshotter and the main Kafka Connect loop.

|[[connectors-snaps-metric-totaltablecount_{context}]]<<connectors-snaps-metric-totaltablecount_{context}, `TotalTableCount`>>
|`int`
|The total number of tables that are being included in the snapshot.

|[[connectors-snaps-metric-remainingtablecount_{context}]]<<connectors-snaps-metric-remainingtablecount_{context}, `RemainingTableCount`>>
|`int`
|The number of tables that the snapshot has yet to copy.

|[[connectors-snaps-metric-snapshotrunning_{context}]]<<connectors-snaps-metric-snapshotrunning_{context}, `SnapshotRunning`>>
|`boolean`
|Whether the snapshot was started.

|[[connectors-snaps-metric-snapshotpaused_{context}]]<<connectors-snaps-metric-snapshotpaused_{context}, `SnapshotPaused`>>
|`boolean`
|Whether the snapshot was paused.

|[[connectors-snaps-metric-snapshotaborted_{context}]]<<connectors-snaps-metric-snapshotaborted_{context}, `SnapshotAborted`>>
|`boolean`
|Whether the snapshot was aborted.

|[[connectors-snaps-metric-snapshotcompleted_{context}]]<<connectors-snaps-metric-snapshotcompleted_{context}, `SnapshotCompleted`>>
|`boolean`
|Whether the snapshot completed.

|[[connectors-snaps-metric-snapshotdurationinseconds_{context}]]<<connectors-snaps-metric-snapshotdurationinseconds_{context}, `SnapshotDurationInSeconds`>>
|`long`
|The total number of seconds that the snapshot has taken so far, even if not complete. Includes also time when snapshot was paused.

|[[connectors-snaps-metric-snapshotpauseddurationinseconds_{context}]]<<connectors-snaps-metric-snapshotpauseddurationinseconds_{context}, `SnapshotPausedDurationInSeconds`>>
|`long`
|The total number of seconds that the snapshot was paused. If the snapshot was paused several times, the paused time adds up.

|[[connectors-snaps-metric-rowsscanned_{context}]]<<connectors-snaps-metric-rowsscanned_{context}, `RowsScanned`>>
|`Map<String, Long>`
|Map containing the number of rows scanned for each table in the snapshot.
Tables are incrementally added to the Map during processing.
Updates every 10,000 rows scanned and upon completing a table.

|[[connectors-snaps-metric-maxqueuesizeinbytes_{context}]]<<connectors-snaps-metric-maxqueuesizeinbytes_{context}, `MaxQueueSizeInBytes`>>
|`long`
|The maximum buffer of the queue in bytes. This metric is available if xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`] is set to a positive long value.

|[[connectors-snaps-metric-currentqueuesizeinbytes_{context}]]<<connectors-snaps-metric-currentqueuesizeinbytes_{context}, `CurrentQueueSizeInBytes`>>
|`long`
|The current volume, in bytes, of records in the queue.

|===

:leveloffset: 1

:leveloffset: +1

The connector also provides the following additional snapshot metrics when an incremental snapshot is executed:

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-insnap-metric-chunkid_{context}]]<<connectors-insnap-metric-chunkid_{context}, `ChunkId`>>
|`string`
|The identifier of the current snapshot chunk.

|[[connectors-insnap-metric-chunkfrom_{context}]]<<connectors-insnap-metric-chunkfrom_{context}, `ChunkFrom`>>
|`string`
|The lower bound of the primary key set defining the current chunk.

|[[connectors-insnap-metric-chunkto_{context}]]<<connectors-insnap-metric-chunkto_{context}, `ChunkTo`>>
|`string`
|The upper bound of the primary key set defining the current chunk.

|[[connectors-insnap-metric-tablefrom_{context}]]<<connectors-insnap-metric-tablefrom_{context}, `TableFrom`>>
|`string`
|The lower bound of the primary key set of the currently snapshotted table.

|[[connectors-insnap-metric-tableto_{context}]]<<connectors-insnap-metric-tableto_{context}, `TableTo`>>
|`string`
|The upper bound of the primary key set of the currently snapshotted table.

|===

The {prodname} {connector-name} connector also provides the `HoldingGlobalLock` custom snapshot metric.
This metric is set to a Boolean value that indicates whether the connector currently holds a global or table write lock.

:leveloffset: 1

// Type: reference
// ModuleID: monitoring-debezium-db2-connector-record-streaming
// Title: Monitoring {prodname} Db2 connector record streaming
[[db2-streaming-metrics]]
=== Streaming metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=streaming,server=_<topic.prefix>_`.

:leveloffset: 1

:leveloffset: +1

The following table lists the streaming metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-strm-metric-lastevent_{context}]]<<connectors-strm-metric-lastevent_{context}, `LastEvent`>>
|`string`
|The last streaming event that the connector has read.

|[[connectors-strm-metric-millisecondssincelastevent_{context}]]<<connectors-strm-metric-millisecondssincelastevent_{context}, `MilliSecondsSinceLastEvent`>>
|`long`
|The number of milliseconds since the connector has read and processed the most recent event.

|[[connectors-strm-metric-totalnumberofeventsseen_{context}]]<<connectors-strm-metric-totalnumberofeventsseen_{context}, `TotalNumberOfEventsSeen`>>
|`long`
|The total number of data change events reported by the source database since the last connector start, or since a metrics reset.
Represents the data change workload for {prodname} to process.

|[[connectors-strm-metric-totalnumberofcreateeventsseen_{context}]]<<connectors-strm-metric-totalnumberofcreateeventsseen_{context}, `TotalNumberOfCreateEventsSeen`>>
|`long`
|The total number of create events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-totalnumberofupdateeventsseen_{context}]]<<connectors-strm-metric-totalnumberofupdateeventsseen_{context}, `TotalNumberOfUpdateEventsSeen`>>
|`long`
|The total number of update events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-totalnumberofdeleteeventsseen_{context}]]<<connectors-strm-metric-totalnumberofdeleteeventsseen_{context}, `TotalNumberOfDeleteEventsSeen`>>
|`long`
|The total number of delete events processed by the connector since its last start or metrics reset.

|[[connectors-strm-metric-numberofeventsfiltered_{context}]]<<connectors-strm-metric-numberofeventsfiltered_{context}, `NumberOfEventsFiltered`>>
|`long`
|The number of events that have been filtered by include/exclude list filtering rules configured on the connector.

|[[connectors-strm-metric-capturedtables_{context}]]<<connectors-strm-metric-capturedtables_{context}, `CapturedTables`>>
|`string[]`
|The list of tables that are captured by the connector.

|[[connectors-strm-metric-queuetotalcapacity_{context}]]<<connectors-strm-metric-queuetotalcapacity_{context}, `QueueTotalCapacity`>>
|`int`
|The length the queue used to pass events between the streamer and the main Kafka Connect loop.

|[[connectors-strm-metric-queueremainingcapacity_{context}]]<<connectors-strm-metric-queueremainingcapacity_{context}, `QueueRemainingCapacity`>>
|`int`
|The free capacity of the queue used to pass events between the streamer and the main Kafka Connect loop.

|[[connectors-strm-metric-connected_{context}]]<<connectors-strm-metric-connected_{context}, `Connected`>>
|`boolean`
|Flag that denotes whether the connector is currently connected to the database server.

|[[connectors-strm-metric-millisecondsbehindsource_{context}]]<<connectors-strm-metric-millisecondsbehindsource_{context}, `MilliSecondsBehindSource`>>
|`long`
|The number of milliseconds between the last change event's timestamp and the connector processing it.
The values will incorporate any differences between the clocks on the machines where the database server and the connector are running.

|[[connectors-strm-metric-numberofcommittedtransactions_{context}]]<<connectors-strm-metric-numberofcommittedtransactions_{context}, `NumberOfCommittedTransactions`>>
|`long`
|The number of processed transactions that were committed.

|[[connectors-strm-metric-sourceeventposition_{context}]]<<connectors-strm-metric-sourceeventposition_{context}, `SourceEventPosition`>>
|`Map<String, String>`
|The coordinates of the last received event.

|[[connectors-strm-metric-lasttransactionid_{context}]]<<connectors-strm-metric-lasttransactionid_{context}, `LastTransactionId`>>
|`string`
|Transaction identifier of the last processed transaction.

|[[connectors-strm-metric-maxqueuesizeinbytes_{context}]]<<connectors-strm-metric-maxqueuesizeinbytes_{context}, `MaxQueueSizeInBytes`>>
|`long`
|The maximum buffer of the queue in bytes. This metric is available if xref:{context}-property-max-queue-size-in-bytes[`max.queue.size.in.bytes`] is set to a positive long value.

|[[connectors-strm-metric-currentqueuesizeinbytes_{context}]]<<connectors-strm-metric-currentqueuesizeinbytes_{context}, `CurrentQueueSizeInBytes`>>
|`long`
|The current volume, in bytes, of records in the queue.

|===

The {prodname} {connector-name} connector also provides the following additional streaming metrics:

.Descriptions of additional {connector-name} streaming metrics
[cols="3,2,5",options="header"]
|===
|Attribute |Type |Description

|[[binlog-filename]]<<binlog-filename,`+BinlogFilename+`>>
|`string`
|The name of the binlog file that the connector has most recently read.

|[[binlog-position]]<<binlog-position,`+BinlogPosition+`>>
|`long`
|The most recent position (in bytes) within the binlog that the connector has read.

|[[is-gtid-mode-enabled]]<<is-gtid-mode-enabled,`+IsGtidModeEnabled+`>>
|`boolean`
|Flag that denotes whether the connector is currently tracking GTIDs from {connector-name} server.

|[[gtid-set]]<<gtid-set,`+GtidSet+`>>
|`string`
|The string representation of the most recent GTID set processed by the connector when reading the binlog.

|[[number-of-skipped-events]]<<number-of-skipped-events,`+NumberOfSkippedEvents+`>>
|`long`
|The number of events that have been skipped by the {connector-name} connector. Typically events are skipped due to a malformed or unparseable event from {connector-name}'s binlog.

|[[number-of-disconnects]]<<number-of-disconnects,`+NumberOfDisconnects+`>>
|`long`
|The number of disconnects by the {connector-name} connector.

|[[number-of-rolled-back-transactions]]<<number-of-rolled-back-transactions,`+NumberOfRolledBackTransactions+`>>
|`long`
|The number of processed transactions that were rolled back and not streamed.

|[[number-of-not-well-formed-transactions]]<<number-of-not-well-formed-transactions,`+NumberOfNotWellFormedTransactions+`>>
|`long`
|The number of transactions that have not conformed to the expected protocol of `BEGIN` + `COMMIT`/`ROLLBACK`. This value should be `0` under normal conditions.

|[[number-of-large-transactions]]<<number-of-large-transactions,`+NumberOfLargeTransactions+`>>
|`long`
|The number of transactions that have not fit into the look-ahead buffer. For optimal performance, this value should be significantly smaller than `NumberOfCommittedTransactions` and `NumberOfRolledBackTransactions`.

|===

:leveloffset: 1

// Type: reference
// ModuleID: monitoring-debezium-db2-connector-schema-history
// Title: Monitoring {prodname} Db2 connector schema history
[[db2-schema-history-metrics]]
=== Schema history metrics

:leveloffset: +1

The *MBean* is `debezium.{mbean-name}:type=connector-metrics,context=schema-history,server=_<topic.prefix>_`.

The following table lists the schema history metrics that are available.

[cols="45%a,25%a,30%a",options="header"]
|===
|Attributes |Type |Description

|[[connectors-shist-metric-status_{context}]]<<connectors-shist-metric-status_{context}, `Status`>>
|`string`
|One of `STOPPED`, `RECOVERING` (recovering history from the storage), `RUNNING` describing the state of the database schema history.

|[[connectors-shist-metric-recoverystarttime_{context}]]<<connectors-shist-metric-recoverystarttime_{context}, `RecoveryStartTime`>>
|`long`
|The time in epoch seconds at what recovery has started.

|[[connectors-shist-metric-changesrecovered_{context}]]<<connectors-shist-metric-changesrecovered_{context}, `ChangesRecovered`>>
|`long`
|The number of changes that were read during recovery phase.

|[[connectors-shist-metric-changesapplied_{context}]]<<connectors-shist-metric-changesapplied_{context}, `ChangesApplied`>>
|`long`
|the total number of schema changes applied during recovery and runtime.

|[[connectors-shist-metric-millisecondssincelastrecoveredchange_{context}]]<<connectors-shist-metric-millisecondssincelastrecoveredchange_{context}, `MilliSecondsSinceLast{zwsp}RecoveredChange`>>
|`long`
|The number of milliseconds that elapsed since the last change was recovered from the history store.

|[[connectors-shist-metric-millisecondssincelastappliedchange_{context}]]<<connectors-shist-metric-millisecondssincelastappliedchange_{context}, `MilliSecondsSinceLast{zwsp}AppliedChange`>>
|`long`
|The number of milliseconds that elapsed since the last change was applied.

|[[connectors-shist-metric-lastrecoveredchange_{context}]]<<connectors-shist-metric-lastrecoveredchange_{context}, `LastRecoveredChange`>>
|`string`
|The string representation of the last change recovered from the history store.

|[[connectors-shist-metric-lastappliedchange_{context}]]<<connectors-shist-metric-lastappliedchange_{context}, `LastAppliedChange`>>
|`string`
|The string representation of the last applied change.

|===

:leveloffset: 1

// Type: reference
// ModuleID: managing-debezium-db2-connectors
// Title: Managing {prodname} Db2 connectors
[[db2-management]]
== Management

After you deploy a {prodname} Db2 connector, use the {prodname} management UDFs to control Db2 replication (ASN) with SQL commands. Some of the UDFs expect a return value in which case you use the  SQL `VALUE` statement to invoke them. For other UDFs, use the SQL `CALL` statement.

.Descriptions of {prodname} management UDFs
[cols="1,4",options="header"]
|===
|Task |Command and notes

|[[debezium-db2-start-asn-agent]]<<debezium-db2-start-asn-agent,Start the ASN agent>>
|`VALUES ASNCDC.ASNCDCSERVICES('start','asncdc');`

|[[debezium-db2-stop-asn-agent]]<<debezium-db2-stop-asn-agent,Stop the ASN agent>>
|`VALUES ASNCDC.ASNCDCSERVICES('stop','asncdc');`

|[[debezium-db2-check-asn-agent]]<<debezium-db2-check-asn-agent,Check the status of the ASN agent>>
|`VALUES ASNCDC.ASNCDCSERVICES('status','asncdc');`

|[[debezium-db2-put-capture-mode]]<<debezium-db2-put-capture-mode,Put a table into capture mode>>
|`CALL ASNCDC.ADDTABLE('MYSCHEMA', 'MYTABLE');` +
 +
Replace `MYSCHEMA`  with the name of the schema that contains the table you want to put into capture mode. Likewise, replace `MYTABLE` with the name of the table to put into capture mode.

|[[debezium-db2-remove-capture-mode]]<<debezium-db2-remove-capture-mode,Remove a table from capture mode>>
|`CALL ASNCDC.REMOVETABLE('MYSCHEMA', 'MYTABLE');`

|[[debezium-db2-reinitialize-asn-service]]<<debezium-db2-reinitialize-asn-service,Reinitialize the ASN service>>
|`VALUES ASNCDC.ASNCDCSERVICES('reinit','asncdc');` +
 +
Do this after you put a table into capture mode or after you remove a table from capture mode.

|===

// Type: assembly
// ModuleID: updating-schemas-for-db2-tables-in-capture-mode-for-debezium-connectors
// Title: Updating schemas for Db2 tables in capture mode for {prodname} connectors
[[db2-schema-evolution]]
== Schema evolution

While a {prodname} Db2 connector can capture schema changes, to update a schema, you must collaborate with a database administrator to ensure that the connector continues to produce change events. This is required by the way that Db2 implements replication.

For each table in capture mode, the replication feature in Db2 creates a change-data table that contains all changes to that source table. However, change-data table schemas are static. If you update the schema for a table in capture mode then you must also update the schema of its corresponding change-data table. A {prodname} Db2 connector cannot do this. A database administrator with elevated privileges must update schemas for tables that are in capture mode.

[WARNING]
====
It is vital to execute a schema update procedure completely before there is a new schema update on the same table. Consequently, the recommendation is to execute all DDLs in a single batch so the schema update procedure is done only once.
====

There are generally two procedures for updating table schemas:

* xref:db2-offline-schema-update[Offline - executed while {prodname} is stopped]
* xref:db2-hot-schema-update[Online - executed while {prodname} is running]

Each approach has advantages and disadvantages.

// Type: procedure
// ModuleID: performing-offline-schema-updates-for-debezium-db2-connectors
// Title: Performing offline schema updates for {prodname} Db2 connectors
[[db2-offline-schema-update]]
=== Offline schema update

You stop the {prodname} Db2 connector before you perform an offline schema update. While this is the safer schema update procedure, it might not be feasible for applications with high-availability requirements.

.Prerequisites

* One or more tables that are in capture mode require schema updates.

.Procedure

. Suspend the application that updates the database.
. Wait for the {prodname} connector to stream all unstreamed change event records.
. Stop the {prodname} connector.
. Apply all changes to the source table schema.
. In the ASN register table, mark the tables with updated schemas as `INACTIVE`.
. xref:debezium-db2-reinitialize-asn-service[Reinitialize the ASN capture service].
. Remove the source table with the old schema from capture mode by xref:debezium-db2-remove-capture-mode[running the {prodname} UDF for removing tables from capture mode].
. Add the source table with the new schema to capture mode by xref:debezium-db2-put-capture-mode[running the {prodname} UDF for adding tables to capture mode].
. In the ASN register table, mark the updated source tables as `ACTIVE`.
. xref:debezium-db2-reinitialize-asn-service[Reinitialize the ASN capture service.]
. Resume the application that updates the database.
. Restart the {prodname} connector.

// Type: procedure
// ModuleID: performing-online-schema-updates-for-debezium-db2-connectors
// Title: Performing online schema updates for {prodname} Db2 connectors
[[db2-hot-schema-update]]
=== Online schema update

An online schema update does not require application and data processing downtime. That is, you do not stop the {prodname} Db2 connector before you perform an online schema update. Also, an online schema update procedure is simpler than the procedure for an offline schema update.

However, when a table is in capture mode, after a change to a column name, the Db2 replication feature continues to use the old column name. The new column name does not appear in {prodname} change events. You must restart the connector to see the new column name in change events.

.Prerequisites

* One or more tables that are in capture mode require schema updates.

.Procedure when adding a column to the end of a table

. Lock the source tables whose schema you want to change.
. In the ASN register table, mark the locked tables as `INACTIVE`.
. xref:debezium-db2-reinitialize-asn-service[Reinitialize the ASN capture service.]
. Apply all changes to the schemas for the source tables.
. Apply all changes to the schemas for the corresponding change-data tables.
. In the ASN register table, mark the source tables as `ACTIVE`.
. xref:debezium-db2-reinitialize-asn-service[Reinitialize the ASN capture service.]
. Optional. Restart the connector to see updated column names in change events.

.Procedure when adding a column to the middle of a table

. Lock the source table(s) to be changed.
. In the ASN register table, mark the locked tables as `INACTIVE`.
. xref:debezium-db2-reinitialize-asn-service[Reinitialize the ASN capture service.]
. For each source table to be changed:
.. Export the data in the source table.
.. Truncate the source table.
.. Alter the source table and add the column.
.. Load the exported data into the altered source table.
.. Export the data in the source table's corresponding change-data table.
.. Truncate the change-data table.
.. Alter the change-data table and add the column.
.. Load the exported data into the altered change-data table.
. In the ASN register table, mark the tables as `INACTIVE`. This marks the old change-data tables as inactive, which allows the data in them to remain but they are no longer updated.
. xref:debezium-db2-reinitialize-asn-service[Reinitialize the ASN capture service.]
. Optional. Restart the connector to see updated column names in change events.

:leveloffset!:


//monitoring

:leveloffset: +1


// Category: debezium-using
// Type: assembly

[id="monitoring-debezium"]
= Monitoring {prodname}

:linkattrs:
:icons: font
:toc:
:toc-placement: macro

toc::[]

You can use the JMX metrics provided by link:https://zookeeper.apache.org/doc/r3.1.2/zookeeperJMX.html[Apache Zookeeper], link:https://kafka.apache.org/documentation/#monitoring[Apache Kafka], and https://kafka.apache.org/documentation/#connect_monitoring[Kafka Connect] to monitor {prodname}.
To use these metrics, you must enable them when you start the Zookeeper, Kafka, and Kafka Connect services.
Enabling JMX involves setting the correct environment variables.
The environment variables that you must set depend on whether you are running Zookeeper, Kafka, and Kafka Connect in a local installation or in Docker containers.

[NOTE]
====
If you are running multiple services on the same machine,
be sure to use distinct JMX ports for each service.
====


// Category: debezium-using
// Type: concept
// ModuleID: debezium-metrics-monitoring-connectors
[id="metrics-monitoring-connectors"]
== Metrics for monitoring {prodname} connectors

In addition to the built-in support for JMX metrics in Kafka, Zookeeper, and Kafka Connect,
each connector provides additional metrics that you can use to monitor their activities.

* {link-prefix}:{link-db2-connector}#db2-monitoring[Db2 connector metrics]
* {link-prefix}:{link-mongodb-connector}#mongodb-monitoring[MongoDB connector metrics]
* {link-prefix}:{link-mysql-connector}#mysql-monitoring[MySQL connector metrics]
* {link-prefix}:{link-oracle-connector}#oracle-monitoring[Oracle connector metrics]
* {link-prefix}:{link-postgresql-connector}#postgresql-monitoring[PostgreSQL connector metrics]
* {link-prefix}:{link-sqlserver-connector}#sqlserver-monitoring[SQL Server connector metrics]
* {link-prefix}:{link-cassandra-connector}#cassandra-monitoring[Cassandra connector metrics]
* {link-prefix}:{link-vitess-connector}#vitess-monitoring[Vitess connector metrics]
* {link-prefix}:{link-spanner-connector}#spanner-monitoring[Spanner connector metrics]
* {link-prefix}:{link-informix-connector}#informix-monitoring[Informix connector metrics]


// Category: debezium-using
// Type: assembly
// ModuleID: enabling-jmx-in-local-installations
[id="enabling-jmx-local-installation"]
== Enabling JMX in local installations

With Zookeeper, Kafka, and Kafka Connect,
you enable JMX by setting the appropriate environment variables when you start each service.

// Category: debezium-using
// Type: reference
// ModuleID: debezium-zookeeper-jmx-environment-variables
[id="zookeeper-jmx-environment-variables"]
=== Zookeeper JMX environment variables

Zookeeper has built-in support for JMX.
When running Zookeeper using a local installation,
the `zkServer.sh` script recognizes the following environment variables:

`JMXPORT`::
Enables JMX and specifies the port number that will be used for JMX.
The value is used to specify the JVM parameter `-Dcom.sun.management.jmxremote.port=$JMXPORT`.

`JMXAUTH`::
Whether JMX clients must use password authentication when connecting.
Must be either `true` or `false`.
The default is `false`.
The value is used to specify the JVM parameter `-Dcom.sun.management.jmxremote.authenticate=$JMXAUTH`.

`JMXSSL`::
Whether JMX clients connect using SSL/TLS.
Must be either `true` or `false`.
The default is `false`.
The value is used to specify the JVM parameter `-Dcom.sun.management.jmxremote.ssl=$JMXSSL`.

`JMXLOG4J`::
Whether the Log4J JMX MBeans should be disabled.
Must be either `true` (default) or `false`.
The default is `true`.
The value is used to specify the JVM parameter `-Dzookeeper.jmx.log4j.disable=$JMXLOG4J`.


// Category: debezium-using
// Type: reference
// ModuleID: debezium-kafka-jmx-environment-variables
[id="kafka-jmx-environment-variables"]
=== Kafka JMX environment variables

When running Kafka using a local installation,
the `kafka-server-start.sh` script recognizes the following environment variables:

`JMX_PORT`::
Enables JMX and specifies the port number that will be used for JMX.
The value is used to specify the JVM parameter `-Dcom.sun.management.jmxremote.port=$JMX_PORT`.

`KAFKA_JMX_OPTS`::
The JMX options, which are passed directly to the JVM during startup.
The default options are:
+
** `-Dcom.sun.management.jmxremote`
** `-Dcom.sun.management.jmxremote.authenticate=false`
** `-Dcom.sun.management.jmxremote.ssl=false`


// Category: debezium-using
// Type: reference
// ModuleID: debezium-kafka-connect-jmx-environment-variables
[id="kafka-connect-jmx-environment-variables"]
=== Kafka Connect JMX environment variables

When running Kafka using a local installation,
the `connect-distributed.sh` script recognizes the following environment variables:

`JMX_PORT`::
Enables JMX and specifies the port number that will be used for JMX.
The value is used to specify the JVM parameter `-Dcom.sun.management.jmxremote.port=$JMX_PORT`.

`KAFKA_JMX_OPTS`::
The JMX options, which are passed directly to the JVM during startup.
The default options are:
+
** `-Dcom.sun.management.jmxremote`
** `-Dcom.sun.management.jmxremote.authenticate=false`
** `-Dcom.sun.management.jmxremote.ssl=false`


[id="enabling-jmx-docker"]
== Enabling JMX in Docker

If you are running Apache Zookeeper, Kafka, and Kafka Connect in via the {prodname} container images,
enabling JMX requires several additional environment variables that are not typically needed when running on a local machine.
This is because the JVM requires the host name to which it will advertise itself to JMX clients.
Thus, {prodname}'s container images for Zookeeper, Kafka, and Kafka Connect use several environment variables to enable and configure JMX.
Most of the environment variables are the same for all of the images,
but there are some minor differences.


[id="zookeeper-jmx-environment-variables-docker"]
=== Zookeeper JMX environment variables in Docker

The `debezium/zookeeper` image recognizes the following JMX-related environment variables:

`JMXPORT` (Required)::
The port number that will be used for JMX.
The value is used to specify the following JVM parameters:
+
** `-Dcom.sun.management.jmxremote.port=$JMXPORT`
** `-Dcom.sun.management.jmxremote.rmi.port=$JMXPORT`

`JMXHOST` (Required)::
The IP address or resolvable host name of the Docker host,
which JMX uses to construct a URL sent to the JMX client.
A value of `localhost` or `127.0.0.1` will not work.
Typically, `0.0.0.0` can be used.
The value is used to specify the JVM parameter `-Djava.rmi.server.hostname=$JMXHOST`.

`JMXAUTH`::
Whether JMX clients must use password authentication when connecting.
Must be either `true` or `false`.
The default is `false`.
The value is used to specify the JVM parameter `-Dcom.sun.management.jmxremote.authenticate=$JMXAUTH`.

`JMXSSL`::
Whether JMX clients connect using SSL/TLS.
Must be either `true` or `false`.
The default is `false`.
The value is used to specify the JVM parameter `-Dcom.sun.management.jmxremote.ssl=$JMXSSL`.

`JMXLOG4J`::
Whether the Log4J JMX MBeans should be disabled.
Must be either `true` or `false`.
The default is `true`.
The value is used to specify the JVM parameter `-Dzookeeper.jmx.log4j.disable=$JMXLOG4J`.

.Enabling JMX in a Zookeeper Docker container
====
The following example Docker command starts a container using the `debezium/zookeeper` image with values for the `JMXPORT` and `JMXHOST` environment variables,
and maps the Docker host's port 9010 to the container's JMX port:

[source,shell,options="nowrap"]
----
$ docker run -it --rm --name zookeeper -p 2181:2181 -p 2888:2888 -p 3888:3888 -p 9010:9010 -e JMXPORT=9010 -e JMXHOST=10.0.1.10 quay.io/debezium/zookeeper:latest
----
====

[id="kafka-jmx-environment-variables-docker"]
=== Kafka JMX environment variables in Docker

The `debezium/kafka` image recognizes the following JMX-related environment variables:

`JMXPORT` (Required)::
The port number that will be used for JMX.
The value is used to specify the following JVM parameters:
+
** `-Dcom.sun.management.jmxremote.port=$JMXPORT`
** `-Dcom.sun.management.jmxremote.rmi.port=$JMXPORT`

`JMXHOST` (Required)::
The IP address or resolvable host name of the Docker host,
which JMX uses to construct a URL sent to the JMX client.
A value of `localhost` or `127.0.0.1` will not work.
Typically, `0.0.0.0` can be used.
The value is used to specify the JVM parameter `-Djava.rmi.server.hostname=$JMXHOST`.

`JMXAUTH`::
Whether JMX clients must use password authentication when connecting.
Must be either `true` or `false`.
The default is `false`.
The value is used to specify the JVM parameter `-Dcom.sun.management.jmxremote.authenticate=$JMXAUTH`.

`JMXSSL`::
Whether JMX clients connect using SSL/TLS.
Must be either `true` or `false`.
The default is `false`.
The value is used to specify the JVM parameter `-Dcom.sun.management.jmxremote.ssl=$JMXSSL`.

.Enabling JMX in a Kafka Docker container
====
The following example Docker command starts a container using the `debezium/kafka` image with values for the `JMXPORT` and `HOST_NAME` environment variables,
and maps the Docker host's port 9011 to the container's JMX port:

[source,shell,options="nowrap"]
----
$ docker run -it --rm --name kafka -p 9092:9092 -p 9011:9011 -e JMXPORT=9011 -e JMXHOST=10.0.1.10 --link zookeeper:zookeeper quay.io/debezium/kafka:latest
----
====

[id="kafka-connect-jmx-environment-variables-docker"]
=== Kafka Connect JMX environment variables in Docker

The `debezium/connect` image recognizes the following JMX-related environment variables:

`JMXPORT` (Required)::
The port number that will be used for JMX.
The value is used to specify the following JVM parameters:
+
** `-Dcom.sun.management.jmxremote.port=$JMXPORT`
** `-Dcom.sun.management.jmxremote.rmi.port=$JMXPORT`

`JMXHOST` (Required)::
The IP address or resolvable host name of the Docker host,
which JMX uses to construct a URL sent to the JMX client.
A value of `localhost` or `127.0.0.1` will not work.
Typically, `0.0.0.0` can be used.
The value is used to specify the JVM parameter `-Djava.rmi.server.hostname=$JMXHOST`.

`JMXAUTH`::
Whether JMX clients must use password authentication when connecting.
Must be either `true` or `false`.
The default is `false`.
The value is used to specify the JVM parameter `-Dcom.sun.management.jmxremote.authenticate=$JMXAUTH`.

`JMXSSL`::
Whether JMX clients connect using SSL/TLS.
Must be either `true` or `false`.
The default is `false`.
The value is used to specify the JVM parameter `-Dcom.sun.management.jmxremote.ssl=$JMXSSL`.

.Enabling JMX in a Kafka Connect Docker container
====
The following example Docker command starts a container using the `debezium/connect` image with values for the `JMXPORT` and `JMXHOST` environment variables,
and maps the Docker host's port 9012 to the container's JMX port:

[source,shell,options="nowrap"]
----
$ docker run -it --rm --name connect \
  -p 8083:8083 -p 9012:9012 \
  -e JMXPORT=9012 -e JMXHOST=10.0.1.10 \
  -e GROUP_ID=1 \
  -e CONFIG_STORAGE_TOPIC=my_connect_configs \
  -e OFFSET_STORAGE_TOPIC=my_connect_offsets \
  -e STATUS_STORAGE_TOPIC=my_connect_statuses \
  --link zookeeper:zookeeper \
  --link kafka:kafka \
  --link mysql:mysql \
  quay.io/debezium/connect:latest
----
====

[id="using-prometheus-grafana"]
== Using Prometheus and Grafana

The metrics exposed by {prodname} and Kafka can be exported and displayed with https://prometheus.io/[Prometheus] and https://grafana.com/[Grafana].
You can find an example for the required configuration and example dashboards for different connectors in the https://github.com/debezium/debezium-examples/tree/main/monitoring[Debezium examples repository].

[NOTE]
====
These dashboards are not part of {prodname} itself and are maintained on a best-effort basis.
====

[id="java-flight-recorder"]
== Java Flight Recording

The {prodname} container image for Kafka Connect also provides easy-to-use support for https://openjdk.java.net/jeps/328[JDK Flight Recorder].
To enable the recording it is necessary to set the environment variable `ENABLE_JFR=true`.
The recording will then be started automatically upon container start.
By default, the recording is enabled, i.e. a continuous recording with default settings is done, which you then can dump using _jcmd_ or JDK Mission Control.

It is possible to modify the recorder's behaviour.
For that, you need to set either environment variables prefixed with `JFR_RECORDING_` to set recording parameters.
The part after the prefix is converted to lowercase and underscores are replaced with dashes so `JFR_RECORDING_PATH_TO_GC_ROOTS=true` becomes `path-to-gc-roots=true`.

Flight Recorder control options can be configured via `JFR_OPT_` prefixed environment variables.

:leveloffset!:
:leveloffset: +1

// Category: debezium-using
// Type: assembly
// ModuleID: debezium-logging
[id="debezium-logging"]
= {prodname} logging

:linkattrs:
:icons: font
:source-highlighter: highlight.js
:toc:
:toc-placement: macro

toc::[]

{prodname} has extensive logging built into its connectors,
and you can change the logging configuration to control which of these log statements appear in the logs
and where those logs are sent.
{prodname} (as well as Kafka, Kafka Connect, and Zookeeper) use the https://logging.apache.org/log4j/1.2/[Log4j] logging framework for Java.

By default, the connectors produce a fair amount of useful information when they start up,
but then produce very few logs when the connector is keeping up with the source databases.
This is often sufficient when the connector is operating normally,
but may not be enough when the connector is behaving unexpectedly.
In such cases, you can change the logging level so that the connector generates much more verbose log messages describing what the connector is doing and what it is not doing.

// Type: concept
// ModuleID: debezium-logging-concepts
// Title: {prodname} logging concepts
[id="logging-concepts"]
== Logging concepts

Before configuring logging, you should understand what Log4J _loggers_, _log levels_, and _appenders_ are.

[discrete]
=== Loggers

Each log message produced by the application is sent to a specific _logger_
(for example, `io.debezium.connector.mysql`).
Loggers are arranged in hierarchies.
For example, the `io.debezium.connector.mysql` logger is the child of the `io.debezium.connector` logger,
which is the child of the `io.debezium` logger.
At the top of the hierarchy,
the _root logger_ defines the default logger configuration for all of the loggers beneath it.

[discrete]
=== Log levels

Every log message produced by the application also has a specific _log level_:

1. `ERROR` - errors, exceptions, and other significant problems
2. `WARN` - _potential_ problems and issues
3. `INFO` - status and general activity (usually low-volume)
4. `DEBUG` - more detailed activity that would be useful in diagnosing unexpected behavior
5. `TRACE` - very verbose and detailed activity (usually very high-volume)

[discrete]
=== Appenders

An _appender_ is essentially a destination where log messages are written.
Each appender controls the format of its log messages,
giving you even more control over what the log messages look like.

To configure logging, you specify the desired level for each logger and the appender(s) where those log messages should be written. Since loggers are hierarchical, the configuration for the root logger serves as a default for all of the loggers below it, although you can override any child (or descendant) logger.


// Type: concept
// ModuleID: default-debezium-logging-configuration
// Title: Default {prodname} logging configuration
[id="understanding-default-logging-configuration"]
== Understanding the default logging configuration

If you are running {prodname} connectors in a Kafka Connect process,
then Kafka Connect uses the Log4j configuration file (for example, `/opt/kafka/config/connect-log4j.properties`) in the Kafka installation.
By default, this file contains the following configuration:

.connect-log4j.properties
[source,properties,options="nowrap"]
----
log4j.rootLogger=INFO, stdout  // <1>

log4j.appender.stdout=org.apache.log4j.ConsoleAppender  // <2>
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout  // <3>
log4j.appender.stdout.layout.ConversionPattern=[%d] %p %m (%c)%n  // <4>
...
----
.Descriptions of `connect-log4j.properties` settings
[cols="1,7",options="header",subs="+attributes"]
|===
|Property |Description

|1
|The root logger, which defines the default logger configuration.
By default, loggers include `INFO`, `WARN`, and `ERROR` messages.
These log messages are written to the `stdout` appender.

|2
|Directs the `stdout` appender to write log messages to the console, as opposed to a file.

|3
|Specifies that the `stdout` appender uses a pattern matching algorithm to format log messages.

|4
|The pattern that the `stdout` appender uses (see the https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html[Log4j documentation] for details).

|===

Unless you configure other loggers,
all of the loggers that {prodname} uses inherit the `rootLogger` configuration.


// Type: assembly
// ModuleID: configuring-debezium-logging
// Title: Configuring {prodname} logging
[id="configuring-logging"]
== Configuring logging

By default, {prodname} connectors write all `INFO`, `WARN`, and `ERROR` messages to the console.
You can change the default logging configuration by using one of the following methods:

* xref:changing-logging-level[Setting the logging level by configuring loggers]
* xref:setting-the-logging-level-with-the-kafka-connect-rest-api[Dynamically setting the logging level with the Kafka Connect REST API]
* xref:adding-mapped-diagnostic-contexts[Setting the logging level by adding mapped diagnostic contexts]

[NOTE]
====
There are other methods that you can use to configure {prodname} logging with Log4j.
For more information, search for tutorials about setting up and using appenders to send log messages to specific destinations.
====

// Type: procedure
// ModuleID: changing-the-debezium-logging-level
// Title: Changing the {prodname} logging level by configuring loggers
[id="changing-logging-level"]
=== Setting the logging level by configuring loggers

The default {prodname} logging level provides sufficient information to show whether a connector is healthy or not.
However, if a connector is not healthy, you can change its logging level to troubleshoot the issue.

In general, {prodname} connectors send their log messages to loggers with names that match the fully-qualified name of the Java class that is generating the log message.
{prodname} uses packages to organize code with similar or related functions.
This means that you can control all of the log messages for a specific class or for all of the classes within or under a specific package.

.Procedure

. Open the `log4j.properties` file.

. Configure a logger for the connector.
+
The following example configures loggers for the MySQL connector and for the database schema history implementation used by the connector,
and sets them to log `DEBUG` level messages: +
+
.log4j.properties
[source,properties,options="nowrap"]
----
...
log4j.logger.io.debezium.connector.mysql=DEBUG, stdout  // <1>
log4j.logger.io.debezium.relational.history=DEBUG, stdout  // <2>

log4j.additivity.io.debezium.connector.mysql=false  // <3>
log4j.additivity.io.debezium.storage.kafka.history=false
...
----
+
.Descriptions of `log4j.properties` settings
[cols="1,7",options="header",subs="+attributes"]
|===
|Property |Description

|1
|Configures the logger named `io.debezium.connector.mysql` to send `DEBUG`, `INFO`, `WARN`, and `ERROR` messages to the `stdout` appender.

|2
|Configures the logger named `io.debezium.relational.history` to send `DEBUG`, `INFO`, `WARN`, and `ERROR` messages to the `stdout` appender.

|3
|This pair of `log4j.additivity.io` entries disable https://logging.apache.org/log4j/2.x/manual/configuration.html#additivity[additivity].
If you use multiple appenders, set `additivity` values to `false` to prevent duplicate log messages from being sent to the appenders of the parent loggers.

|===

. If necessary, change the logging level for a specific subset of the classes within the connector.
+
Increasing the logging level for the entire connector increases the log verbosity,
which can make it difficult to understand what is happening.
In these cases,
you can change the logging level just for the subset of classes that are related to the issue that you are troubleshooting.

.. Set the connector's logging level to either `DEBUG` or `TRACE`.

.. Review the connector's log messages.
+
Find the log messages that are related to the issue that you are troubleshooting.
The end of each log message shows the name of the Java class that produced the message.

.. Set the connector's logging level back to `INFO`.

.. Configure a logger for each Java class that you identified.
+
For example, consider a scenario in which you are unsure why the MySQL connector is skipping some events when it is processing the binlog.
Rather than turn on `DEBUG` or `TRACE` logging for the entire connector,
you can keep the connector's logging level at `INFO` and then configure `DEBUG` or `TRACE` on just the class that is reading the binlog:
+
.log4j.properties
[source,properties,options="nowrap"]
----
...
log4j.logger.io.debezium.connector.mysql=INFO, stdout
log4j.logger.io.debezium.connector.mysql.BinlogReader=DEBUG, stdout
log4j.logger.io.debezium.relational.history=INFO, stdout

log4j.additivity.io.debezium.connector.mysql=false
log4j.additivity.io.debezium.storage.kafka.history=false
log4j.additivity.io.debezium.connector.mysql.BinlogReader=false
...
----

// Type: procedure
// ModuleID: setting-the-debezium-logging-level-with-the-kafka-connect-rest-api
// Title: Dynamically changing the {prodname} logging level with the Kafka Connect API
[id="setting-the-logging-level-with-the-kafka-connect-rest-api"]
=== Dynamically setting the logging level with the Kafka Connect REST API

You can use the Kafka Connect REST API to set logging levels for a connector dynamically at runtime.
Unlike log level changes that you set in `log4j.properties`, changes that you make via the API take effect immediately, and do not require you to restart the worker.

The log level setting that you specify in the API applies only to the worker at the endpoint that receives the request.
The log levels of other workers in the cluster remain unchanged.

The specified level is not persisted after the worker restarts.
To make persistent changes to the logging level, set the log level in `log4j.properties` by xref:changing-logging-level[configuring loggers] or xref:adding-mapped-diagnostic-contexts[adding mapped diagnostic contexts].

.Procedure

* Set the log level by sending a PUT request to the `admin/loggers` endpoint that specifies the following information:
** The package for which you want to change the log level.
** The log level that you want to set.
+
[source,shell,subs="+attributes,+quotes", options="nowrap"]
----
curl -s -X PUT -H "Content-Type:application/json" http://localhost:8083/admin/loggers/io.debezium.connector._<connector_package>_ -d '{"level": "_<log_level>_"}'
----
+
For example, to log debug information for a {prodname} MySQL connector, send the following request to Kafka Connect:
+
[source,shell,options="nowrap"]
----
curl -s -X PUT -H "Content-Type:application/json" http://localhost:8083/admin/loggers/io.debezium.connector.mysql -d '{"level": "DEBUG"}'
----

// Type: procedure
// ModuleID: adding-debezium-mapped-diagnostic-contexts
// Title: Changing the {prodname} logging levely by adding mapped diagnostic contexts
[id="adding-mapped-diagnostic-contexts"]
=== Setting the logging level with mapped diagnostic contexts

Most {prodname} connectors (and the Kafka Connect workers) use multiple threads to perform different activities.
This can make it difficult to look at a log file and find only those log messages for a particular logical activity.
To make the log messages easier to find,
{prodname} provides several _mapped diagnostic contexts_ (MDC) that provide additional information for each thread.

{prodname} provides the following MDC properties:

`dbz.connectorType`::
A short alias for the type of connector.
For example, `MySql`, `Mongo`, `Postgres`, and so on.
All threads associated with the same _type_ of connector use the same value,
so you can use this to find all log messages produced by a given type of connector.

`dbz.connectorName`::
The name of the connector or database server as defined in the connector's configuration.
For example `products`, `serverA`, and so on.
All threads associated with a specific _connector instance_ use the same value,
so you can find all of the log messages produced by a specific connector instance.

`dbz.connectorContext`::
A short name for an activity running as a separate thread running within the connector's task.
For example, `main`, `binlog`, `snapshot`, and so on.
In some cases, when a connector assigns threads to specific resources (such as a table or collection),
the name of that resource could be used instead.
Each thread associated with a connector would use a distinct value,
so you can find all of the log messages associated with this particular activity.

To enable MDC for a connector,
you configure an appender in the `log4j.properties` file.

.Procedure

. Open the `log4j.properties` file.

. Configure an appender to use any of the supported {prodname} MDC properties.
+
--
In the following example, the `stdout` appender is configured to use these MDC properties:

.log4j.properties
[source,properties,options="nowrap"]
----
...
log4j.appender.stdout.layout.ConversionPattern=%d{ISO8601} %-5p  %X{dbz.connectorType}|%X{dbz.connectorName}|%X{dbz.connectorContext}  %m   [%c]%n
...
----

The configuration in the preceding example produces log messages similar to the ones in the following output:

[source,shell,options="nowrap"]
----
...
2017-02-07 20:49:37,692 INFO   MySQL|dbserver1|snapshot  Starting snapshot for jdbc:mysql://mysql:3306/?useInformationSchema=true&nullCatalogMeansCurrent=false&useSSL=false&useUnicode=true&characterEncoding=UTF-8&characterSetResults=UTF-8&zeroDateTimeBehavior=convertToNull with user 'debezium'   [io.debezium.connector.mysql.SnapshotReader]
2017-02-07 20:49:37,696 INFO   MySQL|dbserver1|snapshot  Snapshot is using user 'debezium' with these MySQL grants:   [io.debezium.connector.mysql.SnapshotReader]
2017-02-07 20:49:37,697 INFO   MySQL|dbserver1|snapshot  	GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'debezium'@'%'   [io.debezium.connector.mysql.SnapshotReader]
...
----

Each line in the log includes the connector type (for example, `MySQL`), the name of the connector (for example, `dbserver1`), and the activity of the thread (for example, `snapshot`).
--



[id="configuring-log-level-docker"]
== Configuring the log level in the {prodname} container images

The {prodname} container images for Zookeeper, Kafka, and Kafka Connect all set up their `log4j.properties` file to configure the Debezium-related loggers.
All log messages are sent to the Docker container's console (and thus the Docker logs).
The log messages are also written to files under the `/kafka/logs` directory.

The containers use a `LOG_LEVEL` environment variable to set the log level for the root logger.
You can use this environment variable to set the log level for the service running in the container.
When you start the container and set the value of this environment variable to a log level (for example, `-e LOG_LEVEL=DEBUG`),
all of the code within the container then uses that log level.

There is also an option to override other log4j properties.  If you want to configure `log4j.rootLogger`
differently, then use the environment variable `CONNECT_LOG4J_LOGGERS`. For example to log only to stdout
(without `appender`), you can use `CONNECT_LOG4J_LOGGERS=INFO, stdout`. You can also set other supported
log4j environment variables with the CONNECT_LOG4J prefix, which will be mapped to properties in the `log4j.properties`
file by removing the `CONNECT_` prefix, lowercasing all characters, and converting all '_' characters to '.'.

If you need more control over the logging configuration,
create a new container image that is based on ours,
except that in your `Dockerfile`, copy your own `log4j.properties` file into the image.
For example:

.Dockerfile
[source,dockerfile,options="nowrap"]
----
...
COPY log4j.properties $KAFKA_HOME/config/log4j.properties
...
----

:leveloffset!:


== Configuring

:leveloffset: +2

:page-aliases: configuration/event-flattening.adoc
// Category: debezium-using
// Type: assembly
// ModuleID: extracting-source-record-after-state-from-debezium-change-events
// Title: Extracting source record `after` state from {prodname} change events
[id="new-record-state-extraction"]
= New Record State Extraction

:toc:
:toc-placement: macro
:linkattrs:
:icons: font
:source-highlighter: highlight.js

toc::[]


{prodname} connectors emits data change messages to represent each operation that they capture from a source database.
The messages that a connector sends to Apache Kafka have a complex structure that faithfully represent the details of the original database event.

Although this complex message format accurately details information about changes that happen in the system, the format might not be suitable for some downstream consumers.
Sink connectors, or other parts of the Kafka ecosystem might require messages that are formatted so that field names and values are presented in a simplified, flattened structure.

To simplify the format of the event records that the {prodname} connectors produce, you can use the {prodname} event flattening single message transformation (SMT).
Configure the transformation to support consumers that require Kafka records to be in a format that is simpler than the default format that that the connector produces.
Depending on your particular use case, you can apply the SMT to a {prodname} connector, or to a sink connector that consumes messages that the {prodname} connector produces.
To enable Apache Kafka to retain the {prodname} change event messages in their original format, configure the SMT for a sink connector.

The event flattening transformation is a
link:https://kafka.apache.org/documentation/#connect_transforms[Kafka Connect SMT].

[NOTE]
====
The information in this chapter describes the event flattening single message transformation (SMT) for {prodname} SQL-based database connectors.
For information about an equivalent SMT for the {prodname} MongoDB connector, see {link-prefix}:{link-mongodb-event-flattening}#mongodb-new-document-state-extraction[MongoDB New Document State Extraction].
====


// Type: concept
// ModuleID: description-of-debezium-change-event-structure
// Title: Description of {prodname} change event structure
== Change event structure

{prodname} generates data change events that have a complex structure.
Each event consists of three parts:

* Metadata, which includes but is not limited to:

** The type of operation that changed the data.
** Source information, such as the names of the database and the table in which the change occurred.
** Timestamp that identifies when the change was made.
** Optional transaction information.

* Row data before the change
* Row data after the change

The following example shows part of the message structure for an `UPDATE` change event:

[source,json,indent=0]
----
{
	"op": "u",
	"source": {
		...
	},
	"ts_ms" : "...",
	"ts_us" : "...",
	"ts_ns" : "...",
	"before" : {
		"field1" : "oldvalue1",
		"field2" : "oldvalue2"
	},
	"after" : {
		"field1" : "newvalue1",
		"field2" : "newvalue2"
	}
}
----

For more information about the change event structure for a connector, see
xref:{link-connectors}[the documentation for the connector].

After the event flattening SMT processes the message in the previous example, it simplifies the message format, resulting in the message in the following example:

[source,json,indent=0]
----
{
	"field1" : "newvalue1",
	"field2" : "newvalue2"
}
----

// Type: concept
// ModuleID: behavior-of-debezium-event-flattening-transformation
// Title: Behavior of {prodname} event flattening transformation
[[event-flattening-behavior]]
== Behavior

The event flattening SMT extracts the `after` field from a {prodname} change event in a Kafka record. The SMT replaces the original change event with only its `after` field to create a simple Kafka record.

You can configure the event flattening SMT for a {prodname} connector or for a sink connector that consumes messages emitted by a {prodname} connector. The advantage of configuring event flattening for a sink connector is that records stored in Apache Kafka contain whole {prodname} change events. The decision to apply the SMT to a source or sink connector depends on your particular use case.

You can configure the transformation to do any of the following:

* Add metadata from the change event to the simplified Kafka record. The default behavior is that the SMT does not add metadata.

* Keep Kafka records that contain change events for `DELETE` operations in the stream. The default behavior is that the SMT drops Kafka records for `DELETE` operation change events because most consumers cannot yet handle them.

A database `DELETE` operation causes {prodname} to generate two Kafka records:

* A record that contains `"op": "d",` the `before` row data, and some other fields.
* A tombstone record that has the same key as the deleted row and a value of `null`. This record is a marker for Apache Kafka. It indicates that
link:{link-kafka-docs}/#compaction[log compaction] can remove all records that have this key.

Instead of dropping the record that contains the `before` row data, you can configure the event flattening SMT to do one of the following:

* Keep the record in the stream and edit it to have only the `"value": "null"` field.

* Keep the record in the stream and edit it to have a `value` field that contains the key/value pairs that were in the `before` field with an added `"__deleted": "true"` entry.

Similarly, instead of dropping the tombstone record, you can configure the event flattening SMT to keep the tombstone record in the stream.

// Type: concept
// ModuleID: configuration-of-debezium-event-flattening-transformation
// Title: Configuration of {prodname} event flattening transformation
== Configuration

Configure the {prodname} event flattening SMT in a Kafka Connect source or sink connector by adding the SMT configuration details to your connector's configuration.
For example, to obtain the default behavior of the transformation, add it to the connector configuration without specifying any options, as in the following example:

[source]
----
transforms=unwrap,...
transforms.unwrap.type=io.debezium.transforms.ExtractNewRecordState
----

As with any Kafka Connect connector configuration, you can set `transforms=` to multiple, comma-separated, SMT aliases in the order in which you want Kafka Connect to apply the SMTs.

The following `.properties` example sets several event flattening SMT options:

[source]
----
transforms=unwrap,...
transforms.unwrap.type=io.debezium.transforms.ExtractNewRecordState
transforms.unwrap.drop.tombstones=false
transforms.unwrap.delete.handling.mode=rewrite
transforms.unwrap.add.fields=table,lsn
----

`drop.tombstones=false`:: Keeps tombstone records for `DELETE` operations in the event stream.

`delete.handling.mode=rewrite`:: For `DELETE` operations, edits the Kafka record by flattening the `value` field that was in the change event. The `value` field directly contains the key/value pairs that were in the `before` field. The SMT adds `__deleted` and sets it to `true`, for example:
+
[source,json,indent=0]
----
"value": {
  "pk": 2,
  "cola": null,
  "__deleted": "true"
}
----

`add.fields=table,lsn`:: Adds change event metadata for the `table` and `lsn` fields to the simplified Kafka record.

.Customizing the configuration
The connector might emit many types of event messages (heartbeat messages, tombstone messages, or metadata messages about transactions or schema changes).
To apply the transformation to a subset of events, you can define xref:options-for-applying-the-event-flattening-transformation-selectively[an SMT predicate statement that selectively applies the transformation] to specific events only.

// Type: concept
// ModuleID: example-of-adding-debezium-metadata-to-the-kafka-record
// Title: Example of adding {prodname} metadata to the Kafka record
== Adding metadata

You can configure the event flattening SMT to add original change event metadata to the simplified Kafka record.
For example, you might want the simplified record's header or value to contain any of the following:

* The type of operation that made the change
* The name of the database or table that was changed
* Connector-specific fields such as the Postgres LSN field

For more information on what is available see xref:{link-connectors}[the documentation for each connector].

To add metadata to the simplified Kafka record's header, specify the `add.headers` option.
To add metadata to the simplified Kafka record's value, specify the `add.fields` option.
Each of these options takes a comma separated list of change event field names. Do not specify spaces. When there are duplicate field names, to add metadata for one of those fields, specify the struct as well as the field. For example:

----
transforms=unwrap,...
transforms.unwrap.type=io.debezium.transforms.ExtractNewRecordState
transforms.unwrap.add.fields=op,table,lsn,source.ts_ms
transforms.unwrap.add.headers=db
transforms.unwrap.delete.handling.mode=rewrite
----

With that configuration, a simplified Kafka record would contain something like the following:

[source,json,indent=0]
----
{
 ...
	"__op" : "c",
	"__table": "MY_TABLE",
	"__lsn": "123456789",
	"__source_ts_ms" : "123456789",
 ...
}
----

Also, simplified Kafka records would have a `__db` header.

In the simplified Kafka record, the SMT prefixes the metadata field names with a double underscore. When you specify a struct, the SMT also inserts an underscore between the struct name and the field name.

To add metadata to a simplified Kafka record that is for a `DELETE` operation, you must also configure `delete.handling.mode=rewrite`.

// Type: concept
// Title: Options for applying the event flattening transformation selectively
// ModuleID: options-for-applying-the-event-flattening-transformation-selectively
[id="options-for-applying-the-event-flattening-transformation-selectively"]
== Options for applying the event-flattening transformation selectively

In addition to the change event messages that a {prodname} connector emits when a database change occurs, the connector also emits other types of messages, including heartbeat messages, and metadata messages about schema changes and transactions.
Because the structure of these other messages differs from the structure of the change event messages that the SMT is designed to process, it's best to configure the connector to selectively apply the SMT, so that it processes only the intended data change messages.

For more information about how to apply the SMT selectively, see {link-prefix}:{link-smt-predicates}#applying-the-event-flattening-transformation-selectively[Configure an SMT predicate for the transformation].

[id="configuration-options"]

// Type: reference
// ModuleID: options-for-configuring-debezium-event-flattening-transformation
// Title: Options for configuring {prodname} event flattening transformation
== Configuration options

The following table describes the options that you can specify to configure the event flattening SMT.

.Descriptions of event flattening SMT configuration options
[cols="30%a,25%a,45%a",subs="+attributes",options="header"]
|===
|Option
|Default
|Description

|[[extract-new-record-state-drop-tombstones]]xref:extract-new-record-state-drop-tombstones[`drop.tombstones`]
|`true`
|{prodname} generates a tombstone record for each `DELETE` operation. The default behavior is that event flattening SMT removes tombstone records from the stream. To keep tombstone records in the stream, specify `drop.tombstones=false`.
[NOTE]
====
This option is scheduled for removal in a future release.
In its place, use the xref:extract-new-record-state-delete-tombstone-handling-mode[`delete.tombstone.handling.mode`] option.
====
|[[extract-new-record-state-delete-handling-mode]]xref:extract-new-record-state-delete-handling-mode[`delete.handling{zwsp}.mode`]
|`drop`
|{prodname} generates a change event record for each `DELETE` operation. The default behavior is that event flattening SMT removes these records from the stream. To keep Kafka records for `DELETE` operations in the stream, set `delete.handling.mode` to `none` or `rewrite`. +
 +
Specify `none` to keep the change event record in the stream. The record contains only `"value": "null"`.  +
 +
Specify `rewrite` to keep the change event record in the stream and edit the record to have a `value` field that contains the key/value pairs that were in the `before` field and also add `+__deleted: true+` to the `value`. This is another way to indicate that the record has been deleted. +
 +
When you  specify `rewrite`, the updated simplified records for `DELETE` operations might be all you need to track deleted records. You can consider accepting the default behavior of dropping the tombstone records that the {prodname} connector creates.
[NOTE]
====
This option is scheduled for removal in a future release.
In its place, use the xref:extract-new-record-state-delete-tombstone-handling-mode[`delete.tombstone.handling.mode`] option.
====

|[[extract-new-record-state-delete-tombstone-handling-mode]]xref:extract-new-record-state-delete-tombstone-handling-mode[`delete.tombstone.handling.mode`]
|No default
|{prodname} generates a change event record for each `DELETE` operation. This setting determines how the event flattening SMT handles `DELETE` events from the stream.

[NOTE]
====
The setting for this option takes precedence over any conflicting settings that you might configure for the deprecated xref:extract-new-record-state-drop-tombstones[`drop.tombstones`] or xref:extract-new-record-state-delete-handling-mode[`delete.handling.mode`] options.
====
Set one of the following options:

`drop`:: The SMT removes both the `DELETE` event and `TOMBSTONE` from the stream.
`tombstone` (default):: The SMT retains `TOMBSTONE` records in the stream.
The `TOMBSTONE` record contains only the following value: `"value": "null"`.
`rewrite`:: The SMT retains the change event record in the stream and makes the following changes:
* Adds a `value` field to the record that contains the key/value pairs from the `before` field of the original record.
* Adds `+__deleted: true+` to the `value` of the record.
* Removes `TOMBSTONE` records.
+
This setting provides another way to indicate that the record has been deleted.

`rewrite-with-tombstone`:: The SMT behaves as it does when you select the `rewrite` option, except that it also retains `TOMBSTONE` records.

|[[extract-new-record-state-route-by-field]]xref:extract-new-record-state-route-by-field[`route.by.field`]
|
|To use row data to determine the topic to route the record to, set this option to an `after` field attribute. The SMT routes the record to the topic whose name matches the value of the specified `after` field attribute. For a `DELETE` operation, set this option to a `before` field attribute. +
 +
For example, configuration of `route.by.field=destination` routes records to the topic whose name is the value of `after.destination`. The default behavior is that a {prodname} connector sends each change event record to a topic whose name is formed from the name of the database and the name of the table in which the change was made. +
 +
If you are configuring the event flattening SMT on a sink connector, setting this option might be useful when the destination topic name dictates the name of the database table that will be updated with the simplified change event record. If the topic name is not correct for your use case, you can configure `route.by.field` to re-route the event.

|[[extract-new-record-state-add-fields-prefix]]xref:extract-new-record-state-add-fields-prefix[`add.fields.prefix`]
| __ (double-underscore)
|Set this optional string to prefix a field.

|[[extract-new-record-state-add-fields]]xref:extract-new-record-state-add-fields[`add.fields`]
|
|Set this option to a comma-separated list, with no spaces, of metadata fields to add to the simplified Kafka record's value. When there are duplicate field names, to add metadata for one of those fields, specify the struct as well as the field, for example `source.ts_ms`. +
 +
Optionally, you can override the field name via `<field name>:<new field name>`, e.g. like so: new field name like `version:VERSION, connector:CONNECTOR, source.ts_ms:EVENT_TIMESTAMP`. Please note that the `new field name` is case-sensitive. +
 +
When the SMT adds metadata fields to the simplified record's value, it prefixes each metadata field name with a double underscore. For a struct specification, the SMT also inserts an underscore between the struct name and the field name. +
 +
If you specify a field that is not in the change event record, the SMT still adds the field to the record's value.

|[[extract-new-record-state-add-headers-prefix]]xref:extract-new-record-state-add-headers-prefix[`add.headers.prefix`]
| __ (double-underscore)
|Set this optional string to prefix a header.

|[[extract-new-record-state-add-headers]]xref:extract-new-record-state-add-headers[`add.headers`]
|
|Set this option to a comma-separated list, with no spaces, of metadata fields to add to the header of the simplified Kafka record. When there are duplicate field names, to add metadata for one of those fields, specify the struct as well as the field, for example `source.ts_ms`. +
 +
Optionally, you can override the field name via `<field name>:<new field name>`, e.g. like so: new field name like `version:VERSION, connector:CONNECTOR, source.ts_ms:EVENT_TIMESTAMP`. Please note that the `new field name` is case-sensitive. +
 +
When the SMT adds metadata fields to the simplified record's header, it prefixes each metadata field name with a double underscore. For a struct specification, the SMT also inserts an underscore between the struct name and the field name. +
 +
If you specify a field that is not in the change event record, the SMT does not add the field to the header.

|[[extract-new-record-state-drop-fields-header-name]]xref:extract-new-record-state-drop-fields-header-name[`drop.fields.header.name`]
|
|The Kafka message header name to use for listing field names in the source message that you want to drop from the output message.

|[[extract-new-record-state-drop-fields-from-key]]xref:extract-new-record-state-drop-fields-from-key[`drop.fields.from.key`]
|`false`
|Specifies whether you want the SMT to remove fields that are listed in `drop.fields.header.name` from the event's key.


|[[extract-new-record-state-drop-fields-keep-schema-compatible]]xref:extract-new-record-state-drop-fields-keep-schema-compatible[`drop.fields.keep.schema.compatible`]
|`true`
|Specifies whether you want the SMT to remove non-optional fields that are included in the xref:extract-new-record-state-drop-fields-header-name[`drop.fields.header.name`] configuration property. +
 +
By default, the SMT only removes fields that are marked `optional`.

|===

:leveloffset!:
:leveloffset: +2

:page-aliases: configuration/topic-routing.adoc
// Category: debezium-using
// Type: assembly
// ModuleID: routing-debezium-event-records-to-topics-that-you-specify
// Title: Routing {prodname} event records to topics that you specify

[id="topic-routing"]
= Topic Routing
:toc:
:toc-placement: macro
:linkattrs:
:icons: font
:source-highlighter: highlight.js

toc::[]

Each Kafka record that contains a data change event has a default destination topic. If you need to, you can re-route records to topics that you specify before the records reach the Kafka Connect converter.
To do this, {prodname} provides the topic routing single message transformation (SMT). Configure this transformation in the {prodname} connector's Kafka Connect configuration. Configuration options enable you to specify the following:

* An expression for identifying the records to re-route
* An expression that resolves to the destination topic
* How to ensure a unique key among the records being re-routed to the destination topic

It is up to you to ensure that the transformation configuration provides the behavior that you want. {prodname} does not validate the behavior that results from your configuration of the transformation.

The topic routing transformation is a
link:https://kafka.apache.org/documentation/#connect_transforms[Kafka Connect SMT].


// Type: concept
// ModuleID: use-case-for-routing-debezium-records-to-topics-that-you-specify
// Title: Use case for routing {prodname} records to topics that you specify
== Use case

The default behavior is that a {prodname} connector sends each change event record to a topic whose name is formed from the name of the database and the name of the table in which the change was made. In other words, a topic receives records for one physical table. When you want a topic to receive records for more than one physical table, you must configure the {prodname} connector to re-route the records to that topic.

.Logical tables

A logical table is a common use case for routing records for multiple physical tables to one topic. In a logical table, there are multiple physical tables that all have the same schema. For example, sharded tables have the same schema. A logical table might consist of two or more sharded tables: `db_shard1.my_table` and `db_shard2.my_table`. The tables are in different shards and are physically distinct but together they form a logical table.
You can re-route change event records for tables in any of the shards to the same topic.

.Partitioned PostgreSQL tables

When the {prodname} PostgreSQL connector captures changes in a partitioned table, the default behavior is that change event records are routed to a different topic for each partition. To emit records from all partitions to one topic, configure the topic routing SMT. Because each key in a partitioned table is guaranteed to be unique, configure xref:by-logical-table-router-key-enforce-uniqueness[`key.enforce.uniqueness=false`] so that the SMT does not add a key field to ensure unique keys. The addition of a key field is default behavior.

// Type: concept
// ModuleID: example-of-routing-debezium-records-for-multiple-tables-to-one-topic
// Title: Example of routing {prodname} records for multiple tables to one topic
== Example

To route change event records for multiple physical tables to the same topic, configure the topic routing transformation in the Kafka Connect configuration for the {prodname} connector. Configuration of the topic routing SMT requires you to specify regular expressions that determine:

* The tables for which to route records. These tables must all have the same schema.
* The destination topic name.

The connector configuration in the following example sets several options for the topic routing SMT:

[source]
----
transforms=Reroute
transforms.Reroute.type=io.debezium.transforms.ByLogicalTableRouter
transforms.Reroute.topic.regex=(.*)customers_shard(.*)
transforms.Reroute.topic.replacement=$1customers_all_shards
----

`topic.regex`:: Specifies a regular expression that the transformation applies to each change event record to determine if it should be routed to a particular topic.
+
In the example, the regular expression, `pass:[(.*)customers_shard(.*)]` matches records for changes to tables whose names include the `customers_shard` string. This would re-route records for tables with the following names:
+
`myserver.mydb.customers_shard1` +
`myserver.mydb.customers_shard2` +
`myserver.mydb.customers_shard3`

`topic.replacement`:: Specifies a regular expression that represents the destination topic name. The transformation routes each matching record to the topic identified by this expression. In this example, records for the three sharded tables listed above would be routed to the `myserver.mydb.customers_all_shards` topic.

`schema.name.adjustment.mode`:: Specifies how the message key schema names derived from the resulting topic name should be adjusted for compatibility with the message converter used by the connector. The value can be `none` (default) or `avro`.

.Customizing the configuration
To customize the configuration you can define xref:options-for-applying-the-transformation-selectively[an SMT predicate statement] that specifies the tables that you want the transformation to process, or not to process.
A predicate might be useful if you configure the SMT to route tables that match a regular expression, and you do not want the SMT to reroute one particular table that matches the expression.

// Type: procedure
// ModuleID: ensuring-unique-keys-across-debezium-records-routed-to-the-same-topic
// Title: Ensuring unique keys across {prodname} records routed to the same topic
== Ensure unique key

A {prodname} change event key uses the table columns that make up the table's primary key. To route records for multiple physical tables to one topic, the event key must be unique across all of those tables. However, it is possible for each physical table to have a primary key that is unique within only that table. For example, a row in the `myserver.mydb.customers_shard1` table might have the same key value as a row in the `myserver.mydb.customers_shard2` table.

To ensure that each event key is unique across the tables whose change event records go to the same topic, the topic routing transformation inserts a field into change event keys. By default, the name of the inserted field is `+__dbz__physicalTableIdentifier+`. The value of the inserted field is the default destination topic name.

If you want to, you can configure the topic routing transformation to insert a different field into the key. To do this, specify the `key.field.name` option and set it to a field name that does not clash with existing primary key field names. For example:

[source]
----
transforms=Reroute
transforms.Reroute.type=io.debezium.transforms.ByLogicalTableRouter
transforms.Reroute.topic.regex=(.*)customers_shard(.*)
transforms.Reroute.topic.replacement=$1customers_all_shards
transforms.Reroute.key.field.name=shard_id
----

This example adds the `shard_id` field to the key structure in routed records.

If you want to adjust the value of the key's new field, configure both of these options:

`key.field.regex`:: Specifies a regular expression that the transformation applies to the default destination topic name to capture one or more groups of characters.

`key.field.replacement`:: Specifies a regular expression for determining the value of the inserted key field in terms of those captured groups.

For example:

[source]
----
transforms.Reroute.key.field.regex=(.*)customers_shard(.*)
transforms.Reroute.key.field.replacement=$2
----

With this configuration, suppose that the default destination topic names are:

`myserver.mydb.customers_shard1` +
`myserver.mydb.customers_shard2` +
`myserver.mydb.customers_shard3`

The transformation uses the values in the second captured group, the shard numbers, as the value of the key's new field. In this example, the inserted key field's values would be `1`, `2`, or `3`.

If your tables contain globally unique keys and you do not need to change the key structure, you can set the `key.enforce.uniqueness` option to `false`:

[source]
----
...
transforms.Reroute.key.enforce.uniqueness=false
...
----

// Type: concept
// Title: Options for applying the topic routing transformation selectively
// ModuleID: options-for-applying-the-topic-routing-transformation-selectively
[id="options-for-applying-the-transformation-selectively"]
== Options for applying the topic routing transformation selectively

In addition to the change event messages that a {prodname} connector emits when a database change occurs, the connector also emits other types of messages, including heartbeat messages, and metadata messages about schema changes and transactions.
Because the structure of these other messages differs from the structure of the change event messages that the SMT is designed to process, it's best to configure the connector to selectively apply the SMT, so that it processes only the intended data change messages.

You can use one of the following methods to configure the connector to apply the SMT selectively:

* {link-prefix}:{link-smt-predicates}#applying-transformations-selectively[Configure an SMT predicate for the transformation].
* Use the xref:by-logical-table-router-topic-regex[topic.regex] configuration option for the SMT.

[[configuration-options]]

// Type: reference
// ModuleID: options-for-configuring-debezium-topic-routing-transformation
// Title: Options for configuring {prodname} topic routing transformation
== Configuration options

The following table describes topic routing SMT configuration options.

.Topic routing SMT configuration options
[cols="30%a,25%a,45%a",subs="+attributes",options="header"]
|===
|Option
|Default
|Description

|[[by-logical-table-router-topic-regex]]xref:by-logical-table-router-topic-regex[`topic.regex`]
|
|Specifies a regular expression that the transformation applies to each change event record to determine if it should be routed to a particular topic.

|[[by-logical-table-router-topic-replacement]]xref:by-logical-table-router-topic-replacement[`topic.replacement`]
|
|Specifies a regular expression that represents the destination topic name. The transformation routes each matching record to the topic identified by this expression. This expression can refer to groups captured by the regular expression that you specify for `topic.regex`. To refer to a group, specify `$1`, `$2`, and so on.

|[[by-logical-table-router-key-enforce-uniqueness]]xref:by-logical-table-router-key-enforce-uniqueness[`key.enforce{zwsp}.uniqueness`]
|`true`
|Indicates whether to add a field to the record's change event key. Adding a key field ensures that each event key is unique across the tables whose change event records go to the same topic. This helps to prevent collisions of change events for records that have the same key but that originate from different source tables. +
 +
Specify `false` if you do not want the transformation to add a key field.  For example, if you are routing records from a partitioned PostgreSQL table to one topic, you can configure `key.enforce.uniqueness=false` because unique keys are guaranteed in partitioned PostgreSQL tables.

|[[by-logical-table-router-key-field-name]]xref:by-logical-table-router-key-field-name[`key.field.name`]
|`+__dbz__physicalTableIdentifier+`
|Name of a field to be added to the change event key. The value of this field identifies the original table name. For the SMT to add this field, `key.enforce.uniqueness` must be `true`, which is the default.

|[[by-logical-table-router-key-field-regex]]xref:by-logical-table-router-key-field-regex[`key.field.regex`]
|
|Specifies a regular expression that the transformation applies to the default destination topic name to capture one or more groups of characters. For the SMT to apply this expression, `key.enforce.uniqueness` must be `true`, which is the default.

|[[by-logical-table-router-key-field-replacement]]xref:by-logical-table-router-key-field-replacement[`key.field{zwsp}.replacement`]
|
|Specifies a regular expression for determining the value of the inserted key field in terms of the groups captured by the expression specified for `key.field.regex`. For the SMT to apply this expression, `key.enforce.uniqueness` must be `true`, which is the default.

|[[by-logical-table-router-schema-name-adjustment-mode]]xref:by-logical-table-router-schema-name-adjustment-mode[`schema.name.adjustment.mode`]
|none
|Specify how the message key schema names derived from the resulting topic name should be adjusted for compatibility with the message converter used by the connector, including: `none` does not apply any adjustment (default), `avro` replaces the characters that cannot be used in the Avro type name with underscore.

|[[by-logical-table-router-logical-table-cache-size]]xref:by-logical-table-router-logical-table-cache-size[`logical.table.cache.size`]
|`16`
|The size used for holding the max entries in LRUCache. The cache will keep the old/new schema for logical table key and value, also cache the derived key and topic regex result for improving the source record transformation.
|===

:leveloffset!:



////
