// Metadata created by nebel
//
// ConversionStatus: raw
// ConvertedFromID: oracle-connector-properties
// ConvertedFromFile: modules/ROOT/pages/connectors/oracle.adoc
// ConvertedFromTitle: Connector properties

[id="descriptions-of-debezium-oracle-connector-configuration-properties"]
= Descriptions of {prodname} Oracle connector configuration properties

The {prodname} Oracle connector has numerous configuration properties that you can use to achieve the right connector behavior for your application.
Many properties have default values.
Information about the properties is organized as follows:

* xref:required-debezium-oracle-connector-configuration-properties[Required {prodname} Oracle connector configuration properties]
* xref:debezium-oracle-connector-database-history-configuration-properties[Database history connector configuration properties] that control how {prodname} processes events that it reads from the database history topic.
** xref:oracle-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[Pass-through database history properties]
* xref:debezium-oracle-connector-pass-through-database-driver-configuration-properties[Pass-through database driver properties] that control the behavior of the database driver.

[id="required-debezium-{context}-connector-configuration-properties"]
.Required {prodname} Oracle connector configuration properties
The following configuration properties are _required_ unless a default value is available.

[cols="30%a,25%a,45%a"]
|===
|Property
|Default
|Description

|[[oracle-property-name]]<<oracle-property-name, `+name+`>>
|No default
|Unique name for the connector. Attempting to register again with the same name will fail. (This property is required by all Kafka Connect connectors.)

|[[oracle-property-connector-class]]<<oracle-property-connector-class, `+connector.class+`>>
|No default
|The name of the Java class for the connector. Always use a value of `io.debezium.connector.oracle.OracleConnector` for the Oracle connector.

|[[oracle-property-tasks-max]]<<oracle-property-tasks-max, `+tasks.max+`>>
|`1`
|The maximum number of tasks that should be created for this connector. The Oracle connector always uses a single task and therefore does not use this value, so the default is always acceptable.

|[[oracle-property-database-hostname]]<<oracle-property-database-hostname, `+database.hostname+`>>
|No default
|IP address or hostname of the Oracle database server.

|[[oracle-property-database-port]]<<oracle-property-database-port, `+database.port+`>>
|No default
|Integer port number of the Oracle database server.

|[[oracle-property-database-user]]<<oracle-property-database-user, `+database.user+`>>
|No default
|Name of the Oracle user account that the connector uses to connect to the Oracle database server.

|[[oracle-property-database-password]]<<oracle-property-database-password, `+database.password+`>>
|No default
|Password to use when connecting to the Oracle database server.

|[[oracle-property-database-dbname]]<<oracle-property-database-dbname, `+database.dbname+`>>
|No default
|Name of the database to connect to. Must be the CDB name when working with the CDB + PDB model.

|[[oracle-property-database-url]]<<oracle-property-database-url, `+database.url+`>>
|No default
|Specifies the raw database JDBC URL. Use this property to provide flexibility in defining that database connection.
ifdef::community[]
Valid values include raw TNS names and RAC connection strings.
endif::community[]
ifdef::product[]
Valid values include raw TNS names connection strings.
endif::product[]

|[[oracle-property-database-pdb-name]]<<oracle-property-database-pdb-name, `+database.pdb.name+`>>
|No default
|Name of the Oracle pluggable database to connect to. Use this property with container database (CDB) installations only.

|[[oracle-property-database-server-name]]<<oracle-property-database-server-name, `+database.server.name+`>>
|No default
|Logical name that identifies and provides a namespace for the Oracle database server from which the connector captures changes.
The value that you set is used as a prefix for all Kafka topic names that the connector emits.
Specify a logical name that is unique among all connectors in your {prodname} environment.
The following characters are valid: alphanumeric characters, hyphens, dots, and underscores.
+
[WARNING]
====
Do not change the value of this property.
If you change the name value, after a restart, instead of continuing to emit events to the original topics, the connector emits subsequent events to topics whose names are based on the new value.
The connector is also unable to recover its database history topic.
====

|[[oracle-property-database-connection-adapter]]<<oracle-property-database-connection-adapter, `+database.connection.adapter+`>>
|`logminer`
|The adapter implementation that the connector uses when it streams database changes.
You can set the following values:

`logminer`(default):: The connector uses the native Oracle LogMiner API.
`xstream`:: The connector uses the Oracle XStreams API.

|[[oracle-property-snapshot-mode]]<<oracle-property-snapshot-mode, `+snapshot.mode+`>>
|_initial_
|Specifies the mode that the connector uses to take snapshots of a captured table.
You can set the following values:

`initial`:: The snapshot includes the structure and data of the captured tables.
Specify this value to populate topics with a complete representation of the data from the captured tables.

`initial_only`:: The snapshot includes the structure and data of the captured tables.
The connector performs an initial snapshot and then stops, without processing any subsequent changes.

`schema_only`:: The snapshot includes only the structure of captured tables.
Specify this value if you want the connector to capture data only for changes that occur after the snapshot.

`schema_only_recovery`:: This is a recovery setting for a connector that has already been capturing changes.
When you restart the connector, this setting enables recovery of a corrupted or lost database history topic.
You might set it periodically to "clean up" a database history topic that has been growing unexpectedly.
Database history topics require infinite retention.
Note this mode is only safe to be used when it is guaranteed that no schema changes happened since the point in time the connector was shut down before and the point in time the snapshot is taken.

After the snapshot is complete, the connector continues to read change events from the database's redo logs except when `snapshot.mode` is configured as `initial_only`.

For more information, see the xref:#oracle-connector-snapshot-mode-options[table of `snapshot.mode` options].

|[[oracle-property-snapshot-locking-mode]]<<oracle-property-snapshot-locking-mode, `+snapshot.locking.mode+`>>
|_shared_
a|Controls whether and for how long the connector holds a table lock. Table locks prevent certain types of changes table operations from occurring while the connector performs a snapshot.
You can set the following values:

`shared`:: Enables concurrent access to the table, but prevents any session from acquiring an exclusive table lock.
  The connector acquires a `ROW SHARE` level lock while it captures table schema.

`none`:: Prevents the connector from acquiring any table locks during the snapshot.
  Use this setting only if no schema changes might occur during the creation of the snapshot.

|[[oracle-property-snapshot-include-collection-list]]<<oracle-property-snapshot-include-collection-list, `+snapshot.include.collection.list+`>>
| All tables specified in `table.include.list`
|An optional, comma-separated list of regular expressions that match the fully-qualified names (`_<schemaName>_._<tableName>_`) of the tables to include in a snapshot.
The specified items must be named in the connector's xref:{context}-property-table-include-list[`table.include.list`] property.
This property takes effect only if the connector's `snapshot.mode` property is set to a value other than `never`. +

This property does not affect the behavior of incremental snapshots.

|[[oracle-property-snapshot-select-statement-overrides]]<<oracle-property-snapshot-select-statement-overrides, `+snapshot.select.statement.overrides+`>>
|No default
|Specifies the table rows to include in a snapshot.
Use the property if you want a snapshot to include only a subset of the rows in a table.
This property affects snapshots only.
It does not apply to events that the connector reads from the log.

The property contains a comma-separated list of fully-qualified table names in the form `_<schemaName>.<tableName>_`. For example, +
 +
`+"snapshot.select.statement.overrides": "inventory.products,customers.orders"+` +
 +
For each table in the list, add a further configuration property that specifies the `SELECT` statement for the connector to run on the table when it takes a snapshot.
The specified `SELECT` statement determines the subset of table rows to include in the snapshot.
Use the following format to specify the name of this `SELECT` statement property: +
 +
`snapshot.select.statement.overrides._<schemaName>_._<tableName>_` +
 +
For example,
`snapshot.select.statement.overrides.customers.orders` +
 +
Example:

From a `customers.orders` table that includes the soft-delete column, `delete_flag`, add the following properties if you want a snapshot to include only those records that are not soft-deleted:

----
"snapshot.select.statement.overrides": "customer.orders",
"snapshot.select.statement.overrides.customer.orders": "SELECT * FROM [customers].[orders] WHERE delete_flag = 0 ORDER BY id DESC"
----

In the resulting snapshot, the connector includes only the records for which `delete_flag = 0`.

|[[oracle-property-schema-include-list]]<<oracle-property-schema-include-list, `+schema.include.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match names of schemas for which you *want* to capture changes. Any schema name not included in `schema.include.list` is excluded from having its changes captured. By default, all non-system schemas have their changes captured. Do not also set the `schema.exclude.list` property.
In environments that use the LogMiner implementation, you must use POSIX regular expressions only.

|[[oracle-property-include-schema-comments]]<<oracle-property-include-schema-comments, `+include.schema.comments+`>>
|`false`
|Boolean value that specifies whether the connector should parse and publish table and column comments on metadata objects. Enabling this option will bring the implications on memory usage. The number and size of logical schema objects is what largely impacts how much memory is consumed by the Debezium connectors, and adding potentially large string data to each of them can potentially be quite expensive.

|[[oracle-property-schema-exclude-list]]<<oracle-property-schema-exclude-list, `+schema.exclude.list+`>>
|No default
|An optional, comma-separated list of regular expressions that match names of schemas for which you *do not* want to capture changes. Any schema whose name is not included in `schema.exclude.list` has its changes captured, with the exception of system schemas. Do not also set the `schema.include.list` property.
In environments that use the LogMiner implementation, you must use POSIX regular expressions only.

|[[oracle-property-table-include-list]]<<oracle-property-table-include-list, `+table.include.list+`>>
|No default
|An optional comma-separated list of regular expressions that match fully-qualified table identifiers for tables to be monitored.
Tables that are not included in the include list are excluded from monitoring.
Each table identifier uses the following format: +
 +
`__<schema_name>.<table_name>__` +
 +
By default, the connector monitors every non-system table in each monitored database.
Do not use this property in combination with `table.exclude.list`.
If you use the LogMiner implementation, use only POSIX regular expressions with this property.

|[[oracle-property-table-exclude-list]]<<oracle-property-table-exclude-list, `+table.exclude.list+`>>
|No default
|An optional comma-separated list of regular expressions that match fully-qualified table identifiers for tables to be excluded from monitoring.
The connector captures change events from any table that is not specified in the exclude list.
Specify the identifier for each table using the following format: +
 +
`_<schemaName>.<tableName>_`.

Do not use this property in combination with `table.include.list`.
If you use the LogMiner implementation, use only POSIX regular expressions with this property.

|[[oracle-property-column-include-list]]<<oracle-property-column-include-list, `+column.include.list+`>>
|No default
|An optional comma-separated list of regular expressions that match the fully-qualified names of columns that want to include in the change event message values.
Fully-qualified names for columns use the following format: `_+
 +
`<Schema_name>.<table_name>.<column_name>_` +
 +
The primary key column is always included in an event's key, even if you do not use this property to explicitly include its value.
If you include this property in the configuration, do not also set the `column.exclude.list` property.

|[[oracle-property-column-exclude-list]]<<oracle-property-column-exclude-list, `+column.exclude.list+`>>
|No default
|An optional comma-separated list of regular expressions that match the fully-qualified names of columns that you want to exclude from change event message values.
Fully-qualified column names use the following format: +
 +
`_<schema_name>.<table_name>.<column_name>_` +
 +
The primary key column is always included in an event's key, even if you use this property to explicitly exclude its value.
If you include this property in the configuration, do not set the `column.include.list` property.

|[[oracle-property-column-mask-hash]]<<oracle-property-column-mask-hash, `column.mask.hash._hashAlgorithm_.with.salt._salt_`>>;
[[oracle-property-column-mask-hash-v2]]<<oracle-property-column-mask-hash-v2, `column.mask.hash.v2._hashAlgorithm_.with.salt._salt_`>>
|_n/a_
|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Fully-qualified names for columns are of the form `_<schemaName>_._<tableName>_._<columnName>_`. +
 +
In the resulting change event record, the values for the specified columns are replaced with pseudonyms. +

A pseudonym consists of the hashed value that results from applying the specified _hashAlgorithm_ and _salt_.
Based on the hash function that is used, referential integrity is maintained, while column values are replaced with pseudonyms.
Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation. +
 +
In the following example, `CzQMA0cB5K` is a randomly selected salt. +

----
column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName
----

If necessary, the pseudonym is automatically shortened to the length of the column.
The connector configuration can include multiple properties that specify different hash algorithms and salts. +
 +
Depending on the _hashAlgorithm_ used, the _salt_ selected, and the actual data set, the resulting data set might not be completely masked. +
 +
Hashing strategy version 2 should be used to ensure fidelity if the value is being hashed in different places or systems.

|[[oracle-property-binary-handling-mode]]<<oracle-property-binary-handling-mode, `+binary.handling.mode+`>>
|bytes
|Specifies how binary (`blob`) columns should be represented in change events, including: `bytes` represents binary data as byte array (default), `base64` represents binary data as base64-encoded String, `hex` represents binary data as hex-encoded (base16) String

|[[oracle-property-schema-name-adjustment-mode]]<<oracle-property-schema-name-adjustment-mode,`+schema.name.adjustment.mode+`>>
|avro
|Specifies how schema names should be adjusted for compatibility with the message converter used by the connector. Possible settings:  +

* `avro` replaces the characters that cannot be used in the Avro type name with underscore. +
* `none` does not apply any adjustment. +

|[[oracle-property-decimal-handling-mode]]<<oracle-property-decimal-handling-mode, `+decimal.handling.mode+`>>
|`precise`
| Specifies how the connector should handle floating point values for `NUMBER`, `DECIMAL` and `NUMERIC` columns.
You can set one of the following options:

`precise` (default):: Represents values precisely by using `java.math.BigDecimal` values represented in change events in a binary form.
`double`:: Represents values by using `double` values.
  Using `double` values is easier, but can result in a loss of precision.
`string`:: Encodes values as formatted strings.
  Using the `string` option is easier to consume, but results in a loss of semantic information about the real type.
  For more information, see <<oracle-decimal-types>>.

|[[oracle-property-interval-handling-mode]]<<oracle-property-interval-handling-mode, `+interval.handling.mode+`>>
|`numeric`
| Specifies how the connector should handle values for `interval` columns: +
 +
`numeric` represents intervals using approximate number of microseconds. +
 +
`string` represents intervals exactly by using the string pattern representation `P<years>Y<months>M<days>DT<hours>H<minutes>M<seconds>S`. For example: `P1Y2M3DT4H5M6.78S`.

|[[oracle-property-event-processing-failure-handling-mode]]<<oracle-property-event-processing-failure-handling-mode, `+event.processing.failure.handling.mode+`>>
|`fail`
| Specifies how the connector should react to exceptions during processing of events.
You can set one of the following options:

`fail`:: Propagates the exception (indicating the offset of the problematic event), causing the connector to stop.
`warn`:: Causes the problematic event to be skipped. The offset of the problematic event is then logged.
`skip`:: Causes the problematic event to be skipped.

|[[oracle-property-max-batch-size]]<<oracle-property-max-batch-size, `+max.batch.size+`>>
|`2048`
|A positive integer value that specifies the maximum size of each batch of events to process during each iteration of this connector.

|[[oracle-property-max-queue-size]]<<oracle-property-max-queue-size, `+max.queue.size+`>>
|`8192`
|Positive integer value that specifies the maximum number of records that the blocking queue can hold.
When {prodname} reads events streamed from the database, it places the events in the blocking queue before it writes them to Kafka.
The blocking queue can provide backpressure for reading change events from the database
in cases where the connector ingests messages faster than it can write them to Kafka, or when Kafka becomes unavailable.
Events that are held in the queue are disregarded when the connector periodically records offsets.
Always set the value of `max.queue.size` to be larger than the value of xref:{context}-property-max-batch-size[`max.batch.size`].

|[[oracle-property-max-queue-size-in-bytes]]<<oracle-property-max-queue-size-in-bytes, `+max.queue.size.in.bytes+`>>
|`0` (disabled)
|A long integer value that specifies the maximum volume of the blocking queue in bytes.
By default, volume limits are not specified for the blocking queue.
To specify the number of bytes that the queue can consume, set this property to a positive long value. +
If xref:oracle-property-max-queue-size[`max.queue.size`] is also set, writing to the queue is blocked when the size of the queue reaches the limit specified by either property.
For example, if you set `max.queue.size=1000`, and `max.queue.size.in.bytes=5000`, writing to the queue is blocked after the queue contains 1000 records, or after the volume of the records in the queue reaches 5000 bytes.

|[[oracle-property-poll-interval-ms]]<<oracle-property-poll-interval-ms, `+poll.interval.ms+`>>
|`1000` (1 second)
|Positive integer value that specifies the number of milliseconds the connector should wait during each iteration for new change events to appear.

|[[oracle-property-tombstones-on-delete]]<<oracle-property-tombstones-on-delete, `+tombstones.on.delete+`>>
|`true`
|Controls whether a _delete_ event is followed by a tombstone event.
The following values are possible:

`true`:: For each delete operation, the connector emits a _delete_ event and a subsequent tombstone event.
`false`:: For each delete operation, the connector emits only a _delete_ event.

After a source record is deleted, a tombstone event (the default behavior) enables Kafka to completely delete all events that share the key of the deleted row in topics that have {link-kafka-docs}/#compaction[log compaction] enabled.

|[[oracle-property-message-key-columns]]<<oracle-property-message-key-columns, `+message.key.columns+`>>
|No default
|A list of expressions that specify the columns that the connector uses to form custom message keys for change event records that it publishes to the Kafka topics for specified tables.

By default, {prodname} uses the primary key column of a table as the message key for records that it emits.
In place of the default, or to specify a key for tables that lack a primary key, you can configure custom message keys based on one or more columns. +
To establish a custom message key for a table, list the table, followed by the columns to use as the message key.
Each list entry takes the following format: +
 +
   `_<fullyQualifiedTableName>_`:``_<keyColumn>_``,``_<keyColumn>_`` +
 +
To base a table key on multiple column names, insert commas between the column names. +
Each fully-qualified table name is a regular expression in the following format: +
 +
`_<schemaName>_._<tableName>_` +
 +
The property can include entries for multiple tables.
Use a semicolon to separate table entries in the list. +
 The following example sets the message key for the tables `inventory.customers` and `purchase.orders`: +
 +
`inventory.customers:pk1,pk2;(.*).purchaseorders:pk3,pk4` +
 +
For the table `inventory.customer`, the columns `pk1` and `pk2` are specified as the message key.
For the `purchaseorders` tables in any schema, the columns `pk3` and `pk4` server as the message key. +
There is no limit to the number of columns that you use to create custom message keys.
However, it's best to use the minimum number that are required to specify a unique key.

|[[oracle-property-column-truncate-to-length-chars]]<<oracle-property-column-truncate-to-length-chars, `column.truncate.to._length_.chars`>>
|No default
|An optional comma-separated list of regular expressions that match the fully-qualified names of character-based columns to be truncated in change event messages if their length exceeds the specified number of characters.
Length is specified as a positive integer. A configuration can include multiple properties that specify different lengths.
Specify the fully-qualified name for columns by using the following format: `_<schemaName>_._<tableName>_._<columnName>_`.

|[[oracle-property-column-mask-with-length-chars]]<<oracle-property-column-mask-with-length-chars, `column.mask.with._length_.chars`>>
|No default
|An optional comma-separated list of regular expressions for masking column names in change event messages by replacing characters with asterisks (`*`). +
Specify the number of characters to replace in the name of the property, for example, `column.mask.with.8.chars`. +
Specify length as a positive integer or zero.
Then add regular expressions to the list for each character-based column name where you want to apply a mask. +
Use the following format to specify fully-qualified column names: `_<schemaName>_._<tableName>_._<columnName>_`. +
 +
The connector configuration can include multiple properties that specify different lengths.

|[[oracle-property-column-propagate-source-type]]<<oracle-property-column-propagate-source-type, `+column.propagate.source.type+`>>
|No default
|An optional comma-separated list of regular expressions that match the fully-qualified names of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change messages.
The schema parameters `pass:[_]pass:[_]debezium.source.column.type`, `pass:[_]pass:[_]debezium.source.column.length`, and `pass:[_]pass:[_]debezium.source.column.scale` are used to propagate the original type name and length (for variable-width types), respectively.
Useful to properly size corresponding columns in sink databases. +
 +
Fully-qualified names for columns are of the form `_<tableName>_._<columnName>_`, or `_<schemaName>_._<tableName>_._<columnName>_`.

|[[oracle-property-datatype-propagate-source-type]]<<oracle-property-datatype-propagate-source-type, `+datatype.propagate.source.type+`>>
|No default
|An optional comma-separated list of regular expressions that match the database-specific data type name of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change messages.
The schema parameters `pass:[_]pass:[_]debezium.source.column.type`, `pass:[_]pass:[_]debezium.source.column.length` and `pass:[_]pass:[_]debezium.source.column.scale` are used to propagate the original type name and length (for variable-width types), respectively.
Useful to properly size corresponding columns in sink databases. +
 +
Fully-qualified data type names are of the form `_<tableName>_._<typeName>_`, or `_<schemaName>_._<tableName>_._<typeName>_`. +
See the xref:{link-oracle-connector}#oracle-data-type-mappings[list of Oracle-specific data type names].

|[[oracle-property-heartbeat-interval-ms]]<<oracle-property-heartbeat-interval-ms, `+heartbeat.interval.ms+`>>
|`0`
|Specifies, in milliseconds, how frequently the connector sends messages to a heartbeat topic. +
Use this property to determine whether the connector continues to receive change events from the source database. +
It can also be useful to set the property in situations where the connector no change events occur in captured tables for an extended period. +
In such a a case, although the connector continues to read the redo log, it emits no change event messages, so that the offset in the Kafka topic remains unchanged.
Because the connector does not flush the latest system change number (SCN) that it read from the database, the database might retain the redo log files for longer than necessary.
If the connector restarts, the extended retention period could result in the connector redundantly sending some change events. +
The default value of `0` prevents the connector from sending any heartbeat messages.

|[[oracle-property-heartbeat-topics-prefix]]<<oracle-property-heartbeat-topics-prefix, `+heartbeat.topics.prefix+`>>
|`__debezium-heartbeat`
|Specifies the string that prefixes the name of the topic to which the connector sends heartbeat messages. +
The topic is named according to the pattern `_<heartbeat.topics.prefix>.<serverName>_`.

|[[oracle-property-snapshot-delay-ms]]<<oracle-property-snapshot-delay-ms, `+snapshot.delay.ms+`>>
|No default
|Specifies an interval in milliseconds that the connector waits after it starts before it takes a snapshot. +
Use this property to prevent snapshot interruptions when you start multiple connectors in a cluster, which might cause re-balancing of connectors.

|[[oracle-property-snapshot-fetch-size]]<<oracle-property-snapshot-fetch-size, `+snapshot.fetch.size+`>>
|`2000`
|Specifies the maximum number of rows that should be read in one go from each table while taking a snapshot.
The connector reads table contents in multiple batches of the specified size.

|[[oracle-property-sanitize-field-names]]<<oracle-property-sanitize-field-names, `+sanitize.field.names+`>>
|`true` when the connector configuration explicitly specifies the `key.converter` or `value.converter` parameters to use Avro, otherwise defaults to `false`.
|Specifies whether field names are normalized to comply with Avro naming requirements.
For more information, see xref:{link-avro-serialization}#avro-naming[Avro naming].

|[[oracle-property-provide-transaction-metadata]]<<oracle-property-provide-transaction-metadata, `+provide.transaction.metadata+`>>
|`false`
|Set the property to `true` if you want {prodname} to generate events with transaction boundaries and enriches data events envelope with transaction metadata.

See xref:{link-oracle-connector}#oracle-transaction-metadata[Transaction Metadata] for additional details.

|[[oracle-property-transaction-topic]]<<oracle-property-transaction-topic, `transaction.topic`>>
|`${database.server.name}.transaction`
|Controls the name of the topic to which the connector sends transaction metadata messages. The placeholder `${database.server.name}` can be used for referring to the connector's logical name; defaults to `${database.server.name}.transaction`, for example `dbserver1.transaction`.

|[[oracle-property-log-mining-strategy]]<<oracle-property-log-mining-strategy, `+log.mining.strategy+`>>
|`redo_log_catalog`
|Specifies the mining strategy that controls how Oracle LogMiner builds and uses a given data dictionary for resolving table and column ids to names. +
 +
`redo_log_catalog`:: Writes the data dictionary to the online redo logs causing more archive logs to be generated over time.
This also enables tracking DDL changes against captured tables, so if the schema changes frequently this is the ideal choice. +
 +
`online_catalog`:: Uses the database's current data dictionary to resolve object ids and does not write any extra information to the online redo logs.
This allows LogMiner to mine substantially faster but at the expense that DDL changes cannot be tracked.
If the captured table(s) schema changes infrequently or never, this is the ideal choice.

|[[oracle-property-log-mining-buffer-type]]<<oracle-property-log-mining-buffer-type, `+log.mining.buffer.type+`>>
|`memory`
|The buffer type controls how the connector manages buffering transaction data. +
 +
`memory` - Uses the JVM process' heap to buffer all transaction data.
Choose this option if you don't expect the connector to process a high number of long-running or large transactions.
When this option is active, the buffer state is not persisted across restarts.
Following a restart, recreate the buffer from the SCN value of the current offset. +
ifdef::community[]
 +
`infinispan` - This option uses an embedded Infinispan cache to buffer transaction data and persist it to disk.
Choose this option if you expect the connector to process long-running or large transactions.
When this option is active, the buffer state is persisted across restarts.
After a restart, there is no need to recreate the buffer.
Since the buffer state is persisted across restarts, the buffer does not need to be recreated at restart.
The infinispan option requires that you specify a cache file directory.
Use the `log.mining.buffer.location` property to define the location for storing cache files.

|[[oracle-property-log-mining-buffer-infinispan-cache-transactions]]<<oracle-property-log-mining-buffer-infinispan-cache-transactions, `+log.mining.buffer.infinispan.cache.transactions+`>>
|No default
|The XML configuration for the Infinispan transaction cache.
For more information, see xref:oracle-event-buffering-infinispan[Infinispan event buffering].

|[[oracle-property-log-mining-buffer-infinispan-cache-events]]<<oracle-property-log-mining-buffer-infinispan-cache-events, `+log.mining.buffer.infinispan.cache.events+`>>
|No default
|The XML configuration for the Infinispan events cache.
For more information, see xref:oracle-event-buffering-infinispan[Infinispan event buffering].

|[[oracle-property-log-mining-buffer-infinispan-cache-processed-transactions]]<<oracle-property-log-mining-buffer-infinispan-cache-processed-transactions, `+log.mining.buffer.infinispan.cache.processed_transactions+`>>
|No default
|The XML configuration for the Infinispan processed transactions cache.
For more information, see xref:oracle-event-buffering-infinispan[Infinispan event buffering].

|[[oracle-property-log-mining-buffer-infinispan-cache-schema-changes]]<<oracle-property-log-mining-buffer-infinispan-cache-schema-changes, `+log.mining.buffer.infinispan.cache.schema_changes+`>>
|No default
|The XML configuration for the Infinispan schema changes cache.

|[[oracle-property-log-mining-buffer-drop-on-stop]]<<oracle-property-log-mining-buffer-drop-on-stop, `+log.mining.buffer.drop.on.stop+`>>
|`false`
|Specifies whether the buffer state is deleted after the connector stops in a graceful, expected way. +
 +
This setting only impacts buffer implementations that persist state across restarts, such as `infinispan`. +
The default behavior is that the buffer state is always retained between restarts. +
 +
Set to `true` only in testing or development environments.
endif::community[]

|[[oracle-property-log-mining-batch-size-min]]<<oracle-property-log-mining-batch-size-min, `+log.mining.batch.size.min+`>>
|`1000`
|The minimum SCN interval size that this connector attempts to read from redo/archive logs. Active batch size is also increased/decreased by this amount for tuning connector throughput when needed.

|[[oracle-property-log-mining-batch-size-max]]<<oracle-property-log-mining-batch-size-max, `+log.mining.batch.size.max+`>>
|`100000`
|The maximum SCN interval size that this connector uses when reading from redo/archive logs.

|[[oracle-property-log-mining-batch-size-default]]<<oracle-property-log-mining-batch-size-default, `+log.mining.batch.size.default+`>>
|`20000`
|The starting SCN interval size that the connector uses for reading data from redo/archive logs.

|[[oracle-property-log-mining-sleep-time-min-ms]]<<oracle-property-log-mining-sleep-time-min-ms, `+log.mining.sleep.time.min.ms+`>>
|`0`
|The minimum amount of time that the connector sleeps after reading data from redo/archive logs and before starting reading data again. Value is in milliseconds.

|[[oracle-property-log-mining-sleep-time-max-ms]]<<oracle-property-log-mining-sleep-time-max-ms, `+log.mining.sleep.time.max.ms+`>>
|`3000`
|The maximum amount of time that the connector ill sleeps after reading data from redo/archive logs and before starting reading data again. Value is in milliseconds.

|[[oracle-property-log-mining-sleep-time-default-ms]]<<oracle-property-log-mining-sleep-time-default-ms, `+log.mining.sleep.time.default.ms+`>>
|`1000`
|The starting amount of time that the connector sleeps after reading data from redo/archive logs and before starting reading data again. Value is in milliseconds.

|[[oracle-property-log-mining-sleep-time-increment-ms]]<<oracle-property-log-mining-sleep-time-increment-ms, `+log.mining.sleep.time.increment.ms+`>>
|`200`
|The maximum amount of time up or down that the connector uses to tune the optimal sleep time when reading data from logminer. Value is in milliseconds.

|[[oracle-property-log-mining-view-fetch-size]]<<oracle-property-log-mining-view-fetch-size, `+log.mining.view.fetch.size+`>>
|`10000`
|The number of content records that the connector fetches from the LogMiner content view.

|[[oracle-property-log-mining-archive-log-hours]]<<oracle-property-log-mining-archive-log-hours, `+log.mining.archive.log.hours+`>>
|`0`
|The number of hours in the past from SYSDATE to mine archive logs.
When the default setting (`0`) is used, the connector mines all archive logs.

|[[oracle-property-log-mining-archive-log-only-mode]]<<oracle-property-log-mining-archive-log-only-mode, `+log.mining.archive.log.only.mode+`>>
|`false`
|Controls whether or not the connector mines changes from just archive logs or a combination of the online redo logs and archive logs (the default). +
 +
Redo logs use a circular buffer that can be archived at any point.
In environments where online redo logs are archived frequently, this can lead to LogMiner session failures.
In contrast to redo logs, archive logs are guaranteed to be reliable.
Set this option to `true` to force the connector to mine archive logs only.
After you set the connector to mine only the archive logs, the latency between an operation being committed and the connector emitting an associated change event might increase.
The degree of latency depends on how frequently the database is configured to archive online redo logs.

|[[oracle-property-log-mining-archive-log-only-scn-poll-interval-ms]]<<oracle-property-log-mining-archive-log-only-scn-poll-interval-ms, `+log.mining.archive.log.only.scn.poll.interval.ms+`>>
|`10000`
|The number of milliseconds the connector will sleep in between polling to determine if the starting system change number is in the archive logs.
If `log.mining.archive.log.only.mode` is not enabled, this setting is not used.

|[[oracle-property-log-mining-transaction-retention-hours]]<<oracle-property-log-mining-transaction-retention-hours, `log.mining.transaction.retention.hours`>>
|`0`
|Positive integer value that specifies the number of hours to retain long running transactions between redo log switches.
When set to `0`, transactions are retained until a commit or rollback is detected.

The LogMiner adapter maintains an in-memory buffer of all running transactions.
Because all of the DML operations that are part of a transaction are buffered until a commit or rollback is detected,
long-running transactions should be avoided in order to not overflow that buffer.
Any transaction that exceeds this configured value is discarded entirely, and the connector does not emit any messages for the operations that were part of the transaction.
ifdef::community[]
While this option allows the behavior to be configured on a case-by-case basis,
we have plans to enhance this behavior in a future release by means of adding a scalable transaction buffer, (see xref:{jira-url}/browse/DBZ-3123[DBZ-3123]).
endif::community[]
|[[oracle-property-log-mining-archive-destination-name]]<<oracle-property-log-mining-archive-destination-name, `+log.mining.archive.destination.name+`>>
|No default
|Specifies the configured Oracle archive destination to use when mining archive logs with LogMiner. +
 +
The default behavior automatically selects the first valid, local configured destination.
However, you can use a specific destination can be used by providing the destination name, for example, `LOG_ARCHIVE_DEST_5`.

|[[oracle-property-log-mining-username-exclude-list]]<<oracle-property-log-mining-username-exclude-list, `+log.mining.username.exclude.list+`>>
|No default
|List of database users to exclude from the LogMiner query.
It can be useful to set this property if you want the capturing process to always exclude the changes that specific users make.

|[[oracle-property-log-mining-scn-gap-detection-gap-size-min]]<<oracle-property-log-mining-scn-gap-detection-gap-size-min, `+log.mining.scn.gap.detection.gap.size.min+`>>
|`1000000`
|Specifies a value that the connector compares to the difference between the current and previous SCN values to determine whether an SCN gap exists.
If the difference between the SCN values  is greater than the specified value, and the time difference is smaller than xref:oracle-property-log-mining-scn-gap-detection-time-interval-max-ms[`log.mining.scn.gap.detection.time.interval.max.ms`] then an SCN gap is detected, and the connector uses a mining window larger than the configured maximum batch.

|[[oracle-property-log-mining-scn-gap-detection-time-interval-max-ms]]<<oracle-property-log-mining-scn-gap-detection-time-interval-max-ms, `+log.mining.scn.gap.detection.time.interval.max.ms+`>>
|`20000`
|Specifies a value,  in milliseconds, that the connector compares to the difference between the current and previous SCN timestamps  to determine whether an SCN gap exists.
If the difference between the timestamps is less than the specified value, and the SCN delta is greater than xref:oracle-property-log-mining-scn-gap-detection-gap-size-min[`log.mining.scn.gap.detection.gap.size.min`], then an SCN gap is detected and the connector uses a mining window larger than the configured maximum batch.

|[[oracle-property-lob-enabled]]<<oracle-property-lob-enabled, `+lob.enabled+`>>
|`false`
|Controls whether or not large object (CLOB or BLOB) column values are emitted in change events. +
 +
By default, change events have large object columns, but the columns contain no values.
There is a certain amount of overhead in processing and managing large object column types and payloads.
To capture large object values and serialized them in change events, set this option to `true`.

NOTE: Use of large object data types is a Technology Preview feature.

|[[oracle-property-unavailable-value-placeholder]]<<oracle-property-unavailable-value-placeholder, `+unavailable.value.placeholder+`>>
|`__debezium_unavailable_value`
|Specifies the constant that the connector provides to indicate that the original value is unchanged and not provided by the database.

ifdef::community[]
|[[oracle-property-rac-nodes]]<<oracle-property-rac-nodes, `+rac.nodes+`>>
|No default
|A comma-separated list of Oracle Real Application Clusters (RAC) node host names or addresses.
This field is required to enable Oracle RAC support.
Specify the list of RAC nodes by using one of the following methods:

* Specify a value for xref:oracle-property-database-port[`database.port`], and use the specified port value for each address in the `rac.nodes` list.
For example:
+
[source,properties]
----
database.port=1521
rac.nodes=192.168.1.100,192.168.1.101
----

* Specify a value for xref:oracle-property-database-port[`database.port`], and override the default port for one or more entries in the list.
The list can include entries that use the default `database.port` value, and entries that define their own unique port values.
For example:
+
[source,properties]
----
database.port=1521
rac.nodes=192.168.1.100,192.168.1.101:1522
----

If you supply a raw JDBC URL for the database by using the xref:oracle-property-database-url[`database.url`] property, instead of defining a value for `database.port`, each RAC node entry must explicitly specify a port value.
endif::community[]

|[[oracle-property-skipped-operations]]<<oracle-property-skipped-operations, `+skipped.operations+`>>
|No default
|A comma-separated list of the operation types that you want the connector to skip during streaming.
You can configure the connector to skip the following types of operations:

* `c` (insert/create)
* `u` (update)
* `d` (delete)
* `t` (truncate)

By default, no operations are skipped.

|[[oracle-property-signal-data-collection]]<<oracle-property-signal-data-collection,`+signal.data.collection+`>>
|No default value
a|Fully-qualified name of the data collection that is used to send xref:{link-signalling}#debezium-signaling-enabling-signaling[signals] to the connector. +
Use the following format to specify the collection name: +
`_<databaseName>_._<schemaName>_._<tableName>_`

|[[oracle-property-incremental-snapshot-chunk-size]]<<oracle-property-incremental-snapshot-chunk-size, `+incremental.snapshot.chunk.size+`>>
|`1024`
|The maximum number of rows that the connector fetches and reads into memory during an incremental snapshot chunk.
Increasing the chunk size provides greater efficiency, because the snapshot runs fewer snapshot queries of a greater size.
However, larger chunk sizes also require more memory to buffer the snapshot data.
Adjust the chunk size to a value that provides the best performance in your environment.

|===

[id="debezium-oracle-connector-database-history-configuration-properties"]
.{prodname} Oracle connector database history configuration properties
{prodname} provides a set of `database.history.*` properties that control how the connector interacts with the schema history topic.

The following table describes the `database.history` properties for configuring the {prodname} connector.

.Connector database history configuration properties
[cols="33%a,17%a,50%a",options="header",subs="+attributes"]
|===
|Property |Default |Description
|[[{context}-property-database-history-kafka-topic]]<<{context}-property-database-history-kafka-topic, `+database.history.kafka.topic+`>>
|
|The full name of the Kafka topic where the connector stores the database schema history.

|[[{context}-property-database-history-kafka-bootstrap-servers]]<<{context}-property-database-history-kafka-bootstrap-servers, `+database.history.kafka.bootstrap.servers+`>>
|
|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster. This connection is used for retrieving the database schema history previously stored by the connector, and for writing each DDL statement read from the source database. Each pair should point to the same Kafka cluster used by the Kafka Connect process.

|[[{context}-property-database-history-kafka-recovery-poll-interval-ms]]<<{context}-property-database-history-kafka-recovery-poll-interval-ms, `+database.history.kafka.recovery.poll.interval.ms+`>>
|`100`
|An integer value that specifies the maximum number of milliseconds the connector should wait during startup/recovery while polling for persisted data. The default is 100ms.

|[[{context}-property-database-history-kafka-query-timeout-ms]]<<{context}-property-database-history-kafka-query-timeout-ms, `+database.history.kafka.query.timeout.ms+`>>
|`3000`
|An integer value that specifies the maximum number of milliseconds the connector should wait while fetching cluster information using Kafka admin client.

|[[{context}-property-database-history-kafka-recovery-attempts]]<<{context}-property-database-history-kafka-recovery-attempts, `+database.history.kafka.recovery.attempts+`>>
|`4`
|The maximum number of times that the connector should try to read persisted history data before the connector recovery fails with an error. The maximum amount of time to wait after receiving no data is `recovery.attempts` x `recovery.poll.interval.ms`.

|[[{context}-property-database-history-skip-unparseable-ddl]]<<{context}-property-database-history-skip-unparseable-ddl, `+database.history.skip.unparseable.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector should ignore malformed or unknown database statements or stop processing so a human can fix the issue.
The safe default is `false`.
Skipping should be used only with care as it can lead to data loss or mangling when the binlog is being processed.

|[[{context}-property-database-history-store-only-monitored-tables-ddl]]<<{context}-property-database-history-store-only-monitored-tables-ddl, `+database.history.store.only.monitored.tables.ddl+`>> +

_Deprecated and scheduled for removal in a future release; use xref:{context}-property-database-history-store-only-captured-tables-ddl[`database.history.store.only.captured.tables.ddl`] instead._
|`false`
|A Boolean value that specifies whether the connector should record all DDL statements +

`true` records only those DDL statements that are relevant to tables whose changes are being captured by {prodname}. Set to `true` with care because missing data might become necessary if you change which tables have their changes captured. +

The safe default is `false`.

|[[{context}-property-database-history-store-only-captured-tables-ddl]]<<{context}-property-database-history-store-only-captured-tables-ddl, `+database.history.store.only.captured.tables.ddl+`>>
|`false`
|A Boolean value that specifies whether the connector should record all DDL statements +

`true` records only those DDL statements that are relevant to tables whose changes are being captured by {prodname}. Set to `true` with care because missing data might become necessary if you change which tables have their changes captured. +

The safe default is `false`.
|===

[id="{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients"]
.Pass-through database history properties for configuring producer and consumer clients
{empty} +
{prodname} relies on a Kafka producer to write schema changes to database history topics.
Similarly, it relies on a Kafka consumer to read from database history topics when a connector starts.
You define the configuration for the Kafka producer and consumer clients by assigning values to a set of pass-through configuration properties that begin with the `database.history.producer.\*` and `database.history.consumer.*` prefixes.
The pass-through producer and consumer database history properties control a range of behaviors, such as how these clients secure connections with the Kafka broker, as shown in the following example:

[source,indent=0]
----
database.history.producer.security.protocol=SSL
database.history.producer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
database.history.producer.ssl.keystore.password=test1234
database.history.producer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
database.history.producer.ssl.truststore.password=test1234
database.history.producer.ssl.key.password=test1234

database.history.consumer.security.protocol=SSL
database.history.consumer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
database.history.consumer.ssl.keystore.password=test1234
database.history.consumer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
database.history.consumer.ssl.truststore.password=test1234
database.history.consumer.ssl.key.password=test1234
----

{prodname} strips the prefix from the property name before it passes the property to the Kafka client.

See the Kafka documentation for more details about link:https://kafka.apache.org/documentation.html#producerconfigs[Kafka producer configuration properties] and link:https://kafka.apache.org/documentation.html#consumerconfigs[Kafka consumer configuration properties].

[id="debezium-oracle-connector-pass-through-database-driver-configuration-properties"]
.{prodname} Oracle connector pass-through database driver configuration properties

The {prodname} connector provides for pass-through configuration of the database driver.
Pass-through database properties begin with the prefix `database.*`.
For example, the connector passes properties such as `database.foobar=false` to the JDBC URL.

As is the case with the xref:{context}-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients[pass-through properties for database history clients], {prodname} strips the prefixes from the properties before it passes them to the database driver.

