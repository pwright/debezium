// Metadata created by nebel
//
// ConvertedFromTitle: Change event values
// ConvertedFromFile: modules/ROOT/pages/connectors/oracle.adoc
// ConversionStatus: raw
// ConvertedFromID: oracle-change-event-values

[id="about-values-in-debezium-oracle-connector-change-events"]
= About values in {prodname} Oracle connector change events

The structure of a value in a change event message mirrors the structure of the xref:oracle-change-event-keys[message key in the change event] in the message, and contains both a _schema_ section and a _payload_ section.

.Payload of a change event value
An _envelope_ structure in the payload sections of a change event value contains the following fields:

`op`:: A mandatory field that contains a string value describing the type of operation.
The `op` field in the payload of an Oracle connector change event value contains one of the following values: `c` (create or insert), `u` (update), `d` (delete), or `r` (read, which indicates a snapshot).
`before`:: An optional field that, if present, describes the state of the row _before_ the event occurred.
The structure is described by the `server1.INVENTORY.CUSTOMERS.Value` Kafka Connect schema, which the `server1` connector uses for all rows in the `inventory.customers` table.

// [WARNING]
// ====
// Whether or not this field and its elements are available is highly dependent on the https://docs.oracle.com/database/121/SUTIL/GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3.htm#SUTIL1583[Supplemental Logging] configuration applying to the table.
// ====

`after`:: An optional field that, if present, contains the state of a row _after_ a change occurs.
The structure is described by the same `server1.INVENTORY.CUSTOMERS.Value` Kafka Connect schema that is used for the `before` field.
`source`:: A mandatory field that contains a structure that describes the source metadata for the event.
In the case of the Oracle connector, the structure includes the following fields:
+
* The {prodname} version.
* The connector name.
* Whether the event is part of an ongoing snapshot or not.
* The transaction id (not includes for snapshots).
* The SCN of the change.
* A timestamp that indicates when the record in the source database changed (for snapshots, the timestamp indicates when the snapshot occurred).
+
[TIP]
====
The `commit_scn` field is optional and describes the SCN of the transaction commit that the change event participates within.
====

`ts_ms`:: An optional field that, if present, contains the time (based on the system clock in the JVM that runs the Kafka Connect task) at which the connector processed the event.

.Schema of a change event value
The _schema_ portion of the event message's value contains a schema that describes the envelope structure of the payload and the nested fields within it.

For more information about change event values, see the following topics:

* xref:oracle-create-events[_create_ events]
* xref:oracle-update-events[_update_ events]
* xref:oracle-delete-events[_delete_ events]
* xref:oracle-truncate-events[_truncate_ events]


// Type: continue
[[oracle-create-events]]
._create_ events

The following example shows the value of a _create_ event value from the `customers` table that is described in the xref:oracle-change-event-keys[change event keys] example:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": {
        "type": "struct",
        "fields": [
            {
                "type": "struct",
                "fields": [
                    {
                        "type": "int32",
                        "optional": false,
                        "field": "ID"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "FIRST_NAME"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "LAST_NAME"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "EMAIL"
                    }
                ],
                "optional": true,
                "name": "server1.DEBEZIUM.CUSTOMERS.Value",
                "field": "before"
            },
            {
                "type": "struct",
                "fields": [
                    {
                        "type": "int32",
                        "optional": false,
                        "field": "ID"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "FIRST_NAME"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "LAST_NAME"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "EMAIL"
                    }
                ],
                "optional": true,
                "name": "server1.DEBEZIUM.CUSTOMERS.Value",
                "field": "after"
            },
            {
                "type": "struct",
                "fields": [
                    {
                        "type": "string",
                        "optional": true,
                        "field": "version"
                    },
                    {
                        "type": "string",
                        "optional": false,
                        "field": "name"
                    },
                    {
                        "type": "int64",
                        "optional": true,
                        "field": "ts_ms"
                    },
                    {
                        "type": "string",
                        "optional": true,
                        "field": "txId"
                    },
                    {
                        "type": "string",
                        "optional": true,
                        "field": "scn"
                    },
                    {
                        "type": "string",
                        "optional": true,
                        "field": "commit_scn"
                    },
                    {
                        "type": "boolean",
                        "optional": true,
                        "field": "snapshot"
                    }
                ],
                "optional": false,
                "name": "io.debezium.connector.oracle.Source",
                "field": "source"
            },
            {
                "type": "string",
                "optional": false,
                "field": "op"
            },
            {
                "type": "int64",
                "optional": true,
                "field": "ts_ms"
            }
        ],
        "optional": false,
        "name": "server1.DEBEZIUM.CUSTOMERS.Envelope"
    },
    "payload": {
        "before": null,
        "after": {
            "ID": 1004,
            "FIRST_NAME": "Anne",
            "LAST_NAME": "Kretchmar",
            "EMAIL": "annek@noanswer.org"
        },
        "source": {
            "version": "{debezium-version}",
            "name": "server1",
            "ts_ms": 1520085154000,
            "txId": "6.28.807",
            "scn": "2122185",
            "commit_scn": "2122185",
            "snapshot": false
        },
        "op": "c",
        "ts_ms": 1532592105975
    }
}
----

In the preceding example, notice how the event defines the following schema:

* The _envelope_ (`server1.DEBEZIUM.CUSTOMERS.Envelope`).
* The `source` structure (`io.debezium.connector.oracle.Source`, which is specific to the Oracle connector and reused across all events).
* The table-specific schemas for the `before` and `after` fields.

[TIP]
====
The names of the schemas for the `before` and `after` fields are of the form `_<logicalName>_._<schemaName>_._<tableName>_.Value`, and thus are entirely independent from the schemas for all other tables.
As a result, when you use the xref:{link-avro-serialization}#avro-serialization[Avro converter], the Avro schemas for tables in each logical source have their own evolution and history.
====

The `payload` portion of this event's _value_, provides information about the event.
It describes that a row was created (`op=c`), and shows that the `after` field value contains the values that were inserted into the `ID`, `FIRST_NAME`, `LAST_NAME`, and `EMAIL` columns of the row.

[TIP]
====
By default, the JSON representations of events are much larger than the rows that they describe.
The larger size is due to the JSON representation including both the schema and payload portions of a message.
You can use the xref:{link-avro-serialization}#avro-serialization[Avro Converter] to decrease the size of messages that the connector writes to Kafka topics.
====

// Type: continue
[[oracle-update-events]]
._update_ events

The following example shows an _update_ change event that the connector captures from the same table as the preceding _create_ event.

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "before": {
            "ID": 1004,
            "FIRST_NAME": "Anne",
            "LAST_NAME": "Kretchmar",
            "EMAIL": "annek@noanswer.org"
        },
        "after": {
            "ID": 1004,
            "FIRST_NAME": "Anne",
            "LAST_NAME": "Kretchmar",
            "EMAIL": "anne@example.com"
        },
        "source": {
            "version": "{debezium-version}",
            "name": "server1",
            "ts_ms": 1520085811000,
            "txId": "6.9.809",
            "scn": "2125544",
            "commit_scn": "2125544",
            "snapshot": false
        },
        "op": "u",
        "ts_ms": 1532592713485
    }
}
----

The payload has the same structure as the payload of a _create_ (insert) event, but the following values are different:

* The value of the `op` field is `u`, signifying that this row changed because of an update.
* The `before` field shows the former state of the row with the values that were present before the `update` database commit.
* The `after` field shows the updated state of the row, with the `EMAIL` value now set to `anne@example.com`.
* The structure of the `source` field includes the same fields as before, but the values are different, because the connector captured the event from a different position in the redo log.
* The `ts_ms` field shows the timestamp that indicates when {prodname} processed the event.

The `payload` section reveals several other useful pieces of information.
For example, by comparing the `before` and `after` structures, we can determine how a row changed as the result of a commit.
The `source` structure provides information about Oracle's record of this change, providing traceability.
It also gives us insight into when this event occurred in relation to other events in this topic and in other topics.
Did it occur before, after, or as part of the same commit as another event?

[NOTE]
====
When the columns for a row's primary/unique key are updated, the value of the row's key changes.
As a result, {prodname} emits _three_ events after such an update:

* A `DELETE` event.
* A xref:{link-oracle-connector}#oracle-tombstone-events[tombstone event] with the old key for the row.
* An `INSERT` event that provides the new key for the row.
====

// Type: continue
[[oracle-delete-events]]
._delete_ events

The following example shows a _delete_ event for the table that is shown in the preceding _create_ and _update_ event examples.
The `schema` portion of the _delete_ event is identical to the `schema` portion for those events.

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "before": {
            "ID": 1004,
            "FIRST_NAME": "Anne",
            "LAST_NAME": "Kretchmar",
            "EMAIL": "anne@example.com"
        },
        "after": null,
        "source": {
            "version": "{debezium-version}",
            "name": "server1",
            "ts_ms": 1520085153000,
            "txId": "6.28.807",
            "scn": "2122184",
            "commit_scn": "2122184",
            "snapshot": false
        },
        "op": "d",
        "ts_ms": 1532592105960
    }
}
----

The `payload` portion of the event reveals several differences when compared to the payload of a _create_ or _update_ event:

* The value of the `op` field is `d`, signifying that the row was deleted.
* The `before` field shows the former state of the row that was deleted with the database commit.
* The value of the `after` field is `null`, signifying that the row no longer exists.
* The structure of the `source` field includes many of the keys that exist in _create_ or _update_ events, but the values in the `ts_ms`, `scn`, and `txId` fields are different.
* The `ts_ms` shows a timestamp that indicates when {prodname} processed this event.

The _delete_ event provides consumers with the information that they require to process the removal of this row.

The Oracle connector's events are designed to work with https://cwiki.apache.org/confluence/display/KAFKA/Log+Compaction[Kafka log compaction],
which allows for the removal of some older messages as long as at least the most recent message for every key is kept.
This allows Kafka to reclaim storage space while ensuring the topic contains a complete dataset and can be used for reloading key-based state.

[[oracle-tombstone-events]]
When a row is deleted, the _delete_ event value shown in the preceding example still works with log compaction, because Kafka is able to remove all earlier messages that use the same key.
The message value must be set to `null` to instruct Kafka to remove _all messages_ that share the same key.
To make this possible, by default, {prodname}'s Oracle connector always follows a _delete_ event with a special _tombstone_ event that has the same key but `null` value.
You can change the default behavior by setting the connector property xref:oracle-property-tombstones-on-delete[`tombstones.on.delete`].

// Type: continue
[[oracle-truncate-events]]
._truncate_ events

A  _truncate_ change event signals that a table has been truncated.
The message key is `null` in this case, the message value looks like this:

[source,json,indent=0,subs="+attributes"]
----
{
    "schema": { ... },
    "payload": {
        "before": null,
        "after": null,
        "source": { // <1>
            "version": "{debezium-version}",
            "connector": "oracle",
            "name": "oracle_server",
            "ts_ms": 1638974535000,
            "snapshot": "false",
            "db": "ORCLPDB1",
            "sequence": null,
            "schema": "DEBEZIUM",
            "table": "TEST_TABLE",
            "txId": "02000a0037030000",
            "scn": "13234397",
            "commit_scn": "13271102",
            "lcr_position": null
        },
        "op": "t", // <2>
        "ts_ms": 1638974558961, // <3>
        "transaction": null
    }
}
----

.Descriptions of _truncate_ event value fields
[cols="1,2,7",options="header"]
|===
|Item |Field name |Description

|1
|`source`
a|Mandatory field that describes the source metadata for the event. In a _truncate_ event value, the `source` field structure is the same as for _create_, _update_, and _delete_ events for the same table, provides this metadata:

* {prodname} version
* Connector type and name
* Database and table that contains the new row
* Schema name
* If the event was part of a snapshot (always `false` for _truncate_ events)
* ID of the transaction in which the operation was performed
* SCN of the operation
* Timestamp for when the change was made in the database

|2
|`op`
a|Mandatory string that describes the type of operation. The `op` field value is `t`, signifying that this table was truncated.

|3
|`ts_ms`
a|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.  +
+
In the `source` object, `ts_ms` indicates the time that the change was made in the database. By comparing the value for `payload.source.ts_ms` with the value for `payload.ts_ms`, you can determine the lag between the source database update and {prodname}.

|===

Because _truncate_ events represent changes made to an entire table, and have no message key, in topics with multiple partitions, there is no guarantee that consumers receive _truncate_ events and change events (_create_, _update_, etc.) for to a table in order.
For example, when a consumer reads events from different partitions, it might receive an _update_ event for a table after it receives a _truncate_ event for the same table.
Ordering can be guaranteed only if a topic uses a single partition.

If you do not want to capture _truncate_ events, use the xref:oracle-property-skipped-operations[`skipped.operations`] option to filter them out.

